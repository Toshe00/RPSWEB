{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/browser-utils/node_modules/detect-browser/es/index.js"],"sourcesContent":["var __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nvar BrowserInfo = /** @class */ (function () {\n    function BrowserInfo(name, version, os) {\n        this.name = name;\n        this.version = version;\n        this.os = os;\n        this.type = 'browser';\n    }\n    return BrowserInfo;\n}());\nexport { BrowserInfo };\nvar NodeInfo = /** @class */ (function () {\n    function NodeInfo(version) {\n        this.version = version;\n        this.type = 'node';\n        this.name = 'node';\n        this.os = process.platform;\n    }\n    return NodeInfo;\n}());\nexport { NodeInfo };\nvar SearchBotDeviceInfo = /** @class */ (function () {\n    function SearchBotDeviceInfo(name, version, os, bot) {\n        this.name = name;\n        this.version = version;\n        this.os = os;\n        this.bot = bot;\n        this.type = 'bot-device';\n    }\n    return SearchBotDeviceInfo;\n}());\nexport { SearchBotDeviceInfo };\nvar BotInfo = /** @class */ (function () {\n    function BotInfo() {\n        this.type = 'bot';\n        this.bot = true; // NOTE: deprecated test name instead\n        this.name = 'bot';\n        this.version = null;\n        this.os = null;\n    }\n    return BotInfo;\n}());\nexport { BotInfo };\nvar ReactNativeInfo = /** @class */ (function () {\n    function ReactNativeInfo() {\n        this.type = 'react-native';\n        this.name = 'react-native';\n        this.version = null;\n        this.os = null;\n    }\n    return ReactNativeInfo;\n}());\nexport { ReactNativeInfo };\n// tslint:disable-next-line:max-line-length\nvar SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;\nvar SEARCHBOT_OS_REGEX = /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\\ Jeeves\\/Teoma|ia_archiver)/;\nvar REQUIRED_VERSION_PARTS = 3;\nvar userAgentRules = [\n    ['aol', /AOLShield\\/([0-9\\._]+)/],\n    ['edge', /Edge\\/([0-9\\._]+)/],\n    ['edge-ios', /EdgiOS\\/([0-9\\._]+)/],\n    ['yandexbrowser', /YaBrowser\\/([0-9\\._]+)/],\n    ['kakaotalk', /KAKAOTALK\\s([0-9\\.]+)/],\n    ['samsung', /SamsungBrowser\\/([0-9\\.]+)/],\n    ['silk', /\\bSilk\\/([0-9._-]+)\\b/],\n    ['miui', /MiuiBrowser\\/([0-9\\.]+)$/],\n    ['beaker', /BeakerBrowser\\/([0-9\\.]+)/],\n    ['edge-chromium', /EdgA?\\/([0-9\\.]+)/],\n    [\n        'chromium-webview',\n        /(?!Chrom.*OPR)wv\\).*Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/,\n    ],\n    ['chrome', /(?!Chrom.*OPR)Chrom(?:e|ium)\\/([0-9\\.]+)(:?\\s|$)/],\n    ['phantomjs', /PhantomJS\\/([0-9\\.]+)(:?\\s|$)/],\n    ['crios', /CriOS\\/([0-9\\.]+)(:?\\s|$)/],\n    ['firefox', /Firefox\\/([0-9\\.]+)(?:\\s|$)/],\n    ['fxios', /FxiOS\\/([0-9\\.]+)/],\n    ['opera-mini', /Opera Mini.*Version\\/([0-9\\.]+)/],\n    ['opera', /Opera\\/([0-9\\.]+)(?:\\s|$)/],\n    ['opera', /OPR\\/([0-9\\.]+)(:?\\s|$)/],\n    ['ie', /Trident\\/7\\.0.*rv\\:([0-9\\.]+).*\\).*Gecko$/],\n    ['ie', /MSIE\\s([0-9\\.]+);.*Trident\\/[4-7].0/],\n    ['ie', /MSIE\\s(7\\.0)/],\n    ['bb10', /BB10;\\sTouch.*Version\\/([0-9\\.]+)/],\n    ['android', /Android\\s([0-9\\.]+)/],\n    ['ios', /Version\\/([0-9\\._]+).*Mobile.*Safari.*/],\n    ['safari', /Version\\/([0-9\\._]+).*Safari/],\n    ['facebook', /FBAV\\/([0-9\\.]+)/],\n    ['instagram', /Instagram\\s([0-9\\.]+)/],\n    ['ios-webview', /AppleWebKit\\/([0-9\\.]+).*Mobile/],\n    ['ios-webview', /AppleWebKit\\/([0-9\\.]+).*Gecko\\)$/],\n    ['searchbot', SEARCHBOX_UA_REGEX],\n];\nvar operatingSystemRules = [\n    ['iOS', /iP(hone|od|ad)/],\n    ['Android OS', /Android/],\n    ['BlackBerry OS', /BlackBerry|BB10/],\n    ['Windows Mobile', /IEMobile/],\n    ['Amazon OS', /Kindle/],\n    ['Windows 3.11', /Win16/],\n    ['Windows 95', /(Windows 95)|(Win95)|(Windows_95)/],\n    ['Windows 98', /(Windows 98)|(Win98)/],\n    ['Windows 2000', /(Windows NT 5.0)|(Windows 2000)/],\n    ['Windows XP', /(Windows NT 5.1)|(Windows XP)/],\n    ['Windows Server 2003', /(Windows NT 5.2)/],\n    ['Windows Vista', /(Windows NT 6.0)/],\n    ['Windows 7', /(Windows NT 6.1)/],\n    ['Windows 8', /(Windows NT 6.2)/],\n    ['Windows 8.1', /(Windows NT 6.3)/],\n    ['Windows 10', /(Windows NT 10.0)/],\n    ['Windows ME', /Windows ME/],\n    ['Open BSD', /OpenBSD/],\n    ['Sun OS', /SunOS/],\n    ['Chrome OS', /CrOS/],\n    ['Linux', /(Linux)|(X11)/],\n    ['Mac OS', /(Mac_PowerPC)|(Macintosh)/],\n    ['QNX', /QNX/],\n    ['BeOS', /BeOS/],\n    ['OS/2', /OS\\/2/],\n];\nexport function detect(userAgent) {\n    if (!!userAgent) {\n        return parseUserAgent(userAgent);\n    }\n    if (typeof document === 'undefined' &&\n        typeof navigator !== 'undefined' &&\n        navigator.product === 'ReactNative') {\n        return new ReactNativeInfo();\n    }\n    if (typeof navigator !== 'undefined') {\n        return parseUserAgent(navigator.userAgent);\n    }\n    return getNodeVersion();\n}\nfunction matchUserAgent(ua) {\n    // opted for using reduce here rather than Array#first with a regex.test call\n    // this is primarily because using the reduce we only perform the regex\n    // execution once rather than once for the test and for the exec again below\n    // probably something that needs to be benchmarked though\n    return (ua !== '' &&\n        userAgentRules.reduce(function (matched, _a) {\n            var browser = _a[0], regex = _a[1];\n            if (matched) {\n                return matched;\n            }\n            var uaMatch = regex.exec(ua);\n            return !!uaMatch && [browser, uaMatch];\n        }, false));\n}\nexport function browserName(ua) {\n    var data = matchUserAgent(ua);\n    return data ? data[0] : null;\n}\nexport function parseUserAgent(ua) {\n    var matchedRule = matchUserAgent(ua);\n    if (!matchedRule) {\n        return null;\n    }\n    var name = matchedRule[0], match = matchedRule[1];\n    if (name === 'searchbot') {\n        return new BotInfo();\n    }\n    var versionParts = match[1] && match[1].split(/[._]/).slice(0, 3);\n    if (versionParts) {\n        if (versionParts.length < REQUIRED_VERSION_PARTS) {\n            versionParts = __spreadArrays(versionParts, createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length));\n        }\n    }\n    else {\n        versionParts = [];\n    }\n    var version = versionParts.join('.');\n    var os = detectOS(ua);\n    var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);\n    if (searchBotMatch && searchBotMatch[1]) {\n        return new SearchBotDeviceInfo(name, version, os, searchBotMatch[1]);\n    }\n    return new BrowserInfo(name, version, os);\n}\nexport function detectOS(ua) {\n    for (var ii = 0, count = operatingSystemRules.length; ii < count; ii++) {\n        var _a = operatingSystemRules[ii], os = _a[0], regex = _a[1];\n        var match = regex.exec(ua);\n        if (match) {\n            return os;\n        }\n    }\n    return null;\n}\nexport function getNodeVersion() {\n    var isNode = typeof process !== 'undefined' && process.version;\n    return isNode ? new NodeInfo(process.version.slice(1)) : null;\n}\nfunction createVersionParts(count) {\n    var output = [];\n    for (var ii = 0; ii < count; ii++) {\n        output.push('0');\n    }\n    return output;\n}\n"],"names":[],"mappings":"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","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 387, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 392, "column": 0}, "map": {"version":3,"file":"delay.js","sourceRoot":"","sources":["../../../src/utils/delay.ts"],"names":[],"mappings":";;;;;AAAA,SAAgB,KAAK,CAAC,OAAe;IACnC,OAAO,IAAI,OAAO,EAAC,OAAO,CAAC,EAAE;QAC3B,UAAU,CAAC,GAAG,EAAE;YACd,OAAO,CAAC,IAAI,CAAC,CAAC;QAChB,CAAC,EAAE,OAAO,CAAC,CAAC;IACd,CAAC,CAAC,CAAC;AACL,CAAC;AAND,QAAA,KAAA,GAAA,MAMC","debugId":null}},
    {"offset": {"line": 405, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 410, "column": 0}, "map": {"version":3,"file":"misc.js","sourceRoot":"","sources":["../../../src/constants/misc.ts"],"names":[],"mappings":";;;;;AAEa,QAAA,WAAW,GAAG,GAAG,CAAC;AAElB,QAAA,YAAY,GAAG,IAAI,CAAC","debugId":null}},
    {"offset": {"line": 417, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 422, "column": 0}, "map": {"version":3,"file":"time.js","sourceRoot":"","sources":["../../../src/constants/time.ts"],"names":[],"mappings":";;;;;AAEa,QAAA,UAAU,GAAG,CAAC,CAAC;AAEf,QAAA,YAAY,GAAG,CAAC,CAAC;AAEjB,QAAA,WAAW,GAAG,EAAE,CAAC;AAEjB,QAAA,cAAc,GAAG,EAAE,CAAC;AAEpB,QAAA,aAAa,GAAG,EAAE,CAAC;AAInB,QAAA,UAAU,GAAG,QAAA,aAAa,CAAC;AAE3B,QAAA,YAAY,GAAG,QAAA,UAAU,GAAG,CAAC,CAAC;AAE9B,QAAA,WAAW,GAAG,QAAA,UAAU,GAAG,EAAE,CAAC;AAE9B,QAAA,cAAc,GAAG,QAAA,UAAU,GAAG,EAAE,CAAC;AAEjC,QAAA,aAAa,GAAG,QAAA,UAAU,GAAG,EAAE,CAAC;AAIhC,QAAA,QAAQ,GAAG,QAAA,aAAa,CAAC;AAEzB,QAAA,WAAW,GAAG,QAAA,QAAQ,GAAG,CAAC,CAAC;AAE3B,QAAA,SAAS,GAAG,QAAA,QAAQ,GAAG,CAAC,CAAC;AAEzB,QAAA,YAAY,GAAG,QAAA,QAAQ,GAAG,EAAE,CAAC;AAE7B,QAAA,iBAAiB,GAAG,QAAA,QAAQ,GAAG,EAAE,CAAC;AAIlC,QAAA,OAAO,GAAG,QAAA,iBAAiB,CAAC;AAE5B,QAAA,UAAU,GAAG,QAAA,OAAO,GAAG,CAAC,CAAC;AAEzB,QAAA,SAAS,GAAG,QAAA,OAAO,GAAG,CAAC,CAAC;AAExB,QAAA,UAAU,GAAG,QAAA,OAAO,GAAG,CAAC,CAAC;AAEzB,QAAA,WAAW,GAAG,QAAA,OAAO,GAAG,EAAE,CAAC;AAI3B,QAAA,QAAQ,GAAG,QAAA,UAAU,CAAC;AAEtB,QAAA,SAAS,GAAG,QAAA,QAAQ,GAAG,CAAC,CAAC;AAEzB,QAAA,WAAW,GAAG,QAAA,QAAQ,GAAG,CAAC,CAAC;AAE3B,QAAA,UAAU,GAAG,QAAA,QAAQ,GAAG,CAAC,CAAC;AAI1B,QAAA,QAAQ,GAAG,QAAA,OAAO,GAAG,GAAG,CAAC","debugId":null}},
    {"offset": {"line": 452, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 457, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/constants/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,0HAAA,SAAuB;AACvB,QAAA,YAAA,0HAAA,SAAuB","debugId":null}},
    {"offset": {"line": 464, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 469, "column": 0}, "map": {"version":3,"file":"convert.js","sourceRoot":"","sources":["../../../src/utils/convert.ts"],"names":[],"mappings":";;;;;AAAA,MAAA,sCAA4C;AAE5C,SAAgB,aAAa,CAAC,OAAe;IAC3C,OAAO,OAAO,GAAG,YAAA,YAAY,CAAC;AAChC,CAAC;AAFD,QAAA,aAAA,GAAA,cAEC;AAED,SAAgB,eAAe,CAAC,WAAmB;IACjD,OAAO,IAAI,CAAC,KAAK,CAAC,WAAW,GAAG,YAAA,YAAY,CAAC,CAAC;AAChD,CAAC;AAFD,QAAA,eAAA,GAAA,gBAEC","debugId":null}},
    {"offset": {"line": 483, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 488, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/utils/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,uHAAA,SAAwB;AACxB,QAAA,YAAA,yHAAA,SAA0B","debugId":null}},
    {"offset": {"line": 495, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 500, "column": 0}, "map": {"version":3,"file":"watch.js","sourceRoot":"","sources":["../../src/watch.ts"],"names":[],"mappings":";;;;;AAEA,MAAa,KAAK;IAAlB,aAAA;QACS,IAAA,CAAA,UAAU,GAAG,IAAI,GAAG,EAAyB,CAAC;IA+BvD,CAAC;IA7BQ,KAAK,CAAC,KAAa,EAAA;QACxB,IAAI,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,EAAE;YAC9B,MAAM,IAAI,KAAK,CAAC,CAAA,iCAAA,EAAoC,KAAK,EAAE,CAAC,CAAC;SAC9D;QACD,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAE;YAAE,OAAO,EAAE,IAAI,CAAC,GAAG,EAAE;QAAA,CAAE,CAAC,CAAC;IACtD,CAAC;IAEM,IAAI,CAAC,KAAa,EAAA;QACvB,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAClC,IAAI,OAAO,SAAS,CAAC,OAAO,KAAK,WAAW,EAAE;YAC5C,MAAM,IAAI,KAAK,CAAC,CAAA,iCAAA,EAAoC,KAAK,EAAE,CAAC,CAAC;SAC9D;QACD,MAAM,OAAO,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC,OAAO,CAAC;QAC/C,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,EAAE;YAAE,OAAO,EAAE,SAAS,CAAC,OAAO;YAAE,OAAO;QAAA,CAAE,CAAC,CAAC;IACtE,CAAC;IAEM,GAAG,CAAC,KAAa,EAAA;QACtB,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAC7C,IAAI,OAAO,SAAS,KAAK,WAAW,EAAE;YACpC,MAAM,IAAI,KAAK,CAAC,CAAA,8BAAA,EAAiC,KAAK,EAAE,CAAC,CAAC;SAC3D;QACD,OAAO,SAAS,CAAC;IACnB,CAAC;IAEM,OAAO,CAAC,KAAa,EAAA;QAC1B,MAAM,SAAS,GAAG,IAAI,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;QAClC,MAAM,OAAO,GAAG,SAAS,CAAC,OAAO,IAAI,IAAI,CAAC,GAAG,EAAE,GAAG,SAAS,CAAC,OAAO,CAAC;QACpE,OAAO,OAAO,CAAC;IACjB,CAAC;CACF;AAhCD,QAAA,KAAA,GAAA,MAgCC;AAED,QAAA,OAAA,GAAe,KAAK,CAAC","debugId":null}},
    {"offset": {"line": 543, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 548, "column": 0}, "map": {"version":3,"file":"watch.js","sourceRoot":"","sources":["../../../src/types/watch.ts"],"names":[],"mappings":";;;;;AAKA,MAAsB,MAAM;CAU3B;AAVD,QAAA,MAAA,GAAA,OAUC","debugId":null}},
    {"offset": {"line": 556, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 561, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../../src/types/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,uHAAA,SAAwB","debugId":null}},
    {"offset": {"line": 567, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 572, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,uHAAA,SAAwB;AACxB,QAAA,YAAA,iHAAA,SAAwB;AACxB,QAAA,YAAA,uHAAA,SAAwB;AACxB,QAAA,YAAA,2HAAA,SAA4B","debugId":null}},
    {"offset": {"line": 581, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 587, "column": 0}, "map": {"version":3,"file":"events.js","sourceRoot":"","sources":["../../src/events.ts"],"names":[],"mappings":";;;AAEM,MAAgB,OAAO;CAQ5B","debugId":null}},
    {"offset": {"line": 592, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 598, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 601, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 616, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/heartbeat/src/types/heartbeat.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/heartbeat/src/constants/heartbeat.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/heartbeat/src/heartbeat.ts"],"sourcesContent":["import { IEvents } from \"@walletconnect/events\";\n\nexport interface HeartBeatOptions {\n  interval?: number; // in seconds\n}\n\nexport abstract class IHeartBeat extends IEvents {\n  public abstract interval: number;\n\n  // @ts-ignore - `opts` is not used in the abstract class\n  constructor(opts?: HeartBeatOptions) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n  public abstract stop(): void;\n}\n","import { FIVE_SECONDS } from \"@walletconnect/time\";\n\nexport const HEARTBEAT_INTERVAL = FIVE_SECONDS;\n\nexport const HEARTBEAT_EVENTS = {\n  pulse: \"heartbeat_pulse\",\n};\n","import { EventEmitter } from \"events\";\nimport { toMiliseconds } from \"@walletconnect/time\";\n\nimport { IHeartBeat, HeartBeatOptions } from \"./types\";\n\nimport { HEARTBEAT_INTERVAL, HEARTBEAT_EVENTS } from \"./constants\";\n\nexport class HeartBeat extends IHeartBeat {\n  static async init(opts?: HeartBeatOptions) {\n    const heartbeat = new HeartBeat(opts);\n    await heartbeat.init();\n    return heartbeat;\n  }\n\n  public events = new EventEmitter();\n\n  public interval = HEARTBEAT_INTERVAL;\n  private intervalRef?: ReturnType<typeof setInterval>;\n\n  constructor(opts?: HeartBeatOptions) {\n    super(opts);\n    this.interval = opts?.interval || HEARTBEAT_INTERVAL;\n  }\n\n  public async init(): Promise<void> {\n    await this.initialize();\n  }\n\n  public stop(): void {\n    clearInterval(this.intervalRef);\n  }\n\n  public on(event: string, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private async initialize(): Promise<any> {\n    this.intervalRef = setInterval(() => this.pulse(), toMiliseconds(this.interval));\n  }\n\n  private pulse() {\n    this.events.emit(HEARTBEAT_EVENTS.pulse);\n  }\n}\n"],"names":["IEvents","opts","FIVE_SECONDS","IHeartBeat","EventEmitter","HEARTBEAT_INTERVAL","heartbeat","event","listener","toMiliseconds","HEARTBEAT_EVENTS"],"mappings":"","ignoreList":[0,1,2],"debugId":null}},
    {"offset": {"line": 672, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 678, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;AAQA,MAAM,aAAa,IAAG,IAAI,CAAC,EAAE,AAC3B,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,CAC9B,CADgC,MACzB,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAC3D,CAAC;AASJ,MAAM,SAAS,IAAG,IAAI,CAAC,EAAE;IAMvB,MAAM,uBAAuB,GAAG,oQAAoQ,CAAC;IACrS,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,uBAAuB,EAAE,aAAa,CAAC,CAAC;IAE5E,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE;QAC7C,MAAM,oBAAoB,GACxB,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAErD,IAAI,oBAAoB,EACtB,OAAO,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAEtD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEI,SAAU,aAAa,CAAU,KAAa;IAClD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAI,KAAK,CAAC,CAAA,qCAAA,EAAwC,OAAO,KAAK,EAAE,CAAC,CAAC;KACzE;IACD,IAAI;QACF,OAAO,SAAS,CAAC,KAAK,CAAC,CAAC;KACzB,CAAC,OAAA,IAAM;QACN,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAEK,SAAU,iBAAiB,CAAC,KAAU;IAC1C,OAAO,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;AACxE,CAAC","debugId":null}},
    {"offset": {"line": 705, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 711, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;AAQA,MAAM,aAAa,IAAG,IAAI,CAAC,EAAE,AAC3B,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,CAC9B,CADgC,MACzB,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAC3D,CAAC;AASJ,MAAM,SAAS,IAAG,IAAI,CAAC,EAAE;IAMvB,MAAM,uBAAuB,GAAG,oQAAoQ,CAAC;IACrS,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,uBAAuB,EAAE,aAAa,CAAC,CAAC;IAE5E,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE;QAC7C,MAAM,oBAAoB,GACxB,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAErD,IAAI,oBAAoB,EACtB,OAAO,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAEtD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEI,SAAU,aAAa,CAAU,KAAa;IAClD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAI,KAAK,CAAC,CAAA,qCAAA,EAAwC,OAAO,KAAK,EAAE,CAAC,CAAC;KACzE;IACD,IAAI;QACF,OAAO,SAAS,CAAC,KAAK,CAAC,CAAC;KACzB,CAAC,OAAA,IAAM;QACN,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAEK,SAAU,iBAAiB,CAAC,KAAU;IAC1C,OAAO,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;AACxE,CAAC","debugId":null}},
    {"offset": {"line": 738, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 744, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;AAQA,MAAM,aAAa,IAAG,IAAI,CAAC,EAAE,AAC3B,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,CAC9B,CADgC,MACzB,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAC3D,CAAC;AASJ,MAAM,SAAS,IAAG,IAAI,CAAC,EAAE;IAMvB,MAAM,uBAAuB,GAAG,oQAAoQ,CAAC;IACrS,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,uBAAuB,EAAE,aAAa,CAAC,CAAC;IAE5E,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE;QAC7C,MAAM,oBAAoB,GACxB,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAErD,IAAI,oBAAoB,EACtB,OAAO,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAEtD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEI,SAAU,aAAa,CAAU,KAAa;IAClD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAI,KAAK,CAAC,CAAA,qCAAA,EAAwC,OAAO,KAAK,EAAE,CAAC,CAAC;KACzE;IACD,IAAI;QACF,OAAO,SAAS,CAAC,KAAK,CAAC,CAAC;KACzB,CAAC,OAAA,IAAM;QACN,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAEK,SAAU,iBAAiB,CAAC,KAAU;IAC1C,OAAO,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;AACxE,CAAC","debugId":null}},
    {"offset": {"line": 771, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 777, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;AAQA,MAAM,aAAa,IAAG,IAAI,CAAC,EAAE,AAC3B,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,CAC9B,CADgC,MACzB,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAC3D,CAAC;AASJ,MAAM,SAAS,IAAG,IAAI,CAAC,EAAE;IAMvB,MAAM,uBAAuB,GAAG,oQAAoQ,CAAC;IACrS,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,uBAAuB,EAAE,aAAa,CAAC,CAAC;IAE5E,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE;QAC7C,MAAM,oBAAoB,GACxB,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAErD,IAAI,oBAAoB,EACtB,OAAO,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAEtD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEI,SAAU,aAAa,CAAU,KAAa;IAClD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAI,KAAK,CAAC,CAAA,qCAAA,EAAwC,OAAO,KAAK,EAAE,CAAC,CAAC;KACzE;IACD,IAAI;QACF,OAAO,SAAS,CAAC,KAAK,CAAC,CAAC;KACzB,CAAC,OAAA,IAAM;QACN,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAEK,SAAU,iBAAiB,CAAC,KAAU;IAC1C,OAAO,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;AACxE,CAAC","debugId":null}},
    {"offset": {"line": 804, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 810, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;AAQA,MAAM,aAAa,IAAG,IAAI,CAAC,EAAE,AAC3B,IAAI,CAAC,SAAS,CAAC,IAAI,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,CAC9B,CADgC,MACzB,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,EAAE,GAAG,GAAG,CAAC,CAAC,CAAC,KAAK,CAC3D,CAAC;AASJ,MAAM,SAAS,IAAG,IAAI,CAAC,EAAE;IAMvB,MAAM,uBAAuB,GAAG,oQAAoQ,CAAC;IACrS,MAAM,cAAc,GAAG,IAAI,CAAC,OAAO,CAAC,uBAAuB,EAAE,aAAa,CAAC,CAAC;IAE5E,OAAO,IAAI,CAAC,KAAK,CAAC,cAAc,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE;QAC7C,MAAM,oBAAoB,GACxB,OAAO,KAAK,KAAK,QAAQ,IAAI,KAAK,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QAErD,IAAI,oBAAoB,EACtB,OAAO,MAAM,CAAC,KAAK,CAAC,SAAS,CAAC,CAAC,EAAE,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;QAEtD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEI,SAAU,aAAa,CAAU,KAAa;IAClD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAI,KAAK,CAAC,CAAA,qCAAA,EAAwC,OAAO,KAAK,EAAE,CAAC,CAAC;KACzE;IACD,IAAI;QACF,OAAO,SAAS,CAAC,KAAK,CAAC,CAAC;KACzB,CAAC,OAAA,IAAM;QACN,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAEK,SAAU,iBAAiB,CAAC,KAAU;IAC1C,OAAO,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,aAAa,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC;AACxE,CAAC","debugId":null}},
    {"offset": {"line": 837, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 843, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;AAAM,SAAU,aAAa,CAAU,KAAa;IAClD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,MAAM,IAAI,KAAK,CAAC,CAAA,qCAAA,EAAwC,OAAO,KAAK,EAAE,CAAC,CAAC;KACzE;IACD,IAAI;QACF,OAAO,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC;KAC1B,CAAC,OAAA,IAAM;QACN,OAAO,KAAK,CAAC;KACd;AACH,CAAC;AAEK,SAAU,iBAAiB,CAAC,KAAU;IAC1C,OAAO,OAAO,KAAK,KAAK,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC;AACnE,CAAC","debugId":null}},
    {"offset": {"line": 860, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 866, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/node_modules/unstorage/drivers/utils/index.mjs","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/node_modules/unstorage/drivers/indexedb.mjs","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/keyvaluestorage/src/browser/lib/indexedDb.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/keyvaluestorage/src/browser/lib/localStoragePrototype.js","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/keyvaluestorage/src/shared/utils.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/keyvaluestorage/src/browser/lib/localStore.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/keyvaluestorage/src/browser/lib/browserMigration.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/keyvaluestorage/src/browser/index.ts"],"sourcesContent":["export function defineDriver(factory) {\n  return factory;\n}\nexport function normalizeKey(key) {\n  if (!key) {\n    return \"\";\n  }\n  return key.replace(/[/\\\\]/g, \":\").replace(/^:|:$/g, \"\");\n}\nexport function joinKeys(...keys) {\n  return keys.map(normalizeKey).filter(Boolean).join(\":\");\n}\nexport function createError(driver, message, opts) {\n  const err = new Error(`[unstorage] [${driver}] ${message}`, opts);\n  return err;\n}\nexport function createRequiredError(driver, name) {\n  if (Array.isArray(name)) {\n    return createError(\n      driver,\n      `Missing some of the required options ${name.map((n) => \"`\" + n + \"`\").join(\", \")}`\n    );\n  }\n  return createError(driver, `Missing required option \\`${name}\\`.`);\n}\n","import { defineDriver } from \"./utils/index.mjs\";\nimport {\n  get,\n  set,\n  clear,\n  del,\n  keys,\n  createStore\n} from \"idb-keyval\";\nconst DRIVER_NAME = \"idb-keyval\";\nexport default defineDriver((opts = {}) => {\n  const base = opts.base && opts.base.length > 0 ? `${opts.base}:` : \"\";\n  const makeKey = (key) => base + key;\n  let customStore;\n  if (opts.dbName && opts.storeName) {\n    customStore = createStore(opts.dbName, opts.storeName);\n  }\n  return {\n    name: DRIVER_NAME,\n    options: opts,\n    async hasItem(key) {\n      const item = await get(makeKey(key), customStore);\n      return typeof item === \"undefined\" ? false : true;\n    },\n    async getItem(key) {\n      const item = await get(makeKey(key), customStore);\n      return item ?? null;\n    },\n    setItem(key, value) {\n      return set(makeKey(key), value, customStore);\n    },\n    removeItem(key) {\n      return del(makeKey(key), customStore);\n    },\n    getKeys() {\n      return keys(customStore);\n    },\n    clear() {\n      return clear(customStore);\n    }\n  };\n});\n","import { createStorage } from \"unstorage\";\nimport indexedDbDriver from \"unstorage/drivers/indexedb\";\n\nimport { IKeyValueStorage } from \"../../shared\";\nimport { safeJsonStringify } from \"@walletconnect/safe-json\";\n\nconst DB_NAME = \"WALLET_CONNECT_V2_INDEXED_DB\";\nconst DB_STORE_NAME = \"keyvaluestorage\";\n\nexport class IndexedDb implements IKeyValueStorage {\n  private indexedDb;\n  constructor() {\n    this.indexedDb = createStorage({\n      driver: indexedDbDriver({ dbName: DB_NAME, storeName: DB_STORE_NAME }),\n    });\n  }\n\n  public async getKeys(): Promise<string[]> {\n    return this.indexedDb.getKeys();\n  }\n\n  public async getEntries<T = any>(): Promise<[string, T][]> {\n    const entries = await this.indexedDb.getItems(await this.indexedDb.getKeys());\n    return entries.map((item: any) => [item.key, item.value] as [string, T]);\n  }\n\n  public async getItem<T = any>(key: string): Promise<T | undefined> {\n    const item = await this.indexedDb.getItem(key);\n    if (item === null) {\n      return undefined;\n    }\n    return item as T;\n  }\n\n  public async setItem<T = any>(key: string, value: T): Promise<void> {\n    await this.indexedDb.setItem(key, safeJsonStringify(value));\n  }\n\n  public async removeItem(key: string): Promise<void> {\n    await this.indexedDb.removeItem(key);\n  }\n}\n","/**\n * Source: https://git.coolaj86.com/coolaj86/local-storage.js/src/branch/local-storage/lib/localStorage.js\n */\n\n/* eslint-disable */\n\n(function () {\n  \"use strict\";\n\n  let db;\n\n  function LocalStorage() {}\n  db = LocalStorage;\n\n  db.prototype.getItem = function (key) {\n    if (this.hasOwnProperty(key)) {\n      return String(this[key]);\n    }\n    return null;\n  };\n\n  db.prototype.setItem = function (key, val) {\n    this[key] = String(val);\n  };\n\n  db.prototype.removeItem = function (key) {\n    delete this[key];\n  };\n\n  db.prototype.clear = function () {\n    const self = this;\n    Object.keys(self).forEach(function (key) {\n      self[key] = undefined;\n      delete self[key];\n    });\n  };\n\n  db.prototype.key = function (i) {\n    i = i || 0;\n    return Object.keys(this)[i];\n  };\n\n  db.prototype.__defineGetter__(\"length\", function () {\n    return Object.keys(this).length;\n  });\n\n  if (typeof global !== \"undefined\" && global.localStorage) {\n    module.exports = global.localStorage;\n  } else if (typeof window !== \"undefined\" && window.localStorage) {\n    module.exports = window.localStorage;\n  } else {\n    module.exports = new LocalStorage();\n  }\n})();\n","import { safeJsonParse } from \"@walletconnect/safe-json\";\n\nexport function parseEntry(entry: [string, string | null]): [string, any] {\n  return [entry[0], safeJsonParse(entry[1] ?? \"\")];\n}\n","import { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\n// @ts-expect-error\nimport localStorage from \"./localStoragePrototype\";\nimport { IKeyValueStorage, parseEntry } from \"../../shared\";\n\nexport class LocalStore implements IKeyValueStorage {\n  private readonly localStorage: Storage = localStorage;\n\n  public async getKeys(): Promise<string[]> {\n    return Object.keys(this.localStorage);\n  }\n\n  public async getEntries<T = any>(): Promise<[string, T][]> {\n    return Object.entries(this.localStorage).map(parseEntry);\n  }\n\n  public async getItem<T = any>(key: string): Promise<T | undefined> {\n    const item = this.localStorage.getItem(key);\n    if (item === null) {\n      return undefined;\n    }\n    return safeJsonParse(item) as T;\n  }\n\n  public async setItem<T = any>(key: string, value: T): Promise<void> {\n    this.localStorage.setItem(key, safeJsonStringify(value));\n  }\n\n  public async removeItem(key: string): Promise<void> {\n    this.localStorage.removeItem(key);\n  }\n}\n","import { IKeyValueStorage } from \"../../shared\";\n\nconst VERSION_KEY = \"wc_storage_version\";\nconst DB_VERSION = 1;\n\nexport const migrate = async (\n  fromStore: IKeyValueStorage,\n  toStore: IKeyValueStorage,\n  callback: (store: IKeyValueStorage) => void,\n) => {\n  const versionKey = VERSION_KEY;\n  const currentVersion = await toStore.getItem<number>(versionKey);\n  if (currentVersion && currentVersion >= DB_VERSION) {\n    callback(toStore);\n    return;\n  }\n  const keys = await fromStore.getKeys();\n  if (!keys.length) {\n    callback(toStore);\n    return;\n  }\n  const keysToCleanup: string[] = [];\n  while (keys.length) {\n    const key = keys.shift();\n    if (!key) continue;\n    const formattedKey = key.toLowerCase();\n    if (\n      formattedKey.includes(\"wc@\") ||\n      formattedKey.includes(\"walletconnect\") ||\n      formattedKey.includes(\"wc_\") ||\n      formattedKey.includes(\"wallet_connect\")\n    ) {\n      const item = await fromStore.getItem(key);\n      await toStore.setItem(key, item);\n      keysToCleanup.push(key);\n    }\n  }\n\n  await toStore.setItem(versionKey, DB_VERSION);\n  callback(toStore);\n  cleanup(fromStore, keysToCleanup);\n};\n\nconst cleanup = async (store: IKeyValueStorage, keysToCleanup: string[]) => {\n  if (!keysToCleanup.length) {\n    return;\n  }\n\n  keysToCleanup.forEach(async (key: string) => {\n    await store.removeItem(key);\n  });\n};\n","import { IKeyValueStorage } from \"../shared\";\nimport { IndexedDb } from \"./lib/indexedDb\";\nimport { LocalStore } from \"./lib/localStore\";\nimport { migrate } from \"./lib/browserMigration\";\n\nexport class KeyValueStorage implements IKeyValueStorage {\n  private storage: IKeyValueStorage;\n  private initialized = false;\n\n  constructor() {\n    const local = new LocalStore();\n    this.storage = local;\n    try {\n      const indexed = new IndexedDb();\n      migrate(local, indexed, this.setInitialized);\n      // indexedDb isn't available in node env so this will throw\n    } catch (e) {\n      this.initialized = true;\n    }\n  }\n\n  private setInitialized = (store: IKeyValueStorage) => {\n    this.storage = store;\n    this.initialized = true;\n  };\n\n  public async getKeys(): Promise<string[]> {\n    await this.initialize();\n    return this.storage.getKeys();\n  }\n\n  public async getEntries<T = any>(): Promise<[string, T][]> {\n    await this.initialize();\n    return this.storage.getEntries();\n  }\n\n  public async getItem<T = any>(key: string): Promise<T | undefined> {\n    await this.initialize();\n    return this.storage.getItem(key);\n  }\n\n  public async setItem<T = any>(key: string, value: T): Promise<void> {\n    await this.initialize();\n    return this.storage.setItem(key, value);\n  }\n\n  public async removeItem(key: string): Promise<void> {\n    await this.initialize();\n    return this.storage.removeItem(key);\n  }\n\n  private async initialize() {\n    if (this.initialized) {\n      return;\n    }\n    await new Promise<void>((resolve) => {\n      const interval = setInterval(() => {\n        if (this.initialized) {\n          clearInterval(interval);\n          resolve();\n        }\n      }, 20);\n    });\n  }\n}\n\nexport default KeyValueStorage;\n"],"names":["DB_NAME","DB_STORE_NAME","createStorage","indexedDbDriver","item","key","value","safeJsonStringify","db","LocalStorage","val","self","i","global","localStoragePrototypeModule","entry","_a","safeJsonParse","localStorage","parseEntry","VERSION_KEY","DB_VERSION","fromStore","toStore","callback","versionKey","currentVersion","keys","keysToCleanup","formattedKey","cleanup","store","local","LocalStore","indexed","IndexedDb","migrate","e","resolve","interval"],"mappings":"","ignoreList":[0,1,2,3,4,5,6,7],"debugId":null}},
    {"offset": {"line": 1053, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1059, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/logger/src/constants.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/logger/src/linkedList.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/logger/src/baseChunkLogger.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/logger/src/clientChunkLogger.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/logger/src/serverChunkLogger.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/logger/src/utils.ts"],"sourcesContent":["export const PINO_LOGGER_DEFAULTS = {\n  level: \"info\",\n};\n\nexport const PINO_CUSTOM_CONTEXT_KEY = \"custom_context\";\n\nexport const MAX_LOG_SIZE_IN_BYTES_DEFAULT = 1000 * 1024; // 1MB\n","class LogListNode {\n  private nodeValue: string;\n  private sizeInBytes: number;\n  public next: LogListNode | null;\n\n  constructor(value: string) {\n    this.nodeValue = value;\n    this.sizeInBytes = new TextEncoder().encode(this.nodeValue).length;\n    this.next = null;\n  }\n\n  public get value() {\n    return this.nodeValue;\n  }\n\n  public get size() {\n    return this.sizeInBytes;\n  }\n}\n\nexport default class LogLinkedList {\n  private lengthInNodes: number;\n  private sizeInBytes: number;\n  private head: LogListNode | null;\n  private tail: LogListNode | null;\n  private maxSizeInBytes: number;\n\n  constructor(maxSizeInBytes: number) {\n    this.head = null;\n    this.tail = null;\n    this.lengthInNodes = 0;\n    this.maxSizeInBytes = maxSizeInBytes;\n    this.sizeInBytes = 0;\n  }\n\n  public append(value: string): void {\n    const newNode = new LogListNode(value);\n\n    if (newNode.size > this.maxSizeInBytes) {\n      throw new Error(\n        `[LinkedList] Value too big to insert into list: ${value} with size ${newNode.size}`,\n      );\n    }\n\n    while (this.size + newNode.size > this.maxSizeInBytes) {\n      this.shift();\n    }\n\n    if (!this.head) {\n      this.head = newNode;\n      this.tail = newNode;\n    } else {\n      if (this.tail) {\n        this.tail.next = newNode;\n      }\n      this.tail = newNode;\n    }\n    this.lengthInNodes++;\n    this.sizeInBytes += newNode.size;\n  }\n\n  public shift(): void {\n    if (!this.head) {\n      return;\n    }\n\n    const removedNode = this.head;\n    this.head = this.head.next;\n\n    if (!this.head) {\n      this.tail = null;\n    }\n\n    this.lengthInNodes--;\n    this.sizeInBytes -= removedNode.size;\n  }\n\n  public toArray(): string[] {\n    const array: string[] = [];\n    let currentNode = this.head;\n    while (currentNode !== null) {\n      array.push(currentNode.value);\n      currentNode = currentNode.next;\n    }\n    return array;\n  }\n\n  public get length() {\n    return this.lengthInNodes;\n  }\n\n  public get size() {\n    return this.sizeInBytes;\n  }\n\n  public toOrderedArray() {\n    return Array.from(this);\n  }\n\n  [Symbol.iterator](): Iterator<string> {\n    let node = this.head;\n\n    const next = (): IteratorResult<string> => {\n      if (!node) {\n        return { done: true, value: null };\n      }\n\n      const value = node.value;\n      node = node.next;\n\n      return { done: false, value };\n    };\n\n    return { next };\n  }\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { LoggerOptions } from \"pino\";\nimport { levels } from \"pino\";\nimport LinkedList from \"./linkedList\";\nimport { safeJsonStringify } from \"@walletconnect/safe-json\";\n\nexport default class BaseChunkLogger {\n  private logs: LinkedList;\n  private level: LoggerOptions[\"level\"];\n  private levelValue: number;\n\n  private MAX_LOG_SIZE_IN_BYTES: number;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.level = level ?? \"error\";\n    this.levelValue = levels.values[this.level];\n\n    this.MAX_LOG_SIZE_IN_BYTES = MAX_LOG_SIZE_IN_BYTES;\n    this.logs = new LinkedList(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public forwardToConsole(chunk: any, level: number) {\n    if (level === levels.values.error) {\n      // eslint-disable-next-line no-console\n      console.error(chunk);\n    } else if (level === levels.values.warn) {\n      // eslint-disable-next-line no-console\n      console.warn(chunk);\n    } else if (level === levels.values.debug) {\n      // eslint-disable-next-line no-console\n      console.debug(chunk);\n    } else if (level === levels.values.trace) {\n      // eslint-disable-next-line no-console\n      console.trace(chunk);\n    } else {\n      // eslint-disable-next-line no-console\n      console.log(chunk);\n    }\n  }\n\n  public appendToLogs(chunk: any) {\n    this.logs.append(\n      safeJsonStringify({\n        timestamp: new Date().toISOString(),\n        log: chunk,\n      }),\n    );\n\n    // Based on https://github.com/pinojs/pino/blob/master/lib/constants.js\n    const level = typeof chunk === \"string\" ? JSON.parse(chunk).level : chunk.level;\n    if (level >= this.levelValue) {\n      this.forwardToConsole(chunk, level);\n    }\n  }\n\n  public getLogs() {\n    return this.logs;\n  }\n\n  public clearLogs() {\n    this.logs = new LinkedList(this.MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public getLogArray() {\n    return Array.from(this.logs);\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    const logArray = this.getLogArray();\n    logArray.push(safeJsonStringify({ extraMetadata }));\n    const blob = new Blob(logArray, { type: \"application/json\" });\n    return blob;\n  }\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { LoggerOptions } from \"pino\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport default class ClientChunkLogger {\n  private baseChunkLogger: BaseChunkLogger;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.baseChunkLogger = new BaseChunkLogger(level, MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public write(chunk: any): void {\n    this.baseChunkLogger.appendToLogs(chunk);\n  }\n\n  public getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n\n  public clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n\n  public getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    return this.baseChunkLogger.logsToBlob(extraMetadata);\n  }\n\n  public downloadLogsBlobInBrowser(extraMetadata: Record<string, string>) {\n    const url = URL.createObjectURL(this.logsToBlob(extraMetadata));\n    const anchor = document.createElement(\"a\");\n    anchor.href = url;\n    anchor.download = `walletconnect-logs-${new Date().toISOString()}.txt`;\n    document.body.appendChild(anchor);\n    anchor.click();\n    document.body.removeChild(anchor);\n    URL.revokeObjectURL(url);\n  }\n}\n","import { MAX_LOG_SIZE_IN_BYTES_DEFAULT } from \"./constants\";\nimport type { DestinationStream, LoggerOptions } from \"pino\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport default class ServerChunkLogger implements DestinationStream {\n  private baseChunkLogger: BaseChunkLogger;\n\n  public constructor(\n    level: LoggerOptions[\"level\"],\n    MAX_LOG_SIZE_IN_BYTES: number = MAX_LOG_SIZE_IN_BYTES_DEFAULT,\n  ) {\n    this.baseChunkLogger = new BaseChunkLogger(level, MAX_LOG_SIZE_IN_BYTES);\n  }\n\n  public write(chunk: any): void {\n    this.baseChunkLogger.appendToLogs(chunk);\n  }\n\n  public getLogs() {\n    return this.baseChunkLogger.getLogs();\n  }\n\n  public clearLogs() {\n    this.baseChunkLogger.clearLogs();\n  }\n\n  public getLogArray() {\n    return this.baseChunkLogger.getLogArray();\n  }\n\n  public logsToBlob(extraMetadata: Record<string, string>) {\n    return this.baseChunkLogger.logsToBlob(extraMetadata);\n  }\n}\n","import pino, { Logger, LoggerOptions } from \"pino\";\nimport { PINO_CUSTOM_CONTEXT_KEY, PINO_LOGGER_DEFAULTS } from \"./constants\";\nimport ClientChunkLogger from \"./clientChunkLogger\";\nimport ServerChunkLogger from \"./serverChunkLogger\";\nimport BaseChunkLogger from \"./baseChunkLogger\";\n\nexport interface ChunkLoggerController {\n  logsToBlob: BaseChunkLogger[\"logsToBlob\"];\n  getLogArray: () => string[];\n  clearLogs: () => void;\n  downloadLogsBlobInBrowser?: ClientChunkLogger[\"downloadLogsBlobInBrowser\"];\n}\n\nexport function getDefaultLoggerOptions(opts?: LoggerOptions): LoggerOptions {\n  return {\n    ...opts,\n    level: opts?.level || PINO_LOGGER_DEFAULTS.level,\n  };\n}\n\nexport function getBrowserLoggerContext(\n  logger: Logger,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): string {\n  return (logger as any)[customContextKey] || \"\";\n}\n\nexport function setBrowserLoggerContext(\n  logger: Logger,\n  context: string,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): Logger {\n  (logger as any)[customContextKey] = context;\n  return logger;\n}\n\nexport function getLoggerContext(\n  logger: Logger,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): string {\n  let context = \"\";\n  // logger.bindings is undefined in browser\n  if (typeof logger.bindings === \"undefined\") {\n    context = getBrowserLoggerContext(logger, customContextKey);\n  } else {\n    context = logger.bindings().context || \"\";\n  }\n  return context;\n}\n\nexport function formatChildLoggerContext(\n  logger: Logger,\n  childContext: string,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): string {\n  const parentContext = getLoggerContext(logger, customContextKey);\n  const context = parentContext.trim() ? `${parentContext}/${childContext}` : childContext;\n  return context;\n}\n\nexport function generateChildLogger(\n  logger: Logger,\n  childContext: string,\n  customContextKey: string = PINO_CUSTOM_CONTEXT_KEY,\n): Logger {\n  const context = formatChildLoggerContext(logger, childContext, customContextKey);\n  const child = logger.child({ context });\n  return setBrowserLoggerContext(child, context, customContextKey);\n}\n\nexport function generateClientLogger(params: { opts?: LoggerOptions; maxSizeInBytes?: number }): {\n  logger: Logger<any>;\n  chunkLoggerController: ClientChunkLogger;\n} {\n  const clientLogger = new ClientChunkLogger(params.opts?.level, params.maxSizeInBytes);\n  const logger = pino({\n    ...params.opts,\n    level: \"trace\",\n    browser: {\n      ...params.opts?.browser,\n      write: (obj) => clientLogger.write(obj),\n    },\n  });\n\n  return { logger, chunkLoggerController: clientLogger };\n}\n\nexport function generateServerLogger(params: { maxSizeInBytes?: number; opts?: LoggerOptions }): {\n  logger: Logger<any>;\n  chunkLoggerController: ServerChunkLogger;\n} {\n  const serverLogger = new ServerChunkLogger(params.opts?.level, params.maxSizeInBytes);\n  const logger = pino(\n    {\n      ...params.opts,\n      level: \"trace\",\n    },\n    serverLogger,\n  );\n\n  return { logger, chunkLoggerController: serverLogger };\n}\n\nexport function generatePlatformLogger(params: {\n  maxSizeInBytes?: number;\n  opts?: LoggerOptions;\n  loggerOverride?: string | Logger<any>;\n}): {\n  logger: Logger<any>;\n  chunkLoggerController: ChunkLoggerController | null;\n} {\n  if (typeof params.loggerOverride !== \"undefined\" && typeof params.loggerOverride !== \"string\") {\n    return {\n      logger: params.loggerOverride,\n      chunkLoggerController: null,\n    };\n  }\n\n  if (typeof window !== \"undefined\") {\n    return generateClientLogger(params);\n  } else {\n    return generateServerLogger(params);\n  }\n}\n"],"names":["LogListNode","value","LogLinkedList","maxSizeInBytes","newNode","removedNode","array","currentNode","node","BaseChunkLogger","level","MAX_LOG_SIZE_IN_BYTES","MAX_LOG_SIZE_IN_BYTES_DEFAULT","levels","LinkedList","chunk","safeJsonStringify","extraMetadata","logArray","ClientChunkLogger","url","anchor","ServerChunkLogger","opts","__spreadProps","__spreadValues","PINO_LOGGER_DEFAULTS","logger","customContextKey","PINO_CUSTOM_CONTEXT_KEY","context","childContext","parentContext","child","params","_a","_b","clientLogger","pino","obj","serverLogger"],"mappings":"","ignoreList":[0,1,2,3,4,5],"debugId":null}},
    {"offset": {"line": 1282, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1298, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/core.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/crypto.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/history.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/messages.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/publisher.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/relayer.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/store.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/subscriber.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/keychain.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/expirer.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/pairing.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/verify.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/echo.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/core/events.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/sign-client/client.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/types/src/sign-client/engine.ts"],"sourcesContent":["import { IEvents } from \"@walletconnect/events\";\nimport { IHeartBeat } from \"@walletconnect/heartbeat\";\nimport { IKeyValueStorage, KeyValueStorageOptions } from \"@walletconnect/keyvaluestorage\";\n\nimport { ICrypto } from \"./crypto\";\nimport { IRelayer } from \"./relayer\";\nimport { IKeyChain } from \"./keychain\";\nimport { IJsonRpcHistory } from \"./history\";\nimport { IExpirer } from \"./expirer\";\nimport { IPairing } from \"./pairing\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { IVerify } from \"./verify\";\nimport { IEchoClient } from \"./echo\";\nimport { IEventClient } from \"./events\";\nexport declare namespace CoreTypes {\n  interface Options {\n    projectId?: string;\n    name?: string;\n    relayUrl?: string;\n    logger?: string | Logger;\n    keychain?: IKeyChain;\n    storage?: IKeyValueStorage;\n    storageOptions?: KeyValueStorageOptions;\n    maxLogBlobSizeInBytes?: number;\n    customStoragePrefix?: string;\n    telemetryEnabled?: boolean;\n  }\n\n  interface Metadata {\n    name: string;\n    description: string;\n    url: string;\n    icons: string[];\n    verifyUrl?: string;\n    redirect?: {\n      native?: string;\n      universal?: string;\n      linkMode?: boolean;\n    };\n  }\n}\n\nexport abstract class ICore extends IEvents {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly relayUrl?: string;\n  public abstract readonly projectId?: string;\n  public abstract readonly customStoragePrefix: string;\n\n  public abstract logger: Logger;\n  public abstract heartbeat: IHeartBeat;\n  public abstract crypto: ICrypto;\n  public abstract relayer: IRelayer;\n  public abstract storage: IKeyValueStorage;\n  public abstract history: IJsonRpcHistory;\n  public abstract expirer: IExpirer;\n  public abstract pairing: IPairing;\n  public abstract verify: IVerify;\n  public abstract echoClient: IEchoClient;\n  public abstract linkModeSupportedApps: string[];\n  public abstract eventClient: IEventClient;\n\n  constructor(public opts?: CoreTypes.Options) {\n    super();\n  }\n\n  public abstract start(): Promise<void>;\n  public abstract dispatchEnvelope(params: {\n    topic: string;\n    message: string;\n    sessionExists: boolean;\n  }): void;\n\n  public abstract addLinkModeSupportedApp(universalLink: string): void;\n}\n","import { JsonRpcPayload } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\nimport { IKeyChain } from \"./keychain\";\n\nexport declare namespace CryptoTypes {\n  export type EncodingType = \"base64pad\" | \"base64url\";\n\n  export interface Participant {\n    publicKey: string;\n  }\n\n  export interface KeyPair {\n    privateKey: string;\n    publicKey: string;\n  }\n\n  export interface EncryptParams {\n    message: string;\n    symKey: string;\n    type?: number;\n    iv?: string;\n    senderPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface DecryptParams {\n    symKey: string;\n    encoded: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodingParams {\n    type: Uint8Array;\n    sealed: Uint8Array;\n    iv: Uint8Array;\n    senderPublicKey?: Uint8Array;\n    encoding?: EncodingType;\n  }\n\n  export interface DecodingParams {\n    encoded: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodeOptions {\n    type?: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface DecodeOptions {\n    receiverPublicKey?: string;\n    encoding?: EncodingType;\n  }\n\n  export interface EncodingValidation {\n    type: number;\n    senderPublicKey?: string;\n    receiverPublicKey?: string;\n  }\n\n  export interface TypeOneParams {\n    type: 1;\n    senderPublicKey: string;\n    receiverPublicKey: string;\n  }\n}\n\nexport abstract class ICrypto {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract keychain: IKeyChain;\n\n  public abstract readonly randomSessionIdentifier: string;\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    // @ts-ignore\n    keychain?: IKeyChain,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract hasKeys(tag: string): boolean;\n\n  public abstract getClientId(): Promise<string>;\n\n  public abstract generateKeyPair(): Promise<string>;\n\n  public abstract generateSharedKey(\n    selfPublicKey: string,\n    peerPublicKey: string,\n    overrideTopic?: string,\n  ): Promise<string>;\n\n  public abstract setSymKey(symKey: string, overrideTopic?: string): Promise<string>;\n\n  public abstract deleteKeyPair(publicKey: string): Promise<void>;\n\n  public abstract deleteSymKey(topic: string): Promise<void>;\n\n  public abstract encode(\n    topic: string,\n    payload: JsonRpcPayload,\n    opts?: CryptoTypes.EncodeOptions,\n  ): Promise<string>;\n\n  public abstract decode(\n    topic: string,\n    encoded: string,\n    opts?: CryptoTypes.DecodeOptions,\n  ): Promise<JsonRpcPayload>;\n\n  public abstract signJWT(aud: string): Promise<string>;\n  public abstract getPayloadType(encoded: string, encoding?: CryptoTypes.EncodingType): number;\n  public abstract getPayloadSenderPublicKey(\n    encoded: string,\n    encoding?: CryptoTypes.EncodingType,\n  ): string | undefined;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  RequestArguments,\n} from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\n\nexport interface JsonRpcRecord {\n  id: number;\n  topic: string;\n  request: RequestArguments;\n  chainId?: string;\n  response?: { result: any } | { error: ErrorResponse };\n  expiry?: number;\n}\n\nexport interface RequestEvent {\n  topic: string;\n  request: JsonRpcRequest;\n  chainId?: string;\n}\n\nexport abstract class IJsonRpcHistory extends IEvents {\n  public records = new Map<number, JsonRpcRecord>();\n\n  public abstract readonly context: string;\n\n  public abstract readonly size: number;\n\n  public abstract readonly keys: number[];\n\n  public abstract readonly values: JsonRpcRecord[];\n\n  public abstract readonly pending: RequestEvent[];\n\n  constructor(public core: ICore, public logger: Logger) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(topic: string, request: JsonRpcRequest, chainId?: string): void;\n\n  public abstract get(topic: string, id: number): Promise<JsonRpcRecord>;\n\n  public abstract resolve(response: JsonRpcResponse): Promise<void>;\n\n  public abstract delete(topic: string, id?: number): void;\n\n  public abstract exists(topic: string, id: number): Promise<boolean>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport type MessageRecord = Record<string, string>;\n\nexport abstract class IMessageTracker {\n  public abstract messages: Map<string, MessageRecord>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public logger: Logger, public core: ICore) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(topic: string, message: string): Promise<string>;\n\n  public abstract get(topic: string): MessageRecord;\n\n  public abstract has(topic: string, message: string): boolean;\n\n  public abstract del(topic: string): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace PublisherTypes {\n  export interface Params {\n    topic: string;\n    message: string;\n    opts: Omit<RelayerTypes.PublishOptions, \"internal\">;\n  }\n}\n\nexport abstract class IPublisher extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super();\n  }\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { IJsonRpcProvider, JsonRpcPayload, RequestArguments } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\nimport { IMessageTracker } from \"./messages\";\nimport { IPublisher } from \"./publisher\";\nimport { ISubscriber } from \"./subscriber\";\n\nexport declare namespace RelayerTypes {\n  export interface ProtocolOptions {\n    protocol: string;\n    data?: string;\n  }\n  export interface PublishOptions {\n    relay?: ProtocolOptions;\n    ttl?: number;\n    prompt?: boolean;\n    tag?: number;\n    id?: number;\n    internal?: {\n      throwOnFailedPublish?: boolean;\n    };\n    attestation?: string;\n  }\n\n  export type TransportType = \"relay\" | \"link_mode\";\n\n  export interface SubscribeOptions {\n    relay?: ProtocolOptions;\n    transportType?: TransportType;\n    internal?: {\n      throwOnFailedPublish?: boolean;\n    };\n  }\n\n  export interface UnsubscribeOptions {\n    id?: string;\n    relay: ProtocolOptions;\n  }\n\n  export type RequestOptions = PublishOptions | SubscribeOptions | UnsubscribeOptions;\n\n  export interface PublishPayload {\n    topic: string;\n    message: string;\n    opts?: RelayerTypes.PublishOptions;\n  }\n  export interface MessageEvent {\n    topic: string;\n    message: string;\n    publishedAt: number;\n    transportType?: TransportType;\n    attestation?: string;\n  }\n\n  export interface RpcUrlParams {\n    protocol: string;\n    version: number;\n    auth: string;\n    relayUrl: string;\n    sdkVersion: string;\n    projectId?: string;\n    useOnCloseEvent?: boolean;\n    bundleId?: string;\n    packageName?: string;\n  }\n}\n\nexport interface RelayerOptions {\n  core: ICore;\n  logger?: string | Logger;\n  relayUrl?: string;\n  projectId?: string;\n}\n\nexport interface RelayerClientMetadata {\n  protocol: string;\n  version: number;\n  env: string;\n  host?: string;\n}\n\nexport abstract class IRelayer extends IEvents {\n  public abstract protocol: string;\n\n  public abstract version: number;\n\n  public abstract core: ICore;\n\n  public abstract logger: Logger;\n\n  public abstract subscriber: ISubscriber;\n\n  public abstract publisher: IPublisher;\n\n  public abstract messages: IMessageTracker;\n\n  public abstract provider: IJsonRpcProvider;\n\n  public abstract name: string;\n\n  public abstract transportExplicitlyClosed: boolean;\n\n  public abstract readonly context: string;\n\n  public abstract readonly connected: boolean;\n\n  public abstract readonly connecting: boolean;\n\n  constructor(\n    // @ts-ignore\n    opts: RelayerOptions,\n  ) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract publish(\n    topic: string,\n    message: string,\n    opts?: RelayerTypes.PublishOptions,\n  ): Promise<void>;\n\n  public abstract request(request: RequestArguments): Promise<JsonRpcPayload>;\n\n  public abstract subscribe(topic: string, opts?: RelayerTypes.SubscribeOptions): Promise<string>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n  public abstract transportClose(): Promise<void>;\n  public abstract transportOpen(relayUrl?: string): Promise<void>;\n  public abstract restartTransport(relayUrl?: string): Promise<void>;\n  public abstract confirmOnlineStateOrThrow(): Promise<void>;\n  public abstract handleBatchMessageEvents(messages: RelayerTypes.MessageEvent[]): Promise<void>;\n  public abstract onLinkMessageEvent(\n    messageEvent: RelayerTypes.MessageEvent,\n    opts?: { sessionExists?: boolean },\n  ): Promise<void>;\n}\n","import { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IStore<Key, Value> {\n  public abstract map: Map<Key, Value>;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: Key[];\n\n  public abstract readonly values: Value[];\n\n  constructor(\n    public core: ICore,\n    public logger: Logger,\n    public name: string,\n    // @ts-ignore\n    storagePrefix?: string,\n  ) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract set(key: Key, value: Value): Promise<void>;\n\n  public abstract get(key: Key): Value;\n\n  public abstract getAll(filter?: Partial<Value>): Value[];\n\n  public abstract update(key: Key, update: Partial<Value>): Promise<void>;\n\n  public abstract delete(key: Key, reason: ErrorResponse): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { IRelayer, RelayerTypes } from \"./relayer\";\n\nexport declare namespace SubscriberTypes {\n  export interface Params extends RelayerTypes.SubscribeOptions {\n    topic: string;\n  }\n\n  export interface Active extends Params {\n    id: string;\n  }\n}\n\nexport declare namespace SubscriberEvents {\n  export type Created = SubscriberTypes.Active;\n\n  export interface Deleted extends SubscriberTypes.Active {\n    reason: ErrorResponse;\n  }\n\n  export type Expired = Deleted;\n}\n\nexport abstract class ISubscriberTopicMap {\n  public map = new Map<string, string[]>();\n\n  public abstract readonly topics: string[];\n\n  public abstract set(topic: string, id: string): void;\n\n  public abstract get(topic: string): string[];\n\n  public abstract exists(topic: string, id: string): boolean;\n\n  public abstract delete(topic: string, id?: string): void;\n\n  public abstract clear(): void;\n}\n\nexport abstract class ISubscriber extends IEvents {\n  public abstract subscriptions: Map<string, SubscriberTypes.Active>;\n\n  public abstract topicMap: ISubscriberTopicMap;\n\n  public abstract pending: Map<string, SubscriberTypes.Params>;\n\n  public abstract readonly length: number;\n\n  public abstract readonly ids: string[];\n\n  public abstract readonly values: SubscriberTypes.Active[];\n\n  public abstract readonly topics: string[];\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public relayer: IRelayer, public logger: Logger) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract subscribe(\n    topic: string,\n    opts?: RelayerTypes.SubscribeOptions,\n  ): Promise<string | null>;\n\n  public abstract unsubscribe(topic: string, opts?: RelayerTypes.UnsubscribeOptions): Promise<void>;\n\n  public abstract isSubscribed(topic: string): Promise<boolean>;\n\n  public abstract start(): Promise<void>;\n\n  public abstract stop(): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport abstract class IKeyChain {\n  public abstract keychain: Map<string, string>;\n\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  constructor(public core: ICore, public logger: Logger) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(tag: string, opts?: any): boolean;\n\n  public abstract set(tag: string, key: string, opts?: any): Promise<void>;\n\n  public abstract get(tag: string, opts?: any): string;\n\n  public abstract del(tag: string, opts?: any): Promise<void>;\n}\n","import { IEvents } from \"@walletconnect/events\";\nimport { Logger } from \"@walletconnect/logger\";\n\nimport { ICore } from \"./core\";\n\nexport declare namespace ExpirerTypes {\n  interface Expiration {\n    target: string;\n    expiry: number;\n  }\n\n  interface Created {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Deleted {\n    target: string;\n    expiration: Expiration;\n  }\n\n  interface Expired {\n    target: string;\n    expiration: Expiration;\n  }\n}\n\nexport abstract class IExpirer extends IEvents {\n  public abstract name: string;\n\n  public abstract readonly context: string;\n\n  public abstract readonly length: number;\n\n  public abstract readonly keys: string[];\n\n  public abstract readonly values: ExpirerTypes.Expiration[];\n\n  constructor(public core: ICore, public logger: Logger) {\n    super();\n  }\n\n  public abstract init(): Promise<void>;\n\n  public abstract has(key: string | number): boolean;\n\n  public abstract set(key: string | number, expiry: number): void;\n\n  public abstract get(key: string | number): ExpirerTypes.Expiration;\n\n  public abstract del(key: string | number): void;\n}\n","import {\n  ErrorResponse,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport EventEmitter from \"events\";\n\nimport { ICore, CoreTypes } from \"./core\";\nimport { IStore } from \"./store\";\n\nimport { RelayerTypes } from \"../core/relayer\";\nimport { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace PairingTypes {\n  interface Struct {\n    topic: string;\n    expiry: number;\n    relay: RelayerTypes.ProtocolOptions;\n    active: boolean;\n    peerMetadata?: CoreTypes.Metadata;\n    methods?: string[];\n  }\n}\n\nexport declare namespace PairingJsonRpcTypes {\n  // -- core ------------------------------------------------------- //\n  type DefaultResponse = true | ErrorResponse;\n\n  type WcMethod = \"wc_pairingDelete\" | \"wc_pairingPing\";\n\n  type Error = ErrorResponse;\n\n  // -- requests --------------------------------------------------- //\n\n  interface RequestParams {\n    wc_pairingDelete: {\n      code: number;\n      message: string;\n    };\n    wc_pairingPing: Record<string, unknown>;\n  }\n\n  // -- responses -------------------------------------------------- //\n  interface Results {\n    wc_pairingDelete: true;\n    wc_pairingPing: true;\n  }\n\n  // -- events ----------------------------------------------------- //\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n  }\n}\n\nexport type IPairingStore = IStore<string, PairingTypes.Struct>;\n\nexport abstract class IPairing {\n  public abstract name: string;\n  public abstract readonly context: string;\n  public abstract events: EventEmitter;\n  public abstract pairings: IPairingStore;\n\n  constructor(public logger: Logger, public core: ICore) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract pair(params: {\n    uri: string;\n    activatePairing?: boolean;\n  }): Promise<PairingTypes.Struct>;\n\n  // for proposer to create inactive pairing\n  public abstract create(params?: {\n    methods?: string[];\n    transportType?: RelayerTypes.SubscribeOptions[\"transportType\"];\n  }): Promise<{ topic: string; uri: string }>;\n\n  // for either to activate a previously created pairing\n  public abstract activate(params: { topic: string }): Promise<void>;\n\n  // for both to subscribe on methods requests\n  public abstract register(params: { methods: string[] }): void;\n\n  // for either to update the expiry of an existing pairing.\n  public abstract updateExpiry(params: { topic: string; expiry: number }): Promise<void>;\n\n  // for either to update the metadata of an existing pairing.\n  public abstract updateMetadata(params: {\n    topic: string;\n    metadata: CoreTypes.Metadata;\n  }): Promise<void>;\n\n  // query pairings\n  public abstract getPairings(): PairingTypes.Struct[];\n\n  // for either to ping a peer\n  public abstract ping(params: { topic: string }): Promise<void>;\n\n  // for either peer to disconnect a pairing\n  public abstract disconnect(params: { topic: string }): Promise<void>;\n\n  public abstract formatUriFromPairing(pairing: PairingTypes.Struct): string;\n}\n\nexport interface IPairingPrivate {\n  sendRequest<M extends PairingJsonRpcTypes.WcMethod>(\n    topic: string,\n    method: M,\n    params: PairingJsonRpcTypes.RequestParams[M],\n  ): Promise<number>;\n\n  sendResult<M extends PairingJsonRpcTypes.WcMethod>(\n    id: number,\n    topic: string,\n    result: PairingJsonRpcTypes.Results[M],\n  ): Promise<void>;\n\n  sendError(id: number, topic: string, error: PairingJsonRpcTypes.Error): Promise<void>;\n\n  onRelayEventRequest(event: PairingJsonRpcTypes.EventCallback<JsonRpcRequest>): void;\n\n  onRelayEventResponse(event: PairingJsonRpcTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onPairingPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingPing\"]>,\n  ): Promise<void>;\n\n  onPairingPingResponse(\n    topic: string,\n    payload: JsonRpcResult<PairingJsonRpcTypes.Results[\"wc_pairingPing\"]> | JsonRpcError,\n  ): void;\n\n  onPairingDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<PairingJsonRpcTypes.RequestParams[\"wc_pairingDelete\"]>,\n  ): Promise<void>;\n\n  onUnknownRpcMethodRequest(topic: string, payload: JsonRpcRequest): Promise<void>;\n\n  onUnknownRpcMethodResponse(method: string): void;\n\n  deletePairing(topic: string, expirerHasDeleted?: boolean): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\nimport { ICore } from \"./core\";\n\nexport declare namespace Verify {\n  export interface Context {\n    verified: {\n      origin: string;\n      validation: \"UNKNOWN\" | \"VALID\" | \"INVALID\";\n      verifyUrl: string;\n      isScam?: boolean;\n    };\n  }\n}\n\nexport abstract class IVerify {\n  public abstract readonly context: string;\n\n  constructor(public core: ICore, public logger: Logger, public store: IKeyValueStorage) {}\n\n  public abstract register(params: {\n    id: string;\n    decryptedId: string;\n  }): Promise<string | undefined>;\n\n  public abstract resolve(params: {\n    attestationId?: string;\n    hash?: string;\n    encryptedId?: string;\n    verifyUrl?: string;\n  }): Promise<{ origin: string; isScam?: boolean }>;\n}\n","import { Logger } from \"@walletconnect/logger\";\n\nexport declare namespace EchoClientTypes {\n  type RegisterDeviceTokenParams = {\n    clientId: string;\n    token: string;\n    notificationType: \"fcm\" | \"apns\" | \"apns-sandbox\" | \"noop\";\n    enableEncrypted?: boolean;\n  };\n}\nexport abstract class IEchoClient {\n  public abstract readonly context: string;\n  constructor(public projectId: string, public logger: Logger) {}\n\n  public abstract registerDeviceToken(\n    params: EchoClientTypes.RegisterDeviceTokenParams,\n  ): Promise<void>;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport { ICore } from \"./core\";\n\nexport declare namespace EventClientTypes {\n  export interface Event {\n    eventId: string;\n    bundleId: string;\n    timestamp: number;\n    props: Props;\n    addTrace: (trace: string) => void;\n    setError: (error: string) => void;\n  }\n\n  export interface Props {\n    event: string;\n    type: string;\n    properties: Properties;\n  }\n\n  export interface Properties {\n    topic: string;\n    trace: Trace;\n  }\n\n  export type Trace = string[];\n}\n\nexport abstract class IEventClient {\n  public abstract readonly context: string;\n\n  constructor(public core: ICore, public logger: Logger, public telemetryEnabled: boolean) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract createEvent(params: {\n    event?: \"ERROR\";\n    type?: string;\n    properties: {\n      topic: string;\n      trace: EventClientTypes.Trace;\n    };\n  }): EventClientTypes.Event;\n\n  public abstract getEvent(params: {\n    eventId?: string;\n    topic?: string;\n  }): EventClientTypes.Event | undefined;\n\n  public abstract deleteEvent(params: { eventId: string }): void;\n}\n","import { Logger } from \"@walletconnect/logger\";\nimport EventEmmiter from \"events\";\nimport { CoreTypes, ICore } from \"../core/core\";\nimport { IEngine } from \"./engine\";\nimport { IPendingRequest } from \"./pendingRequest\";\nimport { IProposal, ProposalTypes } from \"./proposal\";\nimport { ISession, SessionTypes } from \"./session\";\nimport { Verify } from \"../core/verify\";\nimport { IAuth, AuthTypes } from \"./auth\";\nimport { RelayerTypes } from \"../core\";\n\nexport declare namespace SignClientTypes {\n  type Event =\n    | \"session_proposal\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"session_delete\"\n    | \"session_expire\"\n    | \"session_request\"\n    | \"session_request_sent\"\n    | \"session_event\"\n    | \"session_authenticate\"\n    | \"proposal_expire\"\n    | \"session_request_expire\";\n\n  interface BaseEventArgs<T = unknown> {\n    id: number;\n    topic: string;\n    params: T;\n  }\n  interface EventArguments {\n    session_proposal: {\n      verifyContext: Verify.Context;\n    } & Omit<BaseEventArgs<ProposalTypes.Struct>, \"topic\">;\n    session_update: BaseEventArgs<{ namespaces: SessionTypes.Namespaces }>;\n    session_extend: Omit<BaseEventArgs, \"params\">;\n    session_ping: Omit<BaseEventArgs, \"params\">;\n    session_delete: Omit<BaseEventArgs, \"params\">;\n    session_expire: { topic: string };\n    session_request: {\n      verifyContext: Verify.Context;\n    } & BaseEventArgs<{\n      request: { method: string; params: any; expiryTimestamp?: number };\n      chainId: string;\n    }>;\n    session_request_sent: {\n      request: { method: string; params: any };\n      topic: string;\n      chainId: string;\n      id: number;\n    };\n    session_event: BaseEventArgs<{\n      event: { name: string; data: any };\n      chainId: string;\n    }>;\n    session_authenticate: {\n      verifyContext: Verify.Context;\n      transportType?: RelayerTypes.TransportType;\n    } & BaseEventArgs<AuthTypes.AuthRequestEventArgs>;\n    proposal_expire: { id: number };\n    session_request_expire: { id: number };\n  }\n\n  type Metadata = CoreTypes.Metadata;\n\n  type SignConfig = {\n    disableRequestQueue?: boolean;\n  };\n\n  interface Options extends CoreTypes.Options {\n    core?: ICore;\n    metadata?: Metadata;\n    signConfig?: SignConfig;\n  }\n}\n\nexport abstract class ISignClientEvents extends EventEmmiter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends SignClientTypes.Event>(\n    event: E,\n    args: SignClientTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract on: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract once: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract off: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeListener: <E extends SignClientTypes.Event>(\n    event: E,\n    listener: (args: SignClientTypes.EventArguments[E]) => any,\n  ) => this;\n\n  public abstract removeAllListeners: <E extends SignClientTypes.Event>(event: E) => this;\n}\n\nexport abstract class ISignClient {\n  public readonly protocol = \"wc\";\n  public readonly version = 2;\n\n  public abstract readonly name: string;\n  public abstract readonly context: string;\n  public abstract readonly metadata: SignClientTypes.Metadata;\n\n  public abstract core: ICore;\n  public abstract logger: Logger;\n  public abstract events: ISignClientEvents;\n  public abstract engine: IEngine;\n  public abstract session: ISession;\n  public abstract proposal: IProposal;\n  public abstract pendingRequest: IPendingRequest;\n  public abstract auth: IAuth;\n  public abstract signConfig?: SignClientTypes.SignConfig;\n\n  constructor(public opts?: SignClientTypes.Options) {}\n\n  public abstract connect: IEngine[\"connect\"];\n  public abstract pair: IEngine[\"pair\"];\n  public abstract approve: IEngine[\"approve\"];\n  public abstract reject: IEngine[\"reject\"];\n  public abstract update: IEngine[\"update\"];\n  public abstract extend: IEngine[\"extend\"];\n  public abstract request: IEngine[\"request\"];\n  public abstract respond: IEngine[\"respond\"];\n  public abstract ping: IEngine[\"ping\"];\n  public abstract emit: IEngine[\"emit\"];\n  public abstract disconnect: IEngine[\"disconnect\"];\n  public abstract find: IEngine[\"find\"];\n  public abstract getPendingSessionRequests: IEngine[\"getPendingSessionRequests\"];\n  public abstract authenticate: IEngine[\"authenticate\"];\n  public abstract formatAuthMessage: IEngine[\"formatAuthMessage\"];\n  public abstract approveSessionAuthenticate: IEngine[\"approveSessionAuthenticate\"];\n  public abstract rejectSessionAuthenticate: IEngine[\"rejectSessionAuthenticate\"];\n}\n","import {\n  JsonRpcResponse,\n  JsonRpcRequest,\n  ErrorResponse,\n  JsonRpcResult,\n  JsonRpcError,\n} from \"@walletconnect/jsonrpc-types\";\nimport { ISignClient } from \"./client\";\nimport { RelayerTypes } from \"../core/relayer\";\nimport { SessionTypes } from \"./session\";\nimport { ProposalTypes } from \"./proposal\";\nimport { PairingTypes } from \"../core/pairing\";\nimport { JsonRpcTypes } from \"./jsonrpc\";\nimport { EventEmitter } from \"events\";\nimport { PendingRequestTypes } from \"./pendingRequest\";\nimport { AuthTypes } from \"./auth\";\nimport { CryptoTypes } from \"../core\";\n\nexport declare namespace EngineTypes {\n  type Event =\n    | \"session_connect\"\n    | \"session_approve\"\n    | \"session_update\"\n    | \"session_extend\"\n    | \"session_ping\"\n    | \"pairing_ping\"\n    | \"session_request\";\n\n  interface EventArguments {\n    session_connect: {\n      error?: ErrorResponse;\n      session?: SessionTypes.Struct;\n    };\n    session_approve: { error?: ErrorResponse };\n    session_update: { error?: ErrorResponse };\n    session_extend: { error?: ErrorResponse };\n    session_ping: { error?: ErrorResponse };\n    pairing_ping: { error?: ErrorResponse };\n    session_request: { error?: ErrorResponse; result?: any };\n  }\n\n  interface UriParameters {\n    protocol: string;\n    version: number;\n    topic: string;\n    symKey: string;\n    relay: RelayerTypes.ProtocolOptions;\n    methods?: string[];\n    expiryTimestamp?: number;\n  }\n\n  interface EventCallback<T extends JsonRpcRequest | JsonRpcResponse> {\n    topic: string;\n    payload: T;\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    attestation?: string;\n    encryptedId?: string;\n  }\n\n  interface ConnectParams {\n    requiredNamespaces?: ProposalTypes.RequiredNamespaces;\n    optionalNamespaces?: ProposalTypes.OptionalNamespaces;\n    sessionProperties?: ProposalTypes.SessionProperties;\n    pairingTopic?: string;\n    relays?: RelayerTypes.ProtocolOptions[];\n  }\n\n  interface PairParams {\n    uri: string;\n  }\n\n  interface ApproveParams {\n    id: number;\n    namespaces: SessionTypes.Namespaces;\n    sessionProperties?: ProposalTypes.SessionProperties;\n    sessionConfig?: SessionTypes.SessionConfig;\n    relayProtocol?: string;\n  }\n\n  interface RejectParams {\n    id: number;\n    reason: ErrorResponse;\n  }\n\n  interface UpdateParams {\n    topic: string;\n    namespaces: SessionTypes.Namespaces;\n  }\n\n  interface ExtendParams {\n    topic: string;\n  }\n\n  interface RequestParams {\n    topic: string;\n    request: {\n      method: string;\n      params: any;\n    };\n    chainId: string;\n    expiry?: number;\n  }\n\n  interface RespondParams {\n    topic: string;\n    response: JsonRpcResponse;\n  }\n\n  interface EmitParams {\n    topic: string;\n    event: {\n      name: string;\n      data: any;\n    };\n    chainId: string;\n  }\n\n  interface PingParams {\n    topic: string;\n  }\n\n  interface DisconnectParams {\n    topic: string;\n    reason: ErrorResponse;\n  }\n\n  interface FindParams {\n    requiredNamespaces: ProposalTypes.RequiredNamespaces;\n  }\n\n  type AcknowledgedPromise = Promise<{ acknowledged: () => Promise<void> }>;\n\n  type SessionAuthenticateResponsePromise = {\n    uri: string;\n    response: () => Promise<AuthTypes.AuthenticateResponseResult>;\n  };\n\n  interface RpcOpts {\n    req: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    res: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    reject?: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n    autoReject?: RelayerTypes.PublishOptions & {\n      ttl: number;\n    };\n  }\n\n  type RpcOptsMap = Record<JsonRpcTypes.WcMethod, RpcOpts>;\n\n  type EngineQueue<T> = {\n    state: \"IDLE\" | \"ACTIVE\";\n    queue: T[];\n  };\n}\n\nexport abstract class IEngineEvents extends EventEmitter {\n  constructor() {\n    super();\n  }\n\n  public abstract emit: <E extends EngineTypes.Event>(\n    event: string,\n    args: EngineTypes.EventArguments[E],\n  ) => boolean;\n\n  public abstract once: <E extends EngineTypes.Event>(\n    event: string,\n    listener: (args: EngineTypes.EventArguments[E]) => any,\n  ) => this;\n}\n\n// -- private method interface -------------------------------------- //\n\nexport interface EnginePrivate {\n  sendRequest<M extends JsonRpcTypes.WcMethod>(args: {\n    topic: string;\n    method: M;\n    params: JsonRpcTypes.RequestParams[M];\n    expiry?: number;\n    relayRpcId?: number;\n    clientRpcId?: number;\n    throwOnFailedPublish?: boolean;\n    appLink?: string;\n  }): Promise<number>;\n\n  sendResult<M extends JsonRpcTypes.WcMethod>(args: {\n    id: number;\n    topic: string;\n    result: JsonRpcTypes.Results[M];\n    throwOnFailedPublish?: boolean;\n    encodeOpts?: CryptoTypes.EncodeOptions;\n    appLink?: string;\n  }): Promise<void>;\n\n  sendError(params: {\n    id: number;\n    topic: string;\n    error: JsonRpcTypes.Error;\n    encodeOpts?: CryptoTypes.EncodeOptions;\n    rpcOpts?: RelayerTypes.PublishOptions;\n    appLink?: string;\n  }): Promise<void>;\n\n  onRelayEventRequest(event: EngineTypes.EventCallback<JsonRpcRequest>): Promise<void>;\n\n  onRelayEventResponse(event: EngineTypes.EventCallback<JsonRpcResponse>): Promise<void>;\n\n  onRelayEventUnknownPayload(event: EngineTypes.EventCallback<any>): Promise<void>;\n\n  shouldIgnorePairingRequest(params: { topic: string; requestMethod: string }): boolean;\n\n  deleteSession(params: {\n    topic: string;\n    expirerHasDeleted?: boolean;\n    id?: number;\n    emitEvent?: boolean;\n  }): Promise<void>;\n\n  deleteProposal(id: number, expirerHasDeleted?: boolean): Promise<void>;\n\n  setExpiry(topic: string, expiry: number): Promise<void>;\n\n  setProposal(id: number, proposal: ProposalTypes.Struct): Promise<void>;\n\n  setAuthRequest(\n    id: number,\n    params: {\n      request: AuthTypes.SessionAuthenticateRequest;\n      pairingTopic: string;\n      transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    },\n  ): Promise<void>;\n\n  setPendingSessionRequest(pendingRequest: PendingRequestTypes.Struct): Promise<void>;\n\n  deletePendingSessionRequest(\n    id: number,\n    reason: ErrorResponse,\n    expirerHasDeleted?: boolean,\n  ): Promise<void>;\n\n  deletePendingAuthRequest(\n    id: number,\n    reason: ErrorResponse,\n    expirerHasDeleted?: boolean,\n  ): Promise<void>;\n\n  cleanupDuplicatePairings(session: SessionTypes.Struct): Promise<void>;\n\n  cleanup(): Promise<void>;\n\n  onSessionProposeRequest(params: {\n    topic: string;\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPropose\"]>;\n    attestation?: string;\n    encryptedId?: string;\n  }): Promise<void>;\n\n  onSessionProposeResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPropose\"]> | JsonRpcError,\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"],\n  ): Promise<void>;\n\n  onSessionSettleRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]>,\n  ): Promise<void>;\n\n  onSessionSettleResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionSettle\"]> | JsonRpcError,\n  ): Promise<void>;\n\n  onSessionUpdateRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionUpdate\"]>,\n  ): Promise<void>;\n\n  onSessionUpdateResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionUpdate\"]> | JsonRpcError,\n  ): void;\n\n  onSessionExtendRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionExtend\"]>,\n  ): Promise<void>;\n\n  onSessionExtendResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionExtend\"]> | JsonRpcError,\n  ): void;\n\n  onSessionPingRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionPing\"]>,\n  ): Promise<void>;\n\n  onSessionPingResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionPing\"]> | JsonRpcError,\n  ): void;\n\n  onSessionDeleteRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionDelete\"]>,\n  ): Promise<void>;\n\n  onSessionRequest(params: {\n    topic: string;\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionRequest\"]>;\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    attestation?: string;\n    encryptedId?: string;\n  }): Promise<void>;\n\n  onSessionRequestResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionRequest\"]> | JsonRpcError,\n  ): void;\n\n  onSessionEventRequest(\n    topic: string,\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionEvent\"]>,\n  ): Promise<void>;\n\n  onSessionAuthenticateRequest(params: {\n    topic: string;\n    payload: JsonRpcRequest<JsonRpcTypes.RequestParams[\"wc_sessionAuthenticate\"]>;\n    transportType?: RelayerTypes.MessageEvent[\"transportType\"];\n    attestation?: string;\n    encryptedId?: string;\n  }): Promise<void>;\n\n  onSessionAuthenticateResponse(\n    topic: string,\n    payload: JsonRpcResult<JsonRpcTypes.Results[\"wc_sessionAuthenticate\"]> | JsonRpcError,\n  ): void;\n\n  // -- Validators ---------------------------------------------------- //\n  isValidConnect(params: EngineTypes.ConnectParams): Promise<void>;\n\n  isValidSessionSettleRequest(params: JsonRpcTypes.RequestParams[\"wc_sessionSettle\"]): void;\n\n  isValidApprove(params: EngineTypes.ApproveParams): Promise<void>;\n\n  isValidReject(params: EngineTypes.RejectParams): Promise<void>;\n\n  isValidUpdate(params: EngineTypes.UpdateParams): Promise<void>;\n\n  isValidExtend(params: EngineTypes.ExtendParams): Promise<void>;\n\n  isValidRequest(params: EngineTypes.RequestParams): Promise<void>;\n\n  isValidRespond(params: EngineTypes.RespondParams): Promise<void>;\n\n  isValidPing(params: EngineTypes.PingParams): Promise<void>;\n\n  isValidEmit(params: EngineTypes.EmitParams): Promise<void>;\n\n  isValidDisconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n}\n\n// -- class interface ----------------------------------------------- //\n\nexport abstract class IEngine {\n  constructor(public client: ISignClient) {}\n\n  public abstract init(): Promise<void>;\n\n  public abstract connect(\n    params: EngineTypes.ConnectParams,\n  ): Promise<{ uri?: string; approval: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract pair(params: EngineTypes.PairParams): Promise<PairingTypes.Struct>;\n\n  public abstract approve(\n    params: EngineTypes.ApproveParams,\n  ): Promise<{ topic: string; acknowledged: () => Promise<SessionTypes.Struct> }>;\n\n  public abstract reject(params: EngineTypes.RejectParams): Promise<void>;\n\n  public abstract update(params: EngineTypes.UpdateParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract extend(params: EngineTypes.ExtendParams): EngineTypes.AcknowledgedPromise;\n\n  public abstract request<T>(params: EngineTypes.RequestParams): Promise<T>;\n\n  public abstract respond(params: EngineTypes.RespondParams): Promise<void>;\n\n  public abstract emit(params: EngineTypes.EmitParams): Promise<void>;\n\n  public abstract ping(params: EngineTypes.PingParams): Promise<void>;\n\n  public abstract disconnect(params: EngineTypes.DisconnectParams): Promise<void>;\n\n  public abstract find: (params: EngineTypes.FindParams) => SessionTypes.Struct[];\n\n  public abstract getPendingSessionRequests: () => PendingRequestTypes.Struct[];\n\n  public abstract authenticate: (\n    params: AuthTypes.SessionAuthenticateParams,\n    walletUniversalLink?: string,\n  ) => Promise<EngineTypes.SessionAuthenticateResponsePromise>;\n\n  public abstract approveSessionAuthenticate: (\n    params: AuthTypes.ApproveSessionAuthenticateParams,\n  ) => Promise<{ session: SessionTypes.Struct | undefined }>;\n\n  public abstract formatAuthMessage: (params: {\n    request: AuthTypes.BaseAuthRequestParams;\n    iss: string;\n  }) => string;\n\n  public abstract rejectSessionAuthenticate(params: EngineTypes.RejectParams): Promise<void>;\n\n  public abstract processRelayMessageCache(): void;\n}\n"],"names":["IEvents","opts","core","logger","keychain","relayer","name","storagePrefix","store","projectId","telemetryEnabled","EventEmmiter","EventEmitter","client"],"mappings":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],"debugId":null}},
    {"offset": {"line": 1421, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1427, "column": 0}, "map": {"version":3,"file":"constants.js","sourceRoot":"","sources":["../../src/constants.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;AAIO,MAAM,eAAe,GAA4B,OAAO,CAAC;AAEzD,MAAM,eAAe,GAA4B,KAAK,CAAC;AAEvD,MAAM,aAAa,GAAG,GAAG,CAAC;AAE1B,MAAM,YAAY,GAAG,WAAW,CAAC;AAEjC,MAAM,aAAa,GAAG,MAAM,CAAC;AAE7B,MAAM,aAAa,GAAG,MAAM,CAAC;AAI7B,MAAM,aAAa,GAAG,GAAG,CAAC;AAE1B,MAAM,UAAU,GAAG,KAAK,CAAC;AAEzB,MAAM,UAAU,GAAG,KAAK,CAAC;AAIzB,MAAM,2BAA2B,GAAG,WAAW,CAAC;AAEhD,MAAM,uBAAuB,GAAG,GAAG,CAAC;AAEpC,MAAM,yBAAyB,GAAG,KAAK,CAAC;AAExC,MAAM,yBAAyB,GAAG,EAAE,CAAC;AAIrC,MAAM,oBAAoB,GAAG,EAAE,CAAC","debugId":null}},
    {"offset": {"line": 1457, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1463, "column": 0}, "map": {"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,oBAAoB,CAAC;AAC5C,OAAO,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAC;AACjD,OAAO,EAAE,UAAU,EAAE,MAAM,yBAAyB,CAAC;AACrD,OAAO,EAAE,aAAa,EAAE,iBAAiB,EAAE,MAAM,0BAA0B,CAAC;AAE5E,OAAO,EACL,aAAa,EACb,aAAa,EACb,UAAU,EACV,UAAU,EACV,aAAa,EACb,aAAa,EACb,YAAY,EACZ,uBAAuB,EACvB,2BAA2B,EAC3B,yBAAyB,EACzB,yBAAyB,GAC1B,MAAM,aAAa,CAAC;;;;;;AAKf,SAAU,UAAU,CAAC,GAAW;IACpC,uOAAO,gBAAA,AAAa,gKAAC,WAAA,AAAQ,kKAAC,aAAA,AAAU,EAAC,GAAG,+KAAE,eAAY,CAAC,+KAAE,gBAAa,CAAC,CAAC,CAAC;AAC/E,CAAC;AAEK,SAAU,UAAU,CAAC,GAAQ;IACjC,oKAAO,YAAA,AAAQ,kKACb,aAAA,AAAU,kOAAC,oBAAA,AAAiB,EAAC,GAAG,CAAC,EAAE,6LAAa,CAAC,+KACjD,eAAY,CACb,CAAC;AACJ,CAAC;AAIK,SAAU,SAAS,CAAC,SAAqB;IAC7C,MAAM,MAAM,IAAG,4KAAA,AAAU,+KACvB,4BAAyB,+KACzB,8BAA2B,CAC5B,CAAC;IACF,MAAM,UAAU,GACd,uMAAuB,iKACvB,WAAA,AAAQ,0JAAC,SAAA,AAAM,EAAC;QAAC,MAAM;QAAE,SAAS;KAAC,CAAC,8KAAE,+BAA2B,CAAC,CAAC;IACrE,OAAO;qLAAC,aAAU;qLAAE,aAAU;QAAE,UAAU;KAAC,CAAC,IAAI,8KAAC,gBAAa,CAAC,CAAC;AAClE,CAAC;AAEK,SAAU,SAAS,CAAC,MAAc;IACtC,MAAM,CAAC,MAAM,EAAE,MAAM,EAAE,UAAU,CAAC,GAAG,MAAM,CAAC,KAAK,8KAAC,gBAAa,CAAC,CAAC;IACjE,IAAI,MAAM,kLAAK,aAAU,IAAI,MAAM,kLAAK,aAAU,EAAE;QAClD,MAAM,IAAI,KAAK,CAAC,CAAA,sCAAA,CAAwC,CAAC,CAAC;KAC3D;IACD,MAAM,IAAI,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IACpC,IAAI,IAAI,kLAAK,0BAAuB,EAAE;QACpC,MAAM,IAAI,KAAK,CAAC,CAAA,wCAAA,CAA0C,CAAC,CAAC;KAC7D;IACD,MAAM,KAAK,mKAAG,aAAA,AAAU,EAAC,UAAU,CAAC,KAAK,CAAC,CAAC,CAAC,+KAAE,8BAA2B,CAAC,CAAC;IAC3E,MAAM,IAAI,iKAAG,WAAA,AAAQ,EAAC,KAAK,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,+KAAE,8BAA2B,CAAC,CAAC;IACtE,IAAI,IAAI,kLAAK,4BAAyB,EAAE;QACtC,MAAM,IAAI,KAAK,CAAC,CAAA,+CAAA,CAAiD,CAAC,CAAC;KACpE;IACD,MAAM,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;IACjC,IAAI,SAAS,CAAC,MAAM,kLAAK,4BAAyB,EAAE;QAClD,MAAM,IAAI,KAAK,CAAC,CAAA,gDAAA,CAAkD,CAAC,CAAC;KACrE;IACD,OAAO,SAAS,CAAC;AACnB,CAAC;AAIK,SAAU,SAAS,CAAC,KAAiB;IACzC,OAAO,yKAAA,AAAQ,EAAC,KAAK,+KAAE,eAAY,CAAC,CAAC;AACvC,CAAC;AAEK,SAAU,SAAS,CAAC,OAAe;IACvC,WAAO,yKAAA,AAAU,EAAC,OAAO,+KAAE,eAAY,CAAC,CAAC;AAC3C,CAAC;AAIK,SAAU,UAAU,CAAC,MAAsB;IAC/C,uKAAO,aAAA,AAAU,EACf;QAAC,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC;QAAE,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC;KAAC,CAAC,IAAI,8KAAC,gBAAa,CAAC,+KAC3E,gBAAa,CACd,CAAC;AACJ,CAAC;AAEK,SAAU,UAAU,CAAC,IAAgB;IACzC,MAAM,MAAM,iKAAG,WAAA,AAAQ,EAAC,IAAI,+KAAE,gBAAa,CAAC,CAAC,KAAK,8KAAC,gBAAa,CAAC,CAAC;IAClE,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACrC,MAAM,OAAO,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACtC,OAAO;QAAE,MAAM;QAAE,OAAO;IAAA,CAAE,CAAC;AAC7B,CAAC;AAIK,SAAU,SAAS,CAAC,MAAwB;IAChD,OAAO;QACL,UAAU,CAAC,MAAM,CAAC,MAAM,CAAC;QACzB,UAAU,CAAC,MAAM,CAAC,OAAO,CAAC;QAC1B,SAAS,CAAC,MAAM,CAAC,SAAS,CAAC;KAC5B,CAAC,IAAI,CAAC,6LAAa,CAAC,CAAC;AACxB,CAAC;AAEK,SAAU,SAAS,CAAC,GAAW;IACnC,MAAM,MAAM,GAAG,GAAG,CAAC,KAAK,8KAAC,gBAAa,CAAC,CAAC;IACxC,MAAM,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACrC,MAAM,OAAO,GAAG,UAAU,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACtC,MAAM,SAAS,GAAG,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;IACvC,MAAM,IAAI,mKAAG,aAAA,AAAU,EACrB,MAAM,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,8KAAC,gBAAa,CAAC,+KACtC,gBAAa,CACd,CAAC;IACF,OAAO;QAAE,MAAM;QAAE,OAAO;QAAE,SAAS;QAAE,IAAI;IAAA,CAAE,CAAC;AAC9C,CAAC","debugId":null}},
    {"offset": {"line": 1564, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1570, "column": 0}, "map": {"version":3,"file":"api.js","sourceRoot":"","sources":["../../src/api.ts"],"names":[],"mappings":";;;;;AAAA,OAAO,KAAK,OAAO,MAAM,oBAAoB,CAAC;AAC9C,OAAO,EAAE,WAAW,EAAE,MAAM,mBAAmB,CAAC;AAChD,OAAO,EAAE,eAAe,EAAE,MAAM,qBAAqB,CAAC;AACtD,OAAO,EACL,eAAe,EACf,eAAe,EACf,oBAAoB,GACrB,MAAM,aAAa,CAAC;AAErB,OAAO,EACL,SAAS,EACT,SAAS,EACT,UAAU,EACV,SAAS,EACT,SAAS,GACV,MAAM,SAAS,CAAC;;;;;;AAEX,SAAU,eAAe,CAC7B,kKAAmB,cAAA,AAAW,+KAAC,uBAAoB,CAAC;IAEpD,oKAAO,OAAO,CAAC,kBAAA,AAAuB,EAAC,IAAI,CAAC,CAAC;AAC/C,CAAC;AAEM,KAAK,UAAU,OAAO,CAC3B,GAAW,EACX,GAAW,EACX,GAAW,EACX,OAAwB,EACxB,0KAAc,kBAAA,AAAe,EAAC,IAAI,CAAC,GAAG,EAAE,CAAC;IAEzC,MAAM,MAAM,GAAG;QAAE,GAAG,EAAE,+LAAe;QAAE,GAAG,+KAAE,kBAAe;IAAA,CAAE,CAAC;IAC9D,MAAM,GAAG,gLAAG,YAAA,AAAS,EAAC,OAAO,CAAC,SAAS,CAAC,CAAC;IACzC,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;IACtB,MAAM,OAAO,GAAG;QAAE,GAAG;QAAE,GAAG;QAAE,GAAG;QAAE,GAAG;QAAE,GAAG;IAAA,CAAE,CAAC;IAC5C,MAAM,IAAI,gLAAG,aAAU,AAAV,EAAW;QAAE,MAAM;QAAE,OAAO;IAAA,CAAE,CAAC,CAAC;IAC7C,MAAM,SAAS,gKAAG,OAAO,AAAC,AAAI,CAAJ,CAAK,OAAO,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IACxD,oLAAO,YAAA,AAAS,EAAC;QAAE,MAAM;QAAE,OAAO;QAAE,SAAS;IAAA,CAAE,CAAC,CAAC;AACnD,CAAC;AAEM,KAAK,UAAU,SAAS,CAAC,GAAW;IACzC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,gLAAG,YAAA,AAAS,EAAC,GAAG,CAAC,CAAC;IAC5D,IAAI,MAAM,CAAC,GAAG,iLAAK,mBAAe,IAAI,MAAM,CAAC,GAAG,kLAAK,kBAAe,EAAE;QACpE,MAAM,IAAI,KAAK,CAAC,8BAA8B,CAAC,CAAC;KACjD;IACD,MAAM,SAAS,gLAAG,YAAA,AAAS,EAAC,OAAO,CAAC,GAAG,CAAC,CAAC;IACzC,oKAAO,OAAO,CAAC,CAAA,AAAM,EAAC,SAAS,EAAE,IAAI,EAAE,SAAS,CAAC,CAAC;AACpD,CAAC","debugId":null}},
    {"offset": {"line": 1621, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1626, "column": 0}, "map": {"version":3,"sources":["file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/relay-auth/dist/esm/types.js"],"sourcesContent":["//# sourceMappingURL=types.js.map"],"names":[],"mappings":"AAAA,iCAAiC","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 1627, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1633, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 1639, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1656, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;AAAA,SAAgB,aAAa,CAAI,IAAY;IAC3C,IAAI,GAAG,GAAkB,SAAS,CAAC;IACnC,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,WAAW,EAAE;QACxE,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;KACpB;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAND,QAAA,aAAA,GAAA,cAMC;AAED,SAAgB,oBAAoB,CAAI,IAAY;IAClD,MAAM,GAAG,GAAG,aAAa,CAAI,IAAI,CAAC,CAAC;IACnC,IAAI,CAAC,GAAG,EAAE;QACR,MAAM,IAAI,KAAK,CAAC,GAAG,IAAI,CAAA,yBAAA,CAA2B,CAAC,CAAC;KACrD;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAND,QAAA,oBAAA,GAAA,qBAMC;AAED,SAAgB,kBAAkB;IAChC,OAAO,oBAAoB,CAAW,UAAU,CAAC,CAAC;AACpD,CAAC;AAFD,QAAA,kBAAA,GAAA,mBAEC;AAED,SAAgB,WAAW;IACzB,OAAO,aAAa,CAAW,UAAU,CAAC,CAAC;AAC7C,CAAC;AAFD,QAAA,WAAA,GAAA,YAEC;AAED,SAAgB,mBAAmB;IACjC,OAAO,oBAAoB,CAAY,WAAW,CAAC,CAAC;AACtD,CAAC;AAFD,QAAA,mBAAA,GAAA,oBAEC;AAED,SAAgB,YAAY;IAC1B,OAAO,aAAa,CAAY,WAAW,CAAC,CAAC;AAC/C,CAAC;AAFD,QAAA,YAAA,GAAA,aAEC;AAED,SAAgB,kBAAkB;IAChC,OAAO,oBAAoB,CAAW,UAAU,CAAC,CAAC;AACpD,CAAC;AAFD,QAAA,kBAAA,GAAA,mBAEC;AAED,SAAgB,WAAW;IACzB,OAAO,aAAa,CAAW,UAAU,CAAC,CAAC;AAC7C,CAAC;AAFD,QAAA,WAAA,GAAA,YAEC;AAED,SAAgB,gBAAgB;IAC9B,OAAO,oBAAoB,CAAS,QAAQ,CAAC,CAAC;AAChD,CAAC;AAFD,QAAA,gBAAA,GAAA,iBAEC;AAED,SAAgB,SAAS;IACvB,OAAO,aAAa,CAAS,QAAQ,CAAC,CAAC;AACzC,CAAC;AAFD,QAAA,SAAA,GAAA,UAEC;AAED,SAAgB,sBAAsB;IACpC,OAAO,oBAAoB,CAAU,cAAc,CAAC,CAAC;AACvD,CAAC;AAFD,QAAA,sBAAA,GAAA,uBAEC;AAED,SAAgB,eAAe;IAC7B,OAAO,aAAa,CAAU,cAAc,CAAC,CAAC;AAChD,CAAC;AAFD,QAAA,eAAA,GAAA,gBAEC","debugId":null}},
    {"offset": {"line": 1717, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1722, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;AAAA,SAAgB,aAAa,CAAI,IAAY;IAC3C,IAAI,GAAG,GAAkB,SAAS,CAAC;IACnC,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,WAAW,EAAE;QACxE,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;KACpB;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAND,QAAA,aAAA,GAAA,cAMC;AAED,SAAgB,oBAAoB,CAAI,IAAY;IAClD,MAAM,GAAG,GAAG,aAAa,CAAI,IAAI,CAAC,CAAC;IACnC,IAAI,CAAC,GAAG,EAAE;QACR,MAAM,IAAI,KAAK,CAAC,GAAG,IAAI,CAAA,yBAAA,CAA2B,CAAC,CAAC;KACrD;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAND,QAAA,oBAAA,GAAA,qBAMC;AAED,SAAgB,kBAAkB;IAChC,OAAO,oBAAoB,CAAW,UAAU,CAAC,CAAC;AACpD,CAAC;AAFD,QAAA,kBAAA,GAAA,mBAEC;AAED,SAAgB,WAAW;IACzB,OAAO,aAAa,CAAW,UAAU,CAAC,CAAC;AAC7C,CAAC;AAFD,QAAA,WAAA,GAAA,YAEC;AAED,SAAgB,mBAAmB;IACjC,OAAO,oBAAoB,CAAY,WAAW,CAAC,CAAC;AACtD,CAAC;AAFD,QAAA,mBAAA,GAAA,oBAEC;AAED,SAAgB,YAAY;IAC1B,OAAO,aAAa,CAAY,WAAW,CAAC,CAAC;AAC/C,CAAC;AAFD,QAAA,YAAA,GAAA,aAEC;AAED,SAAgB,kBAAkB;IAChC,OAAO,oBAAoB,CAAW,UAAU,CAAC,CAAC;AACpD,CAAC;AAFD,QAAA,kBAAA,GAAA,mBAEC;AAED,SAAgB,WAAW;IACzB,OAAO,aAAa,CAAW,UAAU,CAAC,CAAC;AAC7C,CAAC;AAFD,QAAA,WAAA,GAAA,YAEC;AAED,SAAgB,gBAAgB;IAC9B,OAAO,oBAAoB,CAAS,QAAQ,CAAC,CAAC;AAChD,CAAC;AAFD,QAAA,gBAAA,GAAA,iBAEC;AAED,SAAgB,SAAS;IACvB,OAAO,aAAa,CAAS,QAAQ,CAAC,CAAC;AACzC,CAAC;AAFD,QAAA,SAAA,GAAA,UAEC;AAED,SAAgB,sBAAsB;IACpC,OAAO,oBAAoB,CAAU,cAAc,CAAC,CAAC;AACvD,CAAC;AAFD,QAAA,sBAAA,GAAA,uBAEC;AAED,SAAgB,eAAe;IAC7B,OAAO,aAAa,CAAU,cAAc,CAAC,CAAC;AAChD,CAAC;AAFD,QAAA,eAAA,GAAA,gBAEC","debugId":null}},
    {"offset": {"line": 1783, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1788, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;AAAA,SAAgB,aAAa,CAAI,IAAY;IAC3C,IAAI,GAAG,GAAkB,SAAS,CAAC;IACnC,IAAI,OAAO,MAAM,KAAK,WAAW,IAAI,OAAO,MAAM,CAAC,IAAI,CAAC,KAAK,WAAW,EAAE;QACxE,GAAG,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;KACpB;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAND,QAAA,aAAA,GAAA,cAMC;AAED,SAAgB,oBAAoB,CAAI,IAAY;IAClD,MAAM,GAAG,GAAG,aAAa,CAAI,IAAI,CAAC,CAAC;IACnC,IAAI,CAAC,GAAG,EAAE;QACR,MAAM,IAAI,KAAK,CAAC,GAAG,IAAI,CAAA,yBAAA,CAA2B,CAAC,CAAC;KACrD;IACD,OAAO,GAAG,CAAC;AACb,CAAC;AAND,QAAA,oBAAA,GAAA,qBAMC;AAED,SAAgB,kBAAkB;IAChC,OAAO,oBAAoB,CAAW,UAAU,CAAC,CAAC;AACpD,CAAC;AAFD,QAAA,kBAAA,GAAA,mBAEC;AAED,SAAgB,WAAW;IACzB,OAAO,aAAa,CAAW,UAAU,CAAC,CAAC;AAC7C,CAAC;AAFD,QAAA,WAAA,GAAA,YAEC;AAED,SAAgB,mBAAmB;IACjC,OAAO,oBAAoB,CAAY,WAAW,CAAC,CAAC;AACtD,CAAC;AAFD,QAAA,mBAAA,GAAA,oBAEC;AAED,SAAgB,YAAY;IAC1B,OAAO,aAAa,CAAY,WAAW,CAAC,CAAC;AAC/C,CAAC;AAFD,QAAA,YAAA,GAAA,aAEC;AAED,SAAgB,kBAAkB;IAChC,OAAO,oBAAoB,CAAW,UAAU,CAAC,CAAC;AACpD,CAAC;AAFD,QAAA,kBAAA,GAAA,mBAEC;AAED,SAAgB,WAAW;IACzB,OAAO,aAAa,CAAW,UAAU,CAAC,CAAC;AAC7C,CAAC;AAFD,QAAA,WAAA,GAAA,YAEC;AAED,SAAgB,gBAAgB;IAC9B,OAAO,oBAAoB,CAAS,QAAQ,CAAC,CAAC;AAChD,CAAC;AAFD,QAAA,gBAAA,GAAA,iBAEC;AAED,SAAgB,SAAS;IACvB,OAAO,aAAa,CAAS,QAAQ,CAAC,CAAC;AACzC,CAAC;AAFD,QAAA,SAAA,GAAA,UAEC;AAED,SAAgB,sBAAsB;IACpC,OAAO,oBAAoB,CAAU,cAAc,CAAC,CAAC;AACvD,CAAC;AAFD,QAAA,sBAAA,GAAA,uBAEC;AAED,SAAgB,eAAe;IAC7B,OAAO,aAAa,CAAU,cAAc,CAAC,CAAC;AAChD,CAAC;AAFD,QAAA,eAAA,GAAA,gBAEC","debugId":null}},
    {"offset": {"line": 1849, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1854, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1949, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 1954, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2049, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2055, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/relay-api/src/misc.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/relay-api/src/validators.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/relay-api/src/parsers.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/relay-api/src/jsonrpc.ts"],"sourcesContent":["export function assertType(obj: any, key: string, type = \"string\") {\n  if (!obj[key] || typeof obj[key] !== type) {\n    throw new Error(`Missing or invalid \"${key}\" param`);\n  }\n}\n\nexport function hasRequiredParams(params: any, required: string[]) {\n  let matches = true;\n  required.forEach((key) => {\n    const exists = key in params;\n    if (!exists) {\n      matches = false;\n    }\n  });\n  return matches;\n}\n\nexport function hasExactParamsLength(params: any, length: number): boolean {\n  return Array.isArray(params) ? params.length === length : Object.keys(params).length === length;\n}\n\nexport function hasRequiredParamsLength(params: any, minLength: number): boolean {\n  return Array.isArray(params)\n    ? params.length >= minLength\n    : Object.keys(params).length >= minLength;\n}\n\nexport function checkParams(params: any, required: string[], optional: string[]) {\n  const exact = !optional.length;\n  const matchesLength = exact\n    ? hasExactParamsLength(params, required.length)\n    : hasRequiredParamsLength(params, required.length);\n  if (!matchesLength) return false;\n  return hasRequiredParams(params, required);\n}\n\nexport function methodEndsWith(method: string, expected: string, separator = \"_\") {\n  const split = method.split(separator);\n  return split[split.length - 1].trim().toLowerCase() === expected.trim().toLowerCase();\n}\n","import { JsonRpcRequest } from \"@walletconnect/jsonrpc-types\";\n\nimport { checkParams, methodEndsWith } from \"./misc\";\nimport { RelayJsonRpc } from \"./types\";\n\n// ---------- Subscribe ----------------------------------------------- //\n\nexport function isSubscribeRequest(\n  request: JsonRpcRequest,\n): request is JsonRpcRequest<RelayJsonRpc.SubscribeParams> {\n  return isSubscribeMethod(request.method) && isSubscribeParams(request.params);\n}\n\nexport function isSubscribeMethod(method: string): boolean {\n  return methodEndsWith(method, \"subscribe\");\n}\n\nexport function isSubscribeParams(params: any): params is RelayJsonRpc.SubscribeParams {\n  const required = [\"topic\"];\n  const optional: string[] = [];\n  return checkParams(params, required, optional);\n}\n\n// ---------- Publish ----------------------------------------------- //\n\nexport function isPublishRequest(\n  request: JsonRpcRequest,\n): request is JsonRpcRequest<RelayJsonRpc.PublishParams> {\n  return isPublishMethod(request.method) && isPublishParams(request.params);\n}\n\nexport function isPublishMethod(method: string): boolean {\n  return methodEndsWith(method, \"publish\");\n}\n\nexport function isPublishParams(params: any): params is RelayJsonRpc.PublishParams {\n  const required = [\"message\", \"topic\", \"ttl\"];\n  const optional = [\"prompt\", \"tag\"];\n  return checkParams(params, required, optional);\n}\n\n// ---------- Unsubscribe ----------------------------------------------- //\n\nexport function isUnsubscribeRequest(\n  request: JsonRpcRequest,\n): request is JsonRpcRequest<RelayJsonRpc.UnsubscribeParams> {\n  return isUnsubscribeMethod(request.method) && isUnsubscribeParams(request.params);\n}\n\nexport function isUnsubscribeMethod(method: string): boolean {\n  return methodEndsWith(method, \"unsubscribe\");\n}\n\nexport function isUnsubscribeParams(params: any): params is RelayJsonRpc.UnsubscribeParams {\n  const required = [\"id\", \"topic\"];\n  const optional: string[] = [];\n  return checkParams(params, required, optional);\n}\n\n// ---------- Subscription ----------------------------------------------- //\n\nexport function isSubscriptionRequest(\n  request: JsonRpcRequest,\n): request is JsonRpcRequest<RelayJsonRpc.SubscriptionParams> {\n  return isSubscriptionMethod(request.method) && isSubscriptionParams(request.params);\n}\n\nexport function isSubscriptionMethod(method: string): boolean {\n  return methodEndsWith(method, \"subscription\");\n}\n\nexport function isSubscriptionParams(params: any): params is RelayJsonRpc.SubscriptionParams {\n  const required = [\"id\", \"data\"];\n  const optional: string[] = [];\n  return checkParams(params, required, optional);\n}\n","import { JsonRpcRequest } from \"@walletconnect/jsonrpc-types\";\n\nimport { RelayJsonRpc } from \"./types\";\nimport { assertType } from \"./misc\";\nimport {\n  isPublishMethod,\n  isPublishParams,\n  isSubscribeMethod,\n  isSubscribeParams,\n  isSubscriptionMethod,\n  isSubscriptionParams,\n  isUnsubscribeMethod,\n  isUnsubscribeParams,\n} from \"./validators\";\n\nexport function parseSubscribeRequest(request: JsonRpcRequest): RelayJsonRpc.SubscribeParams {\n  if (!isSubscribeMethod(request.method)) {\n    throw new Error(\"JSON-RPC Request has invalid subscribe method\");\n  }\n  if (!isSubscribeParams(request.params)) {\n    throw new Error(\"JSON-RPC Request has invalid subscribe params\");\n  }\n  const params = request.params as RelayJsonRpc.SubscribeParams;\n\n  assertType(params, \"topic\");\n\n  return params;\n}\n\nexport function parsePublishRequest(request: JsonRpcRequest): RelayJsonRpc.PublishParams {\n  if (!isPublishMethod(request.method)) {\n    throw new Error(\"JSON-RPC Request has invalid publish method\");\n  }\n  if (!isPublishParams(request.params)) {\n    throw new Error(\"JSON-RPC Request has invalid publish params\");\n  }\n  const params = request.params as RelayJsonRpc.PublishParams;\n\n  assertType(params, \"topic\");\n  assertType(params, \"message\");\n  assertType(params, \"ttl\", \"number\");\n\n  return params;\n}\n\nexport function parseUnsubscribeRequest(request: JsonRpcRequest): RelayJsonRpc.UnsubscribeParams {\n  if (!isUnsubscribeMethod(request.method)) {\n    throw new Error(\"JSON-RPC Request has invalid unsubscribe method\");\n  }\n  if (!isUnsubscribeParams(request.params)) {\n    throw new Error(\"JSON-RPC Request has invalid unsubscribe params\");\n  }\n  const params = request.params as RelayJsonRpc.UnsubscribeParams;\n\n  assertType(params, \"id\");\n\n  return params;\n}\n\nexport function parseSubscriptionRequest(request: JsonRpcRequest): RelayJsonRpc.SubscriptionParams {\n  if (!isSubscriptionMethod(request.method)) {\n    throw new Error(\"JSON-RPC Request has invalid subscription method\");\n  }\n  if (!isSubscriptionParams(request.params)) {\n    throw new Error(\"JSON-RPC Request has invalid subscription params\");\n  }\n  const params = request.params as RelayJsonRpc.SubscriptionParams;\n\n  assertType(params, \"id\");\n  assertType(params, \"data\");\n\n  return params;\n}\n","import { RelayJsonRpc } from \"./types\";\n\nexport const RELAY_JSONRPC: { [protocol: string]: RelayJsonRpc.Methods } = {\n  waku: {\n    publish: \"waku_publish\",\n    batchPublish: \"waku_batchPublish\",\n    subscribe: \"waku_subscribe\",\n    batchSubscribe: \"waku_batchSubscribe\",\n    subscription: \"waku_subscription\",\n    unsubscribe: \"waku_unsubscribe\",\n    batchUnsubscribe: \"waku_batchUnsubscribe\",\n    batchFetchMessages: \"waku_batchFetchMessages\",\n  },\n  irn: {\n    publish: \"irn_publish\",\n    batchPublish: \"irn_batchPublish\",\n    subscribe: \"irn_subscribe\",\n    batchSubscribe: \"irn_batchSubscribe\",\n    subscription: \"irn_subscription\",\n    unsubscribe: \"irn_unsubscribe\",\n    batchUnsubscribe: \"irn_batchUnsubscribe\",\n    batchFetchMessages: \"irn_batchFetchMessages\",\n  },\n  iridium: {\n    publish: \"iridium_publish\",\n    batchPublish: \"iridium_batchPublish\",\n    subscribe: \"iridium_subscribe\",\n    batchSubscribe: \"iridium_batchSubscribe\",\n    subscription: \"iridium_subscription\",\n    unsubscribe: \"iridium_unsubscribe\",\n    batchUnsubscribe: \"iridium_batchUnsubscribe\",\n    batchFetchMessages: \"iridium_batchFetchMessages\",\n  },\n};\n"],"names":["obj","key","type","params","required","matches","length","minLength","optional","method","expected","separator","split","request","methodEndsWith","checkParams","isSubscribeMethod","isSubscribeParams","assertType","isPublishMethod","isPublishParams","isUnsubscribeMethod","isUnsubscribeParams","isSubscriptionMethod","isSubscriptionParams"],"mappings":"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","ignoreList":[0,1,2,3],"debugId":null}},
    {"offset": {"line": 2205, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 2211, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/utils/src/caip.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/utils/src/misc.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/utils/src/signatures.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/utils/src/cacao.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/utils/src/crypto.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/utils/src/relay.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/utils/src/uri.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/utils/src/namespaces.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/utils/src/errors.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/utils/src/validators.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/utils/src/network.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/utils/src/memoryStore.ts"],"sourcesContent":["import { SessionTypes, ProposalTypes } from \"@walletconnect/types\";\n\ninterface ChainIdParams {\n  namespace: string;\n  reference: string;\n}\n\ninterface AccountIdParams extends ChainIdParams {\n  address: string;\n}\n\nconst CAIP_DELIMITER = \":\";\n\nexport function parseChainId(chain: string): ChainIdParams {\n  const [namespace, reference] = chain.split(CAIP_DELIMITER);\n  return { namespace, reference };\n}\n\nexport function formatChainId(params: ChainIdParams): string {\n  const { namespace, reference } = params;\n  return [namespace, reference].join(CAIP_DELIMITER);\n}\n\nexport function parseAccountId(account: string): AccountIdParams {\n  const [namespace, reference, address] = account.split(CAIP_DELIMITER);\n  return { namespace, reference, address };\n}\n\nexport function formatAccountId(params: AccountIdParams): string {\n  const { namespace, reference, address } = params;\n  return [namespace, reference, address].join(CAIP_DELIMITER);\n}\n\nexport function getUniqueValues(array: string[], parser: (str: string) => string): string[] {\n  const unique: string[] = [];\n  array.forEach((str) => {\n    const value = parser(str);\n    if (!unique.includes(value)) unique.push(value);\n  });\n  return unique;\n}\n\nexport function getAddressFromAccount(account: string) {\n  const { address } = parseAccountId(account);\n  return address;\n}\n\nexport function getChainFromAccount(account: string) {\n  const { namespace, reference } = parseAccountId(account);\n  const chain = formatChainId({ namespace, reference });\n  return chain;\n}\n\nexport function formatAccountWithChain(address: string, chain: string) {\n  const { namespace, reference } = parseChainId(chain);\n  const account = formatAccountId({ namespace, reference, address });\n  return account;\n}\n\nexport function getAddressesFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getAddressFromAccount);\n}\n\nexport function getChainsFromAccounts(accounts: string[]) {\n  return getUniqueValues(accounts, getChainFromAccount);\n}\n\nexport function getAccountsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const accounts: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    accounts.push(...ns.accounts);\n  });\n  return accounts;\n}\n\nexport function getChainsFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(namespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = namespaces[key];\n    chains.push(...getChainsFromAccounts(ns.accounts));\n  });\n  return chains;\n}\n\nexport function getChainsFromRequiredNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  keys: string[] = [],\n): string[] {\n  const chains: string[] = [];\n  Object.keys(requiredNamespaces).forEach((key) => {\n    if (keys.length && !keys.includes(key)) return;\n    const ns = requiredNamespaces[key];\n    chains.push(...getChainsFromNamespace(key, ns));\n  });\n  return chains;\n}\n\nexport function getChainsFromNamespace(\n  namespace: string,\n  namespaceProps: ProposalTypes.BaseRequiredNamespace,\n) {\n  // check if chainId is provided in the key as `eip155:1` or in the namespace as chains[]\n  return namespace.includes(\":\") ? [namespace] : namespaceProps.chains || [];\n}\n","import { detect } from \"detect-browser\";\nimport { FIVE_MINUTES, fromMiliseconds, toMiliseconds } from \"@walletconnect/time\";\nimport {\n  SignClientTypes,\n  RelayerClientMetadata,\n  EngineTypes,\n  RelayerTypes,\n} from \"@walletconnect/types\";\nimport { getDocument, getLocation, getNavigator } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata } from \"@walletconnect/window-metadata\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-utils\";\nimport { IKeyValueStorage } from \"@walletconnect/keyvaluestorage\";\nimport * as qs from \"query-string\";\n\n// -- constants -----------------------------------------//\nexport const REACT_NATIVE_PRODUCT = \"ReactNative\";\n\nexport const ENV_MAP = {\n  reactNative: \"react-native\",\n  node: \"node\",\n  browser: \"browser\",\n  unknown: \"unknown\",\n};\n\nexport const EMPTY_SPACE = \" \";\n\nexport const COLON = \":\";\n\nexport const SLASH = \"/\";\n\nexport const DEFAULT_DEPTH = 2;\n\nexport const ONE_THOUSAND = 1000;\n\nexport const SDK_TYPE = \"js\";\n\n// -- env -----------------------------------------------//\n\nexport function isNode(): boolean {\n  return (\n    typeof process !== \"undefined\" &&\n    typeof process.versions !== \"undefined\" &&\n    typeof process.versions.node !== \"undefined\"\n  );\n}\n\nexport function isReactNative(): boolean {\n  return !getDocument() && !!getNavigator() && navigator.product === REACT_NATIVE_PRODUCT;\n}\n\nexport function isAndroid(): boolean {\n  return (\n    isReactNative() &&\n    typeof global !== \"undefined\" &&\n    typeof (global as any)?.Platform !== \"undefined\" &&\n    (global as any)?.Platform.OS === \"android\"\n  );\n}\n\nexport function isIos(): boolean {\n  return (\n    isReactNative() &&\n    typeof global !== \"undefined\" &&\n    typeof (global as any)?.Platform !== \"undefined\" &&\n    (global as any)?.Platform.OS === \"ios\"\n  );\n}\n\nexport function isBrowser(): boolean {\n  return !isNode() && !!getNavigator() && !!getDocument();\n}\n\nexport function getEnvironment(): string {\n  if (isReactNative()) return ENV_MAP.reactNative;\n  if (isNode()) return ENV_MAP.node;\n  if (isBrowser()) return ENV_MAP.browser;\n  return ENV_MAP.unknown;\n}\n\nexport function getAppId(): string | undefined {\n  try {\n    if (\n      isReactNative() &&\n      typeof global !== \"undefined\" &&\n      typeof (global as any)?.Application !== \"undefined\"\n    ) {\n      return (global as any).Application?.applicationId;\n    }\n    return undefined;\n  } catch {\n    return undefined;\n  }\n}\n\n// -- query -----------------------------------------------//\n\nexport function appendToQueryString(queryString: string, newQueryParams: any): string {\n  let queryParams = qs.parse(queryString);\n\n  queryParams = { ...queryParams, ...newQueryParams };\n\n  queryString = qs.stringify(queryParams);\n\n  return queryString;\n}\n\n// -- metadata ----------------------------------------------//\n\nexport function getAppMetadata(): SignClientTypes.Metadata {\n  return (\n    getWindowMetadata() || {\n      name: \"\",\n      description: \"\",\n      url: \"\",\n      icons: [\"\"],\n    }\n  );\n}\n\nexport function getRelayClientMetadata(protocol: string, version: number): RelayerClientMetadata {\n  const env = getEnvironment();\n\n  const metadata: RelayerClientMetadata = { protocol, version, env };\n  if (env === \"browser\") {\n    metadata.host = getLocation()?.host || \"unknown\";\n  }\n  return metadata;\n}\n\n// -- rpcUrl ----------------------------------------------//\n\nexport function getJavascriptOS() {\n  const env = getEnvironment();\n  // global.Platform is set by react-native-compat\n  if (\n    env === ENV_MAP.reactNative &&\n    typeof global !== \"undefined\" &&\n    typeof (global as any)?.Platform !== \"undefined\"\n  ) {\n    const { OS, Version } = (global as any).Platform;\n    return [OS, Version].join(\"-\");\n  }\n\n  const info = detect();\n  if (info === null) return \"unknown\";\n  const os = info.os ? info.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  if (info.type === \"browser\") {\n    return [os, info.name, info.version].join(\"-\");\n  }\n  return [os, info.version].join(\"-\");\n}\n\nexport function getJavascriptID() {\n  const env = getEnvironment();\n  return env === ENV_MAP.browser ? [env, getLocation()?.host || \"unknown\"].join(\":\") : env;\n}\n\nexport function formatUA(protocol: string, version: number, sdkVersion: string) {\n  const os = getJavascriptOS();\n  const id = getJavascriptID();\n  return [[protocol, version].join(\"-\"), [SDK_TYPE, sdkVersion].join(\"-\"), os, id].join(\"/\");\n}\nconsole;\n\nexport function formatRelayRpcUrl({\n  protocol,\n  version,\n  relayUrl,\n  sdkVersion,\n  auth,\n  projectId,\n  useOnCloseEvent,\n  bundleId,\n  packageName,\n}: RelayerTypes.RpcUrlParams) {\n  const splitUrl = relayUrl.split(\"?\");\n  const ua = formatUA(protocol, version, sdkVersion);\n  const params = {\n    auth,\n    ua,\n    projectId,\n    useOnCloseEvent: useOnCloseEvent || undefined,\n    packageName: packageName || undefined,\n    bundleId: bundleId || undefined,\n  };\n  const queryString = appendToQueryString(splitUrl[1] || \"\", params);\n  return splitUrl[0] + \"?\" + queryString;\n}\n\nexport function getHttpUrl(url: string) {\n  // regex from https://stackoverflow.com/questions/3883871/regexp-to-grab-protocol-from-url\n  const matches = url.match(/^[^:]+(?=:\\/\\/)/gi) || [];\n  let protocol = matches[0];\n  const domain = typeof protocol !== \"undefined\" ? url.split(\"://\")[1] : url;\n  protocol = protocol === \"wss\" ? \"https\" : \"http\";\n  return [protocol, domain].join(\"://\");\n}\n\n// -- assert ------------------------------------------------- //\n\nexport function assertType(obj: any, key: string, type: string) {\n  if (!obj[key] || typeof obj[key] !== type) {\n    throw new Error(`Missing or invalid \"${key}\" param`);\n  }\n}\n\n// -- context ------------------------------------------------- //\n\nexport function parseContextNames(context: string, depth = DEFAULT_DEPTH) {\n  return getLastItems(context.split(SLASH), depth);\n}\n\nexport function formatMessageContext(context: string): string {\n  return parseContextNames(context).join(EMPTY_SPACE);\n}\n\n// -- array ------------------------------------------------- //\n\nexport function hasOverlap(a: any[], b: any[]): boolean {\n  const matches = a.filter((x) => b.includes(x));\n  return matches.length === a.length;\n}\n\nexport function getLastItems(arr: any[], depth = DEFAULT_DEPTH): any[] {\n  return arr.slice(Math.max(arr.length - depth, 0));\n}\n\n// -- map ------------------------------------------------- //\n\nexport function mapToObj<T = any>(map: Map<string, T>): Record<string, T> {\n  return Object.fromEntries(map.entries());\n}\n\nexport function objToMap<T = any>(obj: Record<string, T>): Map<string, T> {\n  return new Map<string, T>(Object.entries<T>(obj));\n}\n\nexport function mapEntries<A = any, B = any>(\n  obj: Record<string, A>,\n  cb: (x: A) => B,\n): Record<string, B> {\n  const res = {};\n  Object.keys(obj).forEach((key) => {\n    res[key] = cb(obj[key]);\n  });\n  return res;\n}\n\n// -- enum ------------------------------------------------- //\n\n// source: https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275\nexport const enumify = <T extends { [index: string]: U }, U extends string>(x: T): T => x;\n\n// -- string ------------------------------------------------- //\n\nexport function capitalizeWord(word: string) {\n  return word.trim().replace(/^\\w/, (c) => c.toUpperCase());\n}\n\nexport function capitalize(str: string) {\n  return str\n    .split(EMPTY_SPACE)\n    .map((w) => capitalizeWord(w))\n    .join(EMPTY_SPACE);\n}\n\n// -- promises --------------------------------------------- //\nexport function createDelayedPromise<T>(\n  expiry: number = FIVE_MINUTES,\n  expireErrorMessage?: string,\n) {\n  const timeout = toMiliseconds(expiry || FIVE_MINUTES);\n  let cacheResolve: undefined | ((value: T | PromiseLike<T>) => void);\n  let cacheReject: undefined | ((value?: ErrorResponse) => void);\n  let cacheTimeout: undefined | NodeJS.Timeout;\n  let result: Promise<Awaited<T>> | Promise<T> | undefined;\n\n  const done = () =>\n    new Promise<T>((promiseResolve, promiseReject) => {\n      if (result) {\n        return promiseResolve(result);\n      }\n      cacheTimeout = setTimeout(() => {\n        const err = new Error(expireErrorMessage);\n        result = Promise.reject(err);\n        promiseReject(err);\n      }, timeout);\n      cacheResolve = promiseResolve;\n      cacheReject = promiseReject;\n    });\n  const resolve = (value?: T) => {\n    if (cacheTimeout && cacheResolve) {\n      clearTimeout(cacheTimeout);\n      cacheResolve(value as T);\n      result = Promise.resolve(value) as Promise<Awaited<T>>;\n    }\n  };\n  const reject = (value?: ErrorResponse) => {\n    if (cacheTimeout && cacheReject) {\n      clearTimeout(cacheTimeout);\n      cacheReject(value);\n    }\n  };\n\n  return {\n    resolve,\n    reject,\n    done,\n  };\n}\n\nexport function createExpiringPromise<T>(\n  promise: Promise<T>,\n  expiry: number,\n  expireErrorMessage?: string,\n) {\n  return new Promise(async (resolve, reject) => {\n    const timeout = setTimeout(() => reject(new Error(expireErrorMessage)), expiry);\n    try {\n      const result = await promise;\n      resolve(result);\n    } catch (error) {\n      reject(error);\n    }\n    clearTimeout(timeout);\n  });\n}\n\n// -- expirer --------------------------------------------- //\n\nexport function formatExpirerTarget(type: \"topic\" | \"id\", value: string | number): string {\n  if (typeof value === \"string\" && value.startsWith(`${type}:`)) return value;\n  if (type.toLowerCase() === \"topic\") {\n    if (typeof value !== \"string\")\n      throw new Error(`Value must be \"string\" for expirer target type: topic`);\n    return `topic:${value}`;\n  } else if (type.toLowerCase() === \"id\") {\n    if (typeof value !== \"number\")\n      throw new Error(`Value must be \"number\" for expirer target type: id`);\n    return `id:${value}`;\n  }\n  throw new Error(`Unknown expirer target type: ${type}`);\n}\n\nexport function formatTopicTarget(topic: string): string {\n  return formatExpirerTarget(\"topic\", topic);\n}\n\nexport function formatIdTarget(id: number): string {\n  return formatExpirerTarget(\"id\", id);\n}\n\nexport function parseExpirerTarget(target: string) {\n  const [type, value] = target.split(\":\");\n  const parsed: { id?: number; topic?: string } = { id: undefined, topic: undefined };\n  if (type === \"topic\" && typeof value === \"string\") {\n    parsed.topic = value;\n  } else if (type === \"id\" && Number.isInteger(Number(value))) {\n    parsed.id = Number(value);\n  } else {\n    throw new Error(`Invalid target, expected id:number or topic:string, got ${type}:${value}`);\n  }\n\n  return parsed;\n}\n\nexport function calcExpiry(ttl: number, now?: number): number {\n  return fromMiliseconds((now || Date.now()) + toMiliseconds(ttl));\n}\n\nexport function isExpired(expiry: number) {\n  return Date.now() >= toMiliseconds(expiry);\n}\n\n// -- events ---------------------------------------------- //\n\nexport function engineEvent(event: EngineTypes.Event, id?: number | string | undefined) {\n  return `${event}${id ? `:${id}` : \"\"}`;\n}\n\nexport function mergeArrays<T>(a: T[] = [], b: T[] = []): T[] {\n  return [...new Set([...a, ...b])];\n}\n\nexport async function handleDeeplinkRedirect({\n  id,\n  topic,\n  wcDeepLink,\n}: {\n  id: number;\n  topic: string;\n  wcDeepLink: string;\n}) {\n  try {\n    if (!wcDeepLink) return;\n\n    const json = typeof wcDeepLink === \"string\" ? JSON.parse(wcDeepLink) : wcDeepLink;\n    const deeplink = json?.href;\n    if (typeof deeplink !== \"string\") return;\n    const link = formatDeeplinkUrl(deeplink, id, topic);\n    const env = getEnvironment();\n\n    if (env === ENV_MAP.browser) {\n      if (!getDocument()?.hasFocus()) {\n        console.warn(\"Document does not have focus, skipping deeplink.\");\n        return;\n      }\n\n      if (link.startsWith(\"https://\") || link.startsWith(\"http://\")) {\n        window.open(link, \"_blank\", \"noreferrer noopener\");\n      } else {\n        window.open(link, isTelegram() ? \"_blank\" : \"_self\", \"noreferrer noopener\");\n      }\n    } else if (env === ENV_MAP.reactNative) {\n      // global.Linking is set by react-native-compat\n      if (typeof (global as any)?.Linking !== \"undefined\") {\n        await (global as any).Linking.openURL(link);\n      }\n    }\n  } catch (err) {\n    // Silent error, just log in console\n    // eslint-disable-next-line no-console\n    console.error(err);\n  }\n}\n\nexport function formatDeeplinkUrl(deeplink: string, requestId: number, sessionTopic: string) {\n  const payload = `requestId=${requestId}&sessionTopic=${sessionTopic}`;\n  if (deeplink.endsWith(\"/\")) deeplink = deeplink.slice(0, -1);\n  let link = `${deeplink}`;\n  if (deeplink.startsWith(\"https://t.me\")) {\n    const startApp = deeplink.includes(\"?\") ? \"&startapp=\" : \"?startapp=\";\n    link = `${link}${startApp}${toBase64(payload, true)}`;\n  } else {\n    link = `${link}/wc?${payload}`;\n  }\n  return link;\n}\n\nexport async function getDeepLink(storage: IKeyValueStorage, key: string) {\n  let link: string | undefined = \"\";\n  try {\n    if (isBrowser()) {\n      link = localStorage.getItem(key) as string;\n      if (link) return link;\n    }\n    link = await storage.getItem(key);\n  } catch (err) {\n    // eslint-disable-next-line no-console\n    console.error(err);\n  }\n  return link;\n}\n\nexport function getCommonValuesInArrays<T = string | number | boolean>(arr1: T[], arr2: T[]): T[] {\n  return arr1.filter((value) => arr2.includes(value));\n}\n\nexport function getSearchParamFromURL(url: string, param: any) {\n  const include = url.includes(param);\n  if (!include) return null;\n  const params = url.split(/([&,?,=])/);\n  const index = params.indexOf(param);\n  const value = params[index + 2];\n  return value;\n}\n\nexport function uuidv4() {\n  if (typeof crypto !== \"undefined\" && crypto?.randomUUID) {\n    return crypto.randomUUID();\n  }\n\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/gu, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n\n    return v.toString(16);\n  });\n}\n\nexport function isTestRun() {\n  return typeof process !== \"undefined\" && process.env.IS_VITEST === \"true\";\n}\n\nexport function isTelegram() {\n  return (\n    typeof window !== \"undefined\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (Boolean((window as any).TelegramWebviewProxy) ||\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      Boolean((window as any).Telegram) ||\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      Boolean((window as any).TelegramWebviewProxyProto))\n  );\n}\n\nexport function toBase64(input: string, removePadding = false): string {\n  const encoded = Buffer.from(input).toString(\"base64\");\n  return removePadding ? encoded.replace(/[=]/g, \"\") : encoded;\n}\n\nexport function fromBase64(encodedString: string): string {\n  return Buffer.from(encodedString, \"base64\").toString(\"utf-8\");\n}\n\nexport function sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n","import { hashMessage } from \"@ethersproject/hash\";\nimport { recoverAddress } from \"@ethersproject/transactions\";\nimport { AuthTypes } from \"@walletconnect/types\";\nimport { parseChainId } from \"./caip\";\nconst DEFAULT_RPC_URL = \"https://rpc.walletconnect.org/v1\";\n\nexport async function verifySignature(\n  address: string,\n  reconstructedMessage: string,\n  cacaoSignature: AuthTypes.CacaoSignature,\n  chainId: string,\n  projectId: string,\n  baseRpcUrl?: string,\n): Promise<boolean> {\n  // Determine if this signature is from an EOA or a contract.\n  switch (cacaoSignature.t) {\n    case \"eip191\":\n      return isValidEip191Signature(address, reconstructedMessage, cacaoSignature.s);\n    case \"eip1271\":\n      return await isValidEip1271Signature(\n        address,\n        reconstructedMessage,\n        cacaoSignature.s,\n        chainId,\n        projectId,\n        baseRpcUrl,\n      );\n      break;\n    default:\n      throw new Error(\n        `verifySignature failed: Attempted to verify CacaoSignature with unknown type: ${cacaoSignature.t}`,\n      );\n  }\n}\n\nexport function isValidEip191Signature(\n  address: string,\n  message: string,\n  signature: string,\n): boolean {\n  const recoveredAddress = recoverAddress(hashMessage(message), signature);\n  return recoveredAddress.toLowerCase() === address.toLowerCase();\n}\n\nexport async function isValidEip1271Signature(\n  address: string,\n  reconstructedMessage: string,\n  signature: string,\n  chainId: string,\n  projectId: string,\n  baseRpcUrl?: string,\n) {\n  const parsedChain = parseChainId(chainId);\n  if (!parsedChain.namespace || !parsedChain.reference) {\n    throw new Error(\n      `isValidEip1271Signature failed: chainId must be in CAIP-2 format, received: ${chainId}`,\n    );\n  }\n  try {\n    const eip1271MagicValue = \"0x1626ba7e\";\n    const dynamicTypeOffset = \"0000000000000000000000000000000000000000000000000000000000000040\";\n    const dynamicTypeLength = \"0000000000000000000000000000000000000000000000000000000000000041\";\n    const nonPrefixedSignature = signature.substring(2);\n    const nonPrefixedHashedMessage = hashMessage(reconstructedMessage).substring(2);\n\n    const data =\n      eip1271MagicValue +\n      nonPrefixedHashedMessage +\n      dynamicTypeOffset +\n      dynamicTypeLength +\n      nonPrefixedSignature;\n    const response = await fetch(\n      `${baseRpcUrl || DEFAULT_RPC_URL}/?chainId=${chainId}&projectId=${projectId}`,\n      {\n        method: \"POST\",\n        body: JSON.stringify({\n          id: generateJsonRpcId(),\n          jsonrpc: \"2.0\",\n          method: \"eth_call\",\n          params: [{ to: address, data }, \"latest\"],\n        }),\n      },\n    );\n    const { result } = await response.json();\n    if (!result) return false;\n\n    // Remove right-padded zeros from result to get only the concrete recovered value.\n    const recoveredValue = result.slice(0, eip1271MagicValue.length);\n    return recoveredValue.toLowerCase() === eip1271MagicValue.toLowerCase();\n  } catch (error: any) {\n    // eslint-disable-next-line no-console\n    console.error(\"isValidEip1271Signature: \", error);\n    return false;\n  }\n}\n\nfunction generateJsonRpcId() {\n  return Date.now() + Math.floor(Math.random() * 1000);\n}\n","import { AuthTypes } from \"@walletconnect/types\";\nimport { getCommonValuesInArrays } from \"./misc\";\nimport { verifySignature } from \"./signatures\";\nconst didPrefix = \"did:pkh:\";\nexport const getDidAddressSegments = (iss: string) => {\n  return iss?.split(\":\");\n};\n\nexport const getDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return iss.includes(didPrefix) ? segments[3] : segments[1];\n  }\n  return undefined;\n};\n\nexport const getNamespacedDidChainId = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments[2] + \":\" + segments[3];\n  }\n  return undefined;\n};\n\nexport const getDidAddress = (iss: string) => {\n  const segments = iss && getDidAddressSegments(iss);\n  if (segments) {\n    return segments.pop();\n  }\n  return undefined;\n};\n\nexport async function validateSignedCacao(params: { cacao: AuthTypes.Cacao; projectId?: string }) {\n  const { cacao, projectId } = params;\n  const { s: signature, p: payload } = cacao;\n  const reconstructed = formatMessage(payload, payload.iss);\n  const walletAddress = getDidAddress(payload.iss) as string;\n  const isValid = await verifySignature(\n    walletAddress,\n    reconstructed,\n    signature,\n    getNamespacedDidChainId(payload.iss) as string,\n    projectId as string,\n  );\n\n  return isValid;\n}\n\nexport const formatMessage = (cacao: AuthTypes.FormatMessageParams, iss: string) => {\n  const header = `${cacao.domain} wants you to sign in with your Ethereum account:`;\n  const walletAddress = getDidAddress(iss);\n\n  if (!cacao.aud && !cacao.uri) {\n    throw new Error(\"Either `aud` or `uri` is required to construct the message\");\n  }\n\n  let statement = cacao.statement || undefined;\n  const uri = `URI: ${cacao.aud || cacao.uri}`;\n  const version = `Version: ${cacao.version}`;\n  const chainId = `Chain ID: ${getDidChainId(iss)}`;\n  const nonce = `Nonce: ${cacao.nonce}`;\n  const issuedAt = `Issued At: ${cacao.iat}`;\n  const expirationTime = cacao.exp ? `Expiration Time: ${cacao.exp}` : undefined;\n  const notBefore = cacao.nbf ? `Not Before: ${cacao.nbf}` : undefined;\n  const requestId = cacao.requestId ? `Request ID: ${cacao.requestId}` : undefined;\n  const resources = cacao.resources\n    ? `Resources:${cacao.resources.map((resource) => `\\n- ${resource}`).join(\"\")}`\n    : undefined;\n  const recap = getRecapFromResources(cacao.resources);\n  if (recap) {\n    const decoded = decodeRecap(recap);\n    statement = formatStatementFromRecap(statement, decoded);\n  }\n\n  const message = [\n    header,\n    walletAddress,\n    ``,\n    statement,\n    ``,\n    uri,\n    version,\n    chainId,\n    nonce,\n    issuedAt,\n    expirationTime,\n    notBefore,\n    requestId,\n    resources,\n  ]\n    .filter((val) => val !== undefined && val !== null) // remove unnecessary empty lines\n    .join(\"\\n\");\n\n  return message;\n};\n\nexport function buildAuthObject(\n  requestPayload: AuthTypes.PayloadParams,\n  signature: AuthTypes.CacaoSignature,\n  iss: string,\n) {\n  if (!iss.includes(\"did:pkh:\")) {\n    iss = `did:pkh:${iss}`;\n  }\n\n  const authObject: AuthTypes.Cacao = {\n    h: {\n      t: \"caip122\",\n    },\n    p: {\n      iss,\n      domain: requestPayload.domain,\n      aud: requestPayload.aud,\n      version: requestPayload.version,\n      nonce: requestPayload.nonce,\n      iat: requestPayload.iat,\n      statement: requestPayload.statement,\n      requestId: requestPayload.requestId,\n      resources: requestPayload.resources,\n      nbf: requestPayload.nbf,\n      exp: requestPayload.exp,\n    },\n    s: signature,\n  };\n  return authObject;\n}\ntype PopulateAuthPayloadParams = {\n  authPayload: AuthTypes.PayloadParams;\n  chains: string[];\n  methods: string[];\n};\nexport function populateAuthPayload(params: PopulateAuthPayloadParams): AuthTypes.PayloadParams {\n  const { authPayload, chains, methods } = params;\n  const statement = authPayload.statement || \"\";\n\n  if (!chains?.length) return authPayload;\n\n  const requested = authPayload.chains;\n  const supported = chains;\n\n  const supportedChains = getCommonValuesInArrays<string>(requested, supported);\n  if (!supportedChains?.length) {\n    throw new Error(\"No supported chains\");\n  }\n\n  const requestedRecaps = getDecodedRecapFromResources(authPayload.resources);\n  if (!requestedRecaps) return authPayload;\n\n  isValidRecap(requestedRecaps);\n  const resource = getRecapResource(requestedRecaps, \"eip155\");\n  let updatedResources = authPayload?.resources || [];\n\n  if (resource?.length) {\n    const actions = getReCapActions(resource);\n    const supportedActions = getCommonValuesInArrays<string>(actions, methods);\n    if (!supportedActions?.length) {\n      throw new Error(\n        `Supported methods don't satisfy the requested: ${JSON.stringify(\n          actions,\n        )}, supported: ${JSON.stringify(methods)}`,\n      );\n    }\n    const formattedActions = assignAbilityToActions(\"request\", supportedActions as string[], {\n      chains: supportedChains,\n    });\n    const updatedRecap = addResourceToRecap(requestedRecaps, \"eip155\", formattedActions);\n    // remove recap from resources as we will add the updated one\n    updatedResources = authPayload?.resources?.slice(0, -1) || [];\n    updatedResources.push(encodeRecap(updatedRecap));\n  }\n\n  return {\n    ...authPayload,\n    statement: buildRecapStatement(statement, getRecapFromResources(updatedResources)),\n    chains: supportedChains,\n    resources: authPayload?.resources || updatedResources.length > 0 ? updatedResources : undefined,\n  };\n}\n\nexport function getDecodedRecapFromResources(resources?: string[]) {\n  const resource = getRecapFromResources(resources);\n  if (!resource) return;\n  if (!isRecap(resource)) return;\n  return decodeRecap(resource);\n}\n\nexport function recapHasResource(recap: any, resource: string) {\n  return recap?.att?.hasOwnProperty(resource);\n}\n\nexport function getRecapResource(recap: any, resource: string): any[] {\n  return recap?.att?.[resource] ? Object.keys(recap?.att?.[resource]) : [];\n}\n\nexport function getRecapAbilitiesFromResource(actions: any[]) {\n  return actions?.map((action) => Object.keys(action)) || [];\n}\n\nexport function getReCapActions(abilities: any[]) {\n  return abilities?.map((ability) => ability.split(\"/\")?.[1]) || [];\n}\n\nexport function base64Encode(input: unknown): string {\n  return Buffer.from(JSON.stringify(input)).toString(\"base64\");\n}\n\nexport function base64Decode(encodedString: string): string {\n  return JSON.parse(Buffer.from(encodedString, \"base64\").toString(\"utf-8\"));\n}\n\nexport function isValidRecap(recap: any) {\n  if (!recap) throw new Error(\"No recap provided, value is undefined\");\n  if (!recap.att) throw new Error(\"No `att` property found\");\n  const resources = Object.keys(recap.att);\n  if (!resources?.length) throw new Error(\"No resources found in `att` property\");\n  resources.forEach((resource) => {\n    const resourceAbilities = recap.att[resource];\n    if (Array.isArray(resourceAbilities))\n      throw new Error(`Resource must be an object: ${resource}`);\n    if (typeof resourceAbilities !== \"object\")\n      throw new Error(`Resource must be an object: ${resource}`);\n    if (!Object.keys(resourceAbilities).length)\n      throw new Error(`Resource object is empty: ${resource}`);\n\n    Object.keys(resourceAbilities).forEach((ability) => {\n      const limits = resourceAbilities[ability];\n      if (!Array.isArray(limits))\n        throw new Error(`Ability limits ${ability} must be an array of objects, found: ${limits}`);\n      if (!limits.length)\n        throw new Error(`Value of ${ability} is empty array, must be an array with objects`);\n      limits.forEach((limit) => {\n        if (typeof limit !== \"object\")\n          throw new Error(\n            `Ability limits (${ability}) must be an array of objects, found: ${limit}`,\n          );\n      });\n    });\n  });\n}\n\nexport function createRecap(resource: string, ability: string, actions: string[], limits = {}) {\n  actions?.sort((a, b) => a.localeCompare(b));\n  return {\n    att: { [resource]: assignAbilityToActions(ability, actions, limits) },\n  };\n}\n\ntype RecapType = {\n  att: {\n    [key: string]: Record<string, unknown>;\n  };\n};\nexport function addResourceToRecap(recap: RecapType, resource: string, actions: unknown[]) {\n  recap.att[resource] = {\n    ...actions,\n  };\n  const keys = Object.keys(recap.att)?.sort((a, b) => a.localeCompare(b));\n  const sorted = keys.reduce(\n    (obj, key) => {\n      obj.att[key] = recap.att[key];\n      return obj;\n    },\n    { att: {} },\n  );\n  return sorted;\n}\n\nexport function assignAbilityToActions(ability: string, actions: string[], limits = {}) {\n  // sort resources alphabetically\n  actions = actions?.sort((a, b) => a.localeCompare(b));\n  const abilities = actions.map((action) => {\n    return {\n      [`${ability}/${action}`]: [limits],\n    };\n  });\n  return Object.assign({}, ...abilities);\n}\n\nexport function encodeRecap(recap: any) {\n  isValidRecap(recap);\n  // remove the padding from the base64 string as per recap spec\n  return `urn:recap:${base64Encode(recap).replace(/=/g, \"\")}`;\n}\n\nexport function decodeRecap(recap: any): RecapType {\n  // base64Decode adds padding internally so don't need to add it back if it was removed\n  const decoded = base64Decode(recap.replace(\"urn:recap:\", \"\"));\n  isValidRecap(decoded);\n  return decoded as unknown as RecapType;\n}\n\nexport function createEncodedRecap(resource: string, ability: string, actions: string[]): string {\n  const recap = createRecap(resource, ability, actions);\n  return encodeRecap(recap);\n}\n\nexport function isRecap(resource: string) {\n  return resource && resource.includes(\"urn:recap:\");\n}\n\nexport function mergeEncodedRecaps(recap1: string, recap2: string) {\n  const decoded1 = decodeRecap(recap1);\n  const decoded2 = decodeRecap(recap2);\n  const merged = mergeRecaps(decoded1, decoded2);\n  return encodeRecap(merged);\n}\n\nexport function mergeRecaps(recap1: RecapType, recap2: RecapType) {\n  isValidRecap(recap1);\n  isValidRecap(recap2);\n  const keys = Object.keys(recap1.att)\n    .concat(Object.keys(recap2.att))\n    .sort((a, b) => a.localeCompare(b));\n  const mergedRecap = { att: {} };\n  keys.forEach((key) => {\n    const actions = Object.keys(recap1.att?.[key] || {})\n      .concat(Object.keys(recap2.att?.[key] || {}))\n      .sort((a, b) => a.localeCompare(b));\n    actions.forEach((action) => {\n      mergedRecap.att[key] = {\n        ...mergedRecap.att[key],\n        [action]: recap1.att[key]?.[action] || recap2.att[key]?.[action],\n      };\n    });\n  });\n  return mergedRecap;\n}\n\nexport function formatStatementFromRecap(statement = \"\", recap: RecapType) {\n  isValidRecap(recap);\n  const base = \"I further authorize the stated URI to perform the following actions on my behalf: \";\n\n  if (statement.includes(base)) return statement;\n\n  const statementForRecap: string[] = [];\n  let currentCounter = 0;\n  Object.keys(recap.att).forEach((resource) => {\n    const actions = Object.keys(recap.att[resource]).map((ability: any) => {\n      return {\n        ability: ability.split(\"/\")[0],\n        action: ability.split(\"/\")[1],\n      };\n    });\n    //\n    actions.sort((a, b) => a.action.localeCompare(b.action));\n    const uniqueAbilities = {};\n    actions.forEach((action: any) => {\n      if (!uniqueAbilities[action.ability]) {\n        uniqueAbilities[action.ability] = [];\n      }\n      uniqueAbilities[action.ability].push(action.action);\n    });\n    const abilities = Object.keys(uniqueAbilities).map((ability) => {\n      currentCounter++;\n      return `(${currentCounter}) '${ability}': '${uniqueAbilities[ability].join(\n        \"', '\",\n      )}' for '${resource}'.`;\n    });\n    statementForRecap.push(abilities.join(\", \").replace(\".,\", \".\"));\n  });\n\n  const recapStatemet = statementForRecap.join(\" \");\n  const recapStatement = `${base}${recapStatemet}`;\n  // add a space if there is a statement\n  return `${statement ? statement + \" \" : \"\"}${recapStatement}`;\n}\n\nexport function getMethodsFromRecap(recap: string) {\n  const decoded = decodeRecap(recap);\n  isValidRecap(decoded);\n  // methods are only available for eip155 as per the current implementation\n  const resource = decoded.att?.eip155;\n  if (!resource) return [];\n  return Object.keys(resource).map((ability: any) => ability.split(\"/\")[1]);\n}\n\nexport function getChainsFromRecap(recap: string) {\n  const decoded = decodeRecap(recap);\n  isValidRecap(decoded);\n  const chains: string[] = [];\n\n  Object.values(decoded.att).forEach((resource: any) => {\n    Object.values(resource).forEach((ability: any) => {\n      if (ability?.[0]?.chains) {\n        chains.push(ability[0].chains);\n      }\n    });\n  });\n  return [...new Set(chains.flat())];\n}\n\nexport function buildRecapStatement(statement: string, recap: unknown) {\n  if (!recap) return statement;\n  const decoded = decodeRecap(recap);\n  isValidRecap(decoded);\n  return formatStatementFromRecap(statement, decoded);\n}\n\nexport function getRecapFromResources(resources?: string[]) {\n  if (!resources) return;\n  // per spec, recap is always the last resource\n  const resource = resources?.[resources.length - 1];\n  return isRecap(resource) ? resource : undefined;\n}\n","import { ChaCha20Poly1305 } from \"@stablelib/chacha20poly1305\";\nimport { HKDF } from \"@stablelib/hkdf\";\nimport { randomBytes } from \"@stablelib/random\";\nimport { hash, SHA256 } from \"@stablelib/sha256\";\nimport * as x25519 from \"@stablelib/x25519\";\nimport { CryptoTypes } from \"@walletconnect/types\";\nimport { concat, fromString, toString } from \"uint8arrays\";\nimport { ec as EC } from \"elliptic\";\nimport { decodeJWT } from \"@walletconnect/relay-auth\";\n\nexport const BASE10 = \"base10\";\nexport const BASE16 = \"base16\";\nexport const BASE64 = \"base64pad\";\nexport const BASE64URL = \"base64url\";\nexport const UTF8 = \"utf8\";\n\nexport const TYPE_0 = 0;\nexport const TYPE_1 = 1;\nexport const TYPE_2 = 2;\n\nexport type P256KeyDataType = {\n  crv: \"P-256\";\n  ext: true;\n  key_ops: [\"verify\"];\n  kty: string;\n  x: string;\n  y: string;\n};\n\nconst ZERO_INDEX = 0;\nconst TYPE_LENGTH = 1;\nconst IV_LENGTH = 12;\nconst KEY_LENGTH = 32;\n\nexport function generateKeyPair(): CryptoTypes.KeyPair {\n  const keyPair = x25519.generateKeyPair();\n  return {\n    privateKey: toString(keyPair.secretKey, BASE16),\n    publicKey: toString(keyPair.publicKey, BASE16),\n  };\n}\n\nexport function generateRandomBytes32(): string {\n  const random = randomBytes(KEY_LENGTH);\n  return toString(random, BASE16);\n}\n\nexport function deriveSymKey(privateKeyA: string, publicKeyB: string): string {\n  const sharedKey = x25519.sharedKey(\n    fromString(privateKeyA, BASE16),\n    fromString(publicKeyB, BASE16),\n    true,\n  );\n  const hkdf = new HKDF(SHA256, sharedKey);\n  const symKey = hkdf.expand(KEY_LENGTH);\n  return toString(symKey, BASE16);\n}\n\nexport function hashKey(key: string): string {\n  const result = hash(fromString(key, BASE16));\n  return toString(result, BASE16);\n}\n\nexport function hashMessage(message: string): string {\n  const result = hash(fromString(message, UTF8));\n  return toString(result, BASE16);\n}\n\nexport function encodeTypeByte(type: number): Uint8Array {\n  return fromString(`${type}`, BASE10);\n}\n\nexport function decodeTypeByte(byte: Uint8Array): number {\n  return Number(toString(byte, BASE10));\n}\n\nexport function encrypt(params: CryptoTypes.EncryptParams): string {\n  const type = encodeTypeByte(typeof params.type !== \"undefined\" ? params.type : TYPE_0);\n  if (decodeTypeByte(type) === TYPE_1 && typeof params.senderPublicKey === \"undefined\") {\n    throw new Error(\"Missing sender public key for type 1 envelope\");\n  }\n  const senderPublicKey =\n    typeof params.senderPublicKey !== \"undefined\"\n      ? fromString(params.senderPublicKey, BASE16)\n      : undefined;\n\n  const iv =\n    typeof params.iv !== \"undefined\" ? fromString(params.iv, BASE16) : randomBytes(IV_LENGTH);\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const sealed = box.seal(iv, fromString(params.message, UTF8));\n  return serialize({ type, sealed, iv, senderPublicKey, encoding: params.encoding });\n}\n\nexport function encodeTypeTwoEnvelope(\n  message: string,\n  encoding?: CryptoTypes.EncodingType,\n): string {\n  const type = encodeTypeByte(TYPE_2);\n  // iv is not used in type 2 envelopes\n  const iv = randomBytes(IV_LENGTH);\n  const sealed = fromString(message, UTF8);\n  return serialize({ type, sealed, iv, encoding });\n}\n\nexport function decrypt(params: CryptoTypes.DecryptParams): string {\n  const box = new ChaCha20Poly1305(fromString(params.symKey, BASE16));\n  const { sealed, iv } = deserialize({ encoded: params.encoded, encoding: params?.encoding });\n  const message = box.open(iv, sealed);\n  if (message === null) throw new Error(\"Failed to decrypt\");\n  return toString(message, UTF8);\n}\n\nexport function decodeTypeTwoEnvelope(\n  encoded: string,\n  encoding?: CryptoTypes.EncodingType,\n): string {\n  const { sealed } = deserialize({ encoded, encoding });\n  return toString(sealed, UTF8);\n}\n\nexport function serialize(params: CryptoTypes.EncodingParams): string {\n  const { encoding = BASE64 } = params;\n\n  if (decodeTypeByte(params.type) === TYPE_2) {\n    return toString(concat([params.type, params.sealed]), encoding);\n  }\n  if (decodeTypeByte(params.type) === TYPE_1) {\n    if (typeof params.senderPublicKey === \"undefined\") {\n      throw new Error(\"Missing sender public key for type 1 envelope\");\n    }\n    return toString(\n      concat([params.type, params.senderPublicKey, params.iv, params.sealed]),\n      encoding,\n    );\n  }\n  // default to type 0 envelope\n  return toString(concat([params.type, params.iv, params.sealed]), encoding);\n}\n\nexport function deserialize(params: CryptoTypes.DecodingParams): CryptoTypes.EncodingParams {\n  const { encoded, encoding = BASE64 } = params;\n  const bytes = fromString(encoded, encoding);\n  const type = bytes.slice(ZERO_INDEX, TYPE_LENGTH);\n  const slice1 = TYPE_LENGTH;\n  if (decodeTypeByte(type) === TYPE_1) {\n    const slice2 = slice1 + KEY_LENGTH;\n    const slice3 = slice2 + IV_LENGTH;\n    const senderPublicKey = bytes.slice(slice1, slice2);\n    const iv = bytes.slice(slice2, slice3);\n    const sealed = bytes.slice(slice3);\n    return { type, sealed, iv, senderPublicKey };\n  }\n  if (decodeTypeByte(type) === TYPE_2) {\n    const sealed = bytes.slice(slice1);\n    // iv is not used in type 2 envelopes\n    const iv = randomBytes(IV_LENGTH);\n    return { type, sealed, iv };\n  }\n  // default to type 0 envelope\n  const slice2 = slice1 + IV_LENGTH;\n  const iv = bytes.slice(slice1, slice2);\n  const sealed = bytes.slice(slice2);\n  return { type, sealed, iv };\n}\n\nexport function validateDecoding(\n  encoded: string,\n  opts?: CryptoTypes.DecodeOptions,\n): CryptoTypes.EncodingValidation {\n  const deserialized = deserialize({ encoded, encoding: opts?.encoding });\n  return validateEncoding({\n    type: decodeTypeByte(deserialized.type),\n    senderPublicKey:\n      typeof deserialized.senderPublicKey !== \"undefined\"\n        ? toString(deserialized.senderPublicKey, BASE16)\n        : undefined,\n    receiverPublicKey: opts?.receiverPublicKey,\n  });\n}\n\nexport function validateEncoding(opts?: CryptoTypes.EncodeOptions): CryptoTypes.EncodingValidation {\n  const type = opts?.type || TYPE_0;\n  if (type === TYPE_1) {\n    if (typeof opts?.senderPublicKey === \"undefined\") {\n      throw new Error(\"missing sender public key\");\n    }\n    if (typeof opts?.receiverPublicKey === \"undefined\") {\n      throw new Error(\"missing receiver public key\");\n    }\n  }\n  return {\n    type,\n    senderPublicKey: opts?.senderPublicKey,\n    receiverPublicKey: opts?.receiverPublicKey,\n  };\n}\n\nexport function isTypeOneEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return (\n    result.type === TYPE_1 &&\n    typeof result.senderPublicKey === \"string\" &&\n    typeof result.receiverPublicKey === \"string\"\n  );\n}\n\nexport function isTypeTwoEnvelope(\n  result: CryptoTypes.EncodingValidation,\n): result is CryptoTypes.TypeOneParams {\n  return result.type === TYPE_2;\n}\nexport function getCryptoKeyFromKeyData(keyData: P256KeyDataType): EC.KeyPair {\n  const ec = new EC(\"p256\");\n  const key = ec.keyFromPublic(\n    {\n      x: Buffer.from(keyData.x, \"base64\").toString(\"hex\"),\n      y: Buffer.from(keyData.y, \"base64\").toString(\"hex\"),\n    },\n    \"hex\",\n  );\n  return key;\n}\n\nfunction base64UrlToBase64(base64Url: string) {\n  let base64 = base64Url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const padding = base64.length % 4;\n  if (padding > 0) {\n    base64 += \"=\".repeat(4 - padding);\n  }\n  return base64;\n}\n\nfunction base64UrlDecode(base64Url: string) {\n  return Buffer.from(base64UrlToBase64(base64Url), \"base64\");\n}\n\nexport function verifyP256Jwt<T>(token: string, keyData: P256KeyDataType) {\n  const [headerBase64Url, payloadBase64Url, signatureBase64Url] = token.split(\".\");\n\n  // Decode the signature\n  const signatureBuffer = base64UrlDecode(signatureBase64Url);\n\n  // Check if signature length is correct (64 bytes for P-256)\n  if (signatureBuffer.length !== 64) {\n    throw new Error(\"Invalid signature length\");\n  }\n\n  // Extract r and s from the signature\n  const r = signatureBuffer.slice(0, 32).toString(\"hex\");\n  const s = signatureBuffer.slice(32, 64).toString(\"hex\");\n\n  // Create the signing input\n  const signingInput = `${headerBase64Url}.${payloadBase64Url}`;\n\n  const sha256 = new SHA256();\n  const buffer = sha256.update(Buffer.from(signingInput)).digest();\n\n  const key = getCryptoKeyFromKeyData(keyData);\n\n  // Convert the hash to hex format\n  const hashHex = Buffer.from(buffer).toString(\"hex\");\n\n  // Verify the signature\n  const isValid = key.verify(hashHex, { r, s });\n\n  if (!isValid) {\n    throw new Error(\"Invalid signature\");\n  }\n  const data = decodeJWT(token) as unknown as { payload: T };\n  return data.payload;\n}\n","import { RELAY_JSONRPC } from \"@walletconnect/relay-api\";\nimport { RelayerTypes } from \"@walletconnect/types\";\n\nexport const RELAYER_DEFAULT_PROTOCOL = \"irn\";\n\nexport function getRelayProtocolName(\n  opts?: RelayerTypes.RequestOptions,\n): RelayerTypes.ProtocolOptions {\n  return opts?.relay || { protocol: RELAYER_DEFAULT_PROTOCOL };\n}\n\nexport function getRelayProtocolApi(protocol: string) {\n  const jsonrpc = RELAY_JSONRPC[protocol];\n  if (typeof jsonrpc === \"undefined\") {\n    throw new Error(`Relay Protocol not supported: ${protocol}`);\n  }\n  return jsonrpc;\n}\n","import * as qs from \"query-string\";\nimport { EngineTypes, RelayerTypes } from \"@walletconnect/types\";\nimport { fromBase64 } from \"./misc\";\n\n// -- uri -------------------------------------------------- //\n\nexport function parseRelayParams(params: any, delimiter = \"-\"): RelayerTypes.ProtocolOptions {\n  const relay: any = {};\n  const prefix = \"relay\" + delimiter;\n  Object.keys(params).forEach((key) => {\n    if (key.startsWith(prefix)) {\n      const name = key.replace(prefix, \"\");\n      const value = params[key];\n      relay[name] = value;\n    }\n  });\n  return relay;\n}\n\nexport function parseUri(str: string): EngineTypes.UriParameters {\n  if (!str.includes(\"wc:\")) {\n    const parsed = fromBase64(str);\n    if (parsed?.includes(\"wc:\")) {\n      str = parsed;\n    }\n  }\n\n  // remove android schema prefix\n  str = str.includes(\"wc://\") ? str.replace(\"wc://\", \"\") : str;\n  // remove ios schema prefix\n  str = str.includes(\"wc:\") ? str.replace(\"wc:\", \"\") : str;\n  const pathStart: number = str.indexOf(\":\");\n  const pathEnd: number | undefined = str.indexOf(\"?\") !== -1 ? str.indexOf(\"?\") : undefined;\n  const protocol: string = str.substring(0, pathStart);\n  const path: string = str.substring(pathStart + 1, pathEnd);\n  const requiredValues = path.split(\"@\");\n  const queryString: string = typeof pathEnd !== \"undefined\" ? str.substring(pathEnd) : \"\";\n  const queryParams = qs.parse(queryString);\n  const methods =\n    typeof queryParams.methods === \"string\" ? queryParams.methods.split(\",\") : undefined;\n  const result = {\n    protocol,\n    topic: parseTopic(requiredValues[0]),\n    version: parseInt(requiredValues[1], 10),\n    symKey: queryParams.symKey as string,\n    relay: parseRelayParams(queryParams),\n    methods,\n    expiryTimestamp: queryParams.expiryTimestamp\n      ? parseInt(queryParams.expiryTimestamp as string, 10)\n      : undefined,\n  };\n  return result;\n}\n\nexport function parseTopic(topic: string): string {\n  return topic.startsWith(\"//\") ? topic.substring(2) : topic;\n}\n\nexport function formatRelayParams(relay: RelayerTypes.ProtocolOptions, delimiter = \"-\") {\n  const prefix = \"relay\";\n  const params: any = {};\n  Object.keys(relay).forEach((key) => {\n    const k = prefix + delimiter + key;\n    if (relay[key]) {\n      params[k] = relay[key];\n    }\n  });\n  return params;\n}\n\nexport function formatUri(params: EngineTypes.UriParameters): string {\n  return (\n    `${params.protocol}:${params.topic}@${params.version}?` +\n    qs.stringify({\n      symKey: params.symKey,\n      ...formatRelayParams(params.relay),\n      expiryTimestamp: params.expiryTimestamp,\n      ...(params.methods ? { methods: params.methods.join(\",\") } : {}),\n    })\n  );\n}\n\nexport function getLinkModeURL(\n  universalLink: string,\n  topic: string,\n  encodedEnvelope: string,\n): string {\n  return `${universalLink}?wc_ev=${encodedEnvelope}&topic=${topic}`;\n}\n","import { ProposalTypes, SessionTypes } from \"@walletconnect/types\";\nimport { mergeArrays } from \"./misc\";\nimport { isConformingNamespaces, isValidNamespaces, isValidObject } from \"./validators\";\n\nexport function getAccountsChains(accounts: SessionTypes.Namespace[\"accounts\"]) {\n  const chains: string[] = [];\n  accounts.forEach((account) => {\n    const [chain, chainId] = account.split(\":\");\n    chains.push(`${chain}:${chainId}`);\n  });\n\n  return chains;\n}\n\nexport function getNamespacesChains(namespaces: SessionTypes.Namespaces) {\n  const chains: string[] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    chains.push(...getAccountsChains(namespace.accounts));\n  });\n\n  return chains;\n}\n\nexport function getNamespacesMethodsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const methods: SessionTypes.Namespace[\"methods\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) methods.push(...namespace.methods);\n  });\n\n  return methods;\n}\n\nexport function getNamespacesEventsForChainId(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n) {\n  const events: SessionTypes.Namespace[\"events\"] = [];\n  Object.values(namespaces).forEach((namespace) => {\n    const chains = getAccountsChains(namespace.accounts);\n    if (chains.includes(chainId)) events.push(...namespace.events);\n  });\n\n  return events;\n}\n\nexport function getRequiredNamespacesFromNamespaces(\n  namespaces: SessionTypes.Namespaces,\n  caller: string,\n): ProposalTypes.RequiredNamespaces {\n  const validNamespacesError = isValidNamespaces(namespaces, caller);\n  if (validNamespacesError) throw new Error(validNamespacesError.message);\n\n  const required = {};\n  for (const [namespace, values] of Object.entries(namespaces)) {\n    required[namespace] = {\n      methods: values.methods,\n      events: values.events,\n      chains: values.accounts.map((account) => `${account.split(\":\")[0]}:${account.split(\":\")[1]}`),\n    };\n  }\n  return required;\n}\n\nexport type BuildApprovedNamespacesParams = {\n  proposal: ProposalTypes.Struct;\n  supportedNamespaces: Record<\n    string,\n    { chains: string[]; methods: string[]; events: string[]; accounts: string[] }\n  >;\n};\n\n/**\n * util designed for Wallets that builds namespaces structure by provided supported chains, methods, events & accounts.\n * It takes required & optional namespaces provided in the session proposal\n * along with the supported chains/methods/events/accounts by the wallet and returns a structured namespaces object\n * @param {BuildApprovedNamespacesParams} params\n * @returns {SessionTypes.Namespaces}\n */\nexport function buildApprovedNamespaces(\n  params: BuildApprovedNamespacesParams,\n): SessionTypes.Namespaces {\n  const {\n    proposal: { requiredNamespaces, optionalNamespaces = {} },\n    supportedNamespaces,\n  } = params;\n  const normalizedRequired = normalizeNamespaces(requiredNamespaces);\n  const normalizedOptional = normalizeNamespaces(optionalNamespaces);\n\n  // build approved namespaces\n  const namespaces = {};\n  Object.keys(supportedNamespaces).forEach((namespace) => {\n    const supportedChains = supportedNamespaces[namespace].chains;\n    const supportedMethods = supportedNamespaces[namespace].methods;\n    const supportedEvents = supportedNamespaces[namespace].events;\n    const supportedAccounts = supportedNamespaces[namespace].accounts;\n\n    supportedChains.forEach((chain) => {\n      if (!supportedAccounts.some((account) => account.includes(chain))) {\n        throw new Error(`No accounts provided for chain ${chain} in namespace ${namespace}`);\n      }\n    });\n\n    namespaces[namespace] = {\n      chains: supportedChains,\n      methods: supportedMethods,\n      events: supportedEvents,\n      accounts: supportedAccounts,\n    };\n  });\n\n  // verify all required namespaces are supported\n  const err = isConformingNamespaces(requiredNamespaces, namespaces, \"approve()\");\n  if (err) throw new Error(err.message);\n\n  const approvedNamespaces = {};\n\n  // if both required & optional namespaces are empty, return all supported namespaces by the wallet\n  if (!Object.keys(requiredNamespaces).length && !Object.keys(optionalNamespaces).length)\n    return namespaces;\n\n  // assign accounts for the required namespaces\n  Object.keys(normalizedRequired).forEach((requiredNamespace) => {\n    const chains = supportedNamespaces[requiredNamespace].chains.filter((chain) =>\n      normalizedRequired[requiredNamespace]?.chains?.includes(chain),\n    );\n    const methods = supportedNamespaces[requiredNamespace].methods.filter((method) =>\n      normalizedRequired[requiredNamespace]?.methods?.includes(method),\n    );\n    const events = supportedNamespaces[requiredNamespace].events.filter((event) =>\n      normalizedRequired[requiredNamespace]?.events?.includes(event),\n    );\n\n    const accounts = chains\n      .map((chain: string) =>\n        supportedNamespaces[requiredNamespace].accounts.filter((account: string) =>\n          account.includes(`${chain}:`),\n        ),\n      )\n      .flat();\n\n    approvedNamespaces[requiredNamespace] = {\n      chains,\n      methods,\n      events,\n      accounts,\n    };\n  });\n\n  // add optional namespaces\n  Object.keys(normalizedOptional).forEach((optionalNamespace) => {\n    if (!supportedNamespaces[optionalNamespace]) return;\n\n    const chainsToAdd = normalizedOptional[optionalNamespace]?.chains?.filter((chain) =>\n      supportedNamespaces[optionalNamespace].chains.includes(chain),\n    );\n    const methodsToAdd = supportedNamespaces[optionalNamespace].methods.filter((method) =>\n      normalizedOptional[optionalNamespace]?.methods?.includes(method),\n    );\n    const eventsToAdd = supportedNamespaces[optionalNamespace].events.filter((event) =>\n      normalizedOptional[optionalNamespace]?.events?.includes(event),\n    );\n\n    const accountsToAdd = chainsToAdd\n      ?.map((chain: string) =>\n        supportedNamespaces[optionalNamespace].accounts.filter((account: string) =>\n          account.includes(`${chain}:`),\n        ),\n      )\n      .flat();\n\n    approvedNamespaces[optionalNamespace] = {\n      chains: mergeArrays(approvedNamespaces[optionalNamespace]?.chains, chainsToAdd),\n      methods: mergeArrays(approvedNamespaces[optionalNamespace]?.methods, methodsToAdd),\n      events: mergeArrays(approvedNamespaces[optionalNamespace]?.events, eventsToAdd),\n      accounts: mergeArrays(approvedNamespaces[optionalNamespace]?.accounts, accountsToAdd),\n    };\n  });\n\n  return approvedNamespaces;\n}\n\nexport function isCaipNamespace(namespace: string): boolean {\n  return namespace.includes(\":\");\n}\n\nexport function parseNamespaceKey(namespace: string) {\n  return isCaipNamespace(namespace) ? namespace.split(\":\")[0] : namespace;\n}\n\n/**\n * Converts\n * ```\n * {\n *  \"eip155:1\": {...},\n *  \"eip155:2\": {...},\n * }\n * ```\n * into\n * ```\n * {\n *  \"eip155\": {\n *      chains: [\"eip155:1\", \"eip155:2\"],\n *      ...\n *    }\n * }\n *```\n */\nexport function normalizeNamespaces(\n  namespaces: ProposalTypes.RequiredNamespaces,\n): ProposalTypes.RequiredNamespaces {\n  const normalizedNamespaces = {} as ProposalTypes.RequiredNamespaces;\n  if (!isValidObject(namespaces)) return normalizedNamespaces;\n  for (const [key, values] of Object.entries(namespaces)) {\n    const chains = isCaipNamespace(key) ? [key] : values.chains;\n    const methods = values.methods || [];\n    const events = values.events || [];\n    const normalizedKey = parseNamespaceKey(key);\n    normalizedNamespaces[normalizedKey] = {\n      ...normalizedNamespaces[normalizedKey],\n      chains: mergeArrays(chains, normalizedNamespaces[normalizedKey]?.chains),\n      methods: mergeArrays(methods, normalizedNamespaces[normalizedKey]?.methods),\n      events: mergeArrays(events, normalizedNamespaces[normalizedKey]?.events),\n    };\n  }\n  return normalizedNamespaces;\n}\n\nexport function getNamespacesFromAccounts(accounts: string[]) {\n  const namespaces = {};\n  accounts?.forEach((account) => {\n    const [namespace, chainId] = account.split(\":\");\n    if (!namespaces[namespace]) {\n      namespaces[namespace] = {\n        accounts: [],\n        chains: [],\n        events: [],\n      };\n    }\n    namespaces[namespace].accounts.push(account);\n    namespaces[namespace].chains.push(`${namespace}:${chainId}`);\n  });\n\n  return namespaces;\n}\n\nexport function buildNamespacesFromAuth(methods: string[], accounts: string[]) {\n  accounts = accounts.map((account) => account.replace(\"did:pkh:\", \"\"));\n\n  const namespaces = getNamespacesFromAccounts(accounts);\n\n  for (const [_, values] of Object.entries(namespaces) as [string, SessionTypes.Namespace][]) {\n    if (!values.methods) {\n      values.methods = methods;\n    } else {\n      values.methods = mergeArrays(values.methods, methods);\n    }\n    values.events = [\"chainChanged\", \"accountsChanged\"];\n  }\n  return namespaces;\n}\n","/**\n * Types\n */\nexport type SdkErrorKey = keyof typeof SDK_ERRORS;\nexport type InternalErrorKey = keyof typeof INTERNAL_ERRORS;\n\n/**\n * Constants\n */\nexport const SDK_ERRORS = {\n  /* ----- INVALID (1xxx) ----- */\n  INVALID_METHOD: {\n    message: \"Invalid method.\",\n    code: 1001,\n  },\n  INVALID_EVENT: {\n    message: \"Invalid event.\",\n    code: 1002,\n  },\n  INVALID_UPDATE_REQUEST: {\n    message: \"Invalid update request.\",\n    code: 1003,\n  },\n  INVALID_EXTEND_REQUEST: {\n    message: \"Invalid extend request.\",\n    code: 1004,\n  },\n  INVALID_SESSION_SETTLE_REQUEST: {\n    message: \"Invalid session settle request.\",\n    code: 1005,\n  },\n  /* ----- UNAUTHORIZED (3xxx) ----- */\n  UNAUTHORIZED_METHOD: {\n    message: \"Unauthorized method.\",\n    code: 3001,\n  },\n  UNAUTHORIZED_EVENT: {\n    message: \"Unauthorized event.\",\n    code: 3002,\n  },\n  UNAUTHORIZED_UPDATE_REQUEST: {\n    message: \"Unauthorized update request.\",\n    code: 3003,\n  },\n  UNAUTHORIZED_EXTEND_REQUEST: {\n    message: \"Unauthorized extend request.\",\n    code: 3004,\n  },\n  /* ----- REJECTED (5xxx) ----- */\n  USER_REJECTED: {\n    message: \"User rejected.\",\n    code: 5000,\n  },\n  USER_REJECTED_CHAINS: {\n    message: \"User rejected chains.\",\n    code: 5001,\n  },\n  USER_REJECTED_METHODS: {\n    message: \"User rejected methods.\",\n    code: 5002,\n  },\n  USER_REJECTED_EVENTS: {\n    message: \"User rejected events.\",\n    code: 5003,\n  },\n  UNSUPPORTED_CHAINS: {\n    message: \"Unsupported chains.\",\n    code: 5100,\n  },\n  UNSUPPORTED_METHODS: {\n    message: \"Unsupported methods.\",\n    code: 5101,\n  },\n  UNSUPPORTED_EVENTS: {\n    message: \"Unsupported events.\",\n    code: 5102,\n  },\n  UNSUPPORTED_ACCOUNTS: {\n    message: \"Unsupported accounts.\",\n    code: 5103,\n  },\n  UNSUPPORTED_NAMESPACE_KEY: {\n    message: \"Unsupported namespace key.\",\n    code: 5104,\n  },\n  /* ----- REASON (6xxx) ----- */\n  USER_DISCONNECTED: {\n    message: \"User disconnected.\",\n    code: 6000,\n  },\n  /* ----- FAILURE (7xxx) ----- */\n  SESSION_SETTLEMENT_FAILED: {\n    message: \"Session settlement failed.\",\n    code: 7000,\n  },\n  /* ----- PAIRING (10xxx) ----- */\n  WC_METHOD_UNSUPPORTED: {\n    message: \"Unsupported wc_ method.\",\n    code: 10001,\n  },\n};\n\nexport const INTERNAL_ERRORS = {\n  NOT_INITIALIZED: {\n    message: \"Not initialized.\",\n    code: 1,\n  },\n  NO_MATCHING_KEY: {\n    message: \"No matching key.\",\n    code: 2,\n  },\n  RESTORE_WILL_OVERRIDE: {\n    message: \"Restore will override.\",\n    code: 3,\n  },\n  RESUBSCRIBED: {\n    message: \"Resubscribed.\",\n    code: 4,\n  },\n  MISSING_OR_INVALID: {\n    message: \"Missing or invalid.\",\n    code: 5,\n  },\n  EXPIRED: {\n    message: \"Expired.\",\n    code: 6,\n  },\n  UNKNOWN_TYPE: {\n    message: \"Unknown type.\",\n    code: 7,\n  },\n  MISMATCHED_TOPIC: {\n    message: \"Mismatched topic.\",\n    code: 8,\n  },\n  NON_CONFORMING_NAMESPACES: {\n    message: \"Non conforming namespaces.\",\n    code: 9,\n  },\n};\n\n/**\n * Utilities\n */\nexport function getInternalError(key: InternalErrorKey, context?: string | number) {\n  const { message, code } = INTERNAL_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n\nexport function getSdkError(key: SdkErrorKey, context?: string | number) {\n  const { message, code } = SDK_ERRORS[key];\n  return {\n    message: context ? `${message} ${context}` : message,\n    code,\n  };\n}\n","import { SessionTypes, ProposalTypes, RelayerTypes, EngineTypes } from \"@walletconnect/types\";\nimport { ErrorResponse } from \"@walletconnect/jsonrpc-types\";\nimport {\n  getNamespacesChains,\n  getNamespacesMethodsForChainId,\n  getNamespacesEventsForChainId,\n  getAccountsChains,\n} from \"./namespaces\";\nimport { getSdkError, getInternalError } from \"./errors\";\nimport { fromBase64, hasOverlap } from \"./misc\";\nimport { getChainsFromNamespace } from \"./caip\";\n\nexport type ErrorObject = { message: string; code: number } | null;\n\n// -- types validation ----------------------------------------------------- //\n\nexport function isValidArray(arr: any, itemCondition?: (item: any) => boolean) {\n  if (Array.isArray(arr)) {\n    if (typeof itemCondition !== \"undefined\" && arr.length) {\n      return arr.every(itemCondition);\n    } else {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function isValidObject(obj: any) {\n  return Object.getPrototypeOf(obj) === Object.prototype && Object.keys(obj).length;\n}\n\nexport function isUndefined(input: any): input is undefined {\n  return typeof input === \"undefined\";\n}\n\nexport function isValidString(input: any, optional: boolean): input is string {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"string\" && Boolean(input.trim().length);\n}\n\nexport function isValidNumber(input: any, optional: boolean) {\n  if (optional && isUndefined(input)) return true;\n\n  return typeof input === \"number\" && !isNaN(input);\n}\n\n// -- protocol validation -------------------------------------------------- //\n\nexport function isSessionCompatible(session: SessionTypes.Struct, params: EngineTypes.FindParams) {\n  const { requiredNamespaces } = params;\n  const sessionKeys = Object.keys(session.namespaces);\n  const paramsKeys = Object.keys(requiredNamespaces);\n  let compatible = true;\n\n  if (!hasOverlap(paramsKeys, sessionKeys)) return false;\n\n  sessionKeys.forEach((key) => {\n    const { accounts, methods, events } = session.namespaces[key];\n    const chains = getAccountsChains(accounts);\n    const requiredNamespace = requiredNamespaces[key];\n    if (\n      !hasOverlap(getChainsFromNamespace(key, requiredNamespace), chains) ||\n      !hasOverlap(requiredNamespace.methods, methods) ||\n      !hasOverlap(requiredNamespace.events, events)\n    ) {\n      compatible = false;\n    }\n  });\n\n  return compatible;\n}\n\nexport function isValidChainId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    return split.length === 2;\n  }\n  return false;\n}\n\nexport function isValidAccountId(value: any) {\n  if (isValidString(value, false) && value.includes(\":\")) {\n    const split = value.split(\":\");\n    if (split.length === 3) {\n      const chainId = split[0] + \":\" + split[1];\n      return !!split[2] && isValidChainId(chainId);\n    }\n  }\n  return false;\n}\n\nexport function isValidUrl(value: any) {\n  function validateUrl(blob: string) {\n    try {\n      const url = new URL(blob);\n      return typeof url !== \"undefined\";\n    } catch (e) {\n      return false;\n    }\n  }\n  try {\n    if (isValidString(value, false)) {\n      const isValid = validateUrl(value);\n      if (isValid) return true;\n\n      const decoded = fromBase64(value);\n      return validateUrl(decoded);\n    }\n  } catch (e) {}\n  return false;\n}\n\nexport function isProposalStruct(input: any): input is ProposalTypes.Struct {\n  return input?.proposer?.publicKey;\n}\n\nexport function isSessionStruct(input: any): input is SessionTypes.Struct {\n  return input?.topic;\n}\n\nexport function isValidController(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (!isValidString(input?.publicKey, false)) {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method} controller public key should be a string`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceMethodsOrEvents(input: any): input is string {\n  let valid = true;\n  if (isValidArray(input)) {\n    if (input.length) {\n      valid = input.every((item: any) => isValidString(item, false));\n    }\n  } else {\n    valid = false;\n  }\n\n  return valid;\n}\n\nexport function isValidChains(key: string, chains: any, context: string) {\n  let error: ErrorObject = null;\n\n  if (isValidArray(chains) && chains.length) {\n    chains.forEach((chain: any) => {\n      if (error) return;\n      if (!isValidChainId(chain)) {\n        error = getSdkError(\n          \"UNSUPPORTED_CHAINS\",\n          `${context}, chain ${chain} should be a string and conform to \"namespace:chainId\" format`,\n        );\n      }\n    });\n  } else if (!isValidChainId(key)) {\n    error = getSdkError(\n      \"UNSUPPORTED_CHAINS\",\n      `${context}, chains must be defined as \"namespace:chainId\" e.g. \"eip155:1\": {...} in the namespace key OR as an array of CAIP-2 chainIds e.g. eip155: { chains: [\"eip155:1\", \"eip155:5\"] }`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceChains(namespaces: any, method: string, type: string) {\n  let error: ErrorObject = null;\n  Object.entries(namespaces).forEach(([key, namespace]: [string, any]) => {\n    if (error) return;\n    const validChainsError = isValidChains(\n      key,\n      getChainsFromNamespace(key, namespace),\n      `${method} ${type}`,\n    );\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidAccounts(accounts: any, context: string) {\n  let error: ErrorObject = null;\n  if (isValidArray(accounts)) {\n    accounts.forEach((account: any) => {\n      if (error) return;\n      if (!isValidAccountId(account)) {\n        error = getSdkError(\n          \"UNSUPPORTED_ACCOUNTS\",\n          `${context}, account ${account} should be a string and conform to \"namespace:chainId:address\" format`,\n        );\n      }\n    });\n  } else {\n    error = getSdkError(\n      \"UNSUPPORTED_ACCOUNTS\",\n      `${context}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceAccounts(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validAccountsError = isValidAccounts(namespace?.accounts, `${method} namespace`);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidActions(namespace: any, context: string) {\n  let error: ErrorObject = null;\n  if (!isValidNamespaceMethodsOrEvents(namespace?.methods)) {\n    error = getSdkError(\n      \"UNSUPPORTED_METHODS\",\n      `${context}, methods should be an array of strings or empty array for no methods`,\n    );\n  } else if (!isValidNamespaceMethodsOrEvents(namespace?.events)) {\n    error = getSdkError(\n      \"UNSUPPORTED_EVENTS\",\n      `${context}, events should be an array of strings or empty array for no events`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaceActions(input: any, method: string) {\n  let error: ErrorObject = null;\n  Object.values(input).forEach((namespace: any) => {\n    if (error) return;\n    const validActionsError = isValidActions(namespace, `${method}, namespace`);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n  });\n\n  return error;\n}\n\nexport function isValidRequiredNamespaces(input: any, method: string, type: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validChainsError = isValidNamespaceChains(input, method, type);\n    if (validChainsError) {\n      error = validChainsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, ${type} should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidNamespaces(input: any, method: string) {\n  let error: ErrorObject = null;\n  if (input && isValidObject(input)) {\n    const validActionsError = isValidNamespaceActions(input, method);\n    if (validActionsError) {\n      error = validActionsError;\n    }\n    const validAccountsError = isValidNamespaceAccounts(input, method);\n    if (validAccountsError) {\n      error = validAccountsError;\n    }\n  } else {\n    error = getInternalError(\n      \"MISSING_OR_INVALID\",\n      `${method}, namespaces should be an object with data`,\n    );\n  }\n\n  return error;\n}\n\nexport function isValidRelay(input: any): input is RelayerTypes.ProtocolOptions {\n  return isValidString(input.protocol, true);\n}\n\nexport function isValidRelays(\n  input: any,\n  optional: boolean,\n): input is RelayerTypes.ProtocolOptions[] {\n  let valid = false;\n\n  if (optional && !input) valid = true;\n  else if (input && isValidArray(input) && input.length) {\n    input.forEach((relay: RelayerTypes.ProtocolOptions) => {\n      valid = isValidRelay(relay);\n    });\n  }\n\n  return valid;\n}\n\nexport function isValidId(input: any) {\n  return typeof input === \"number\";\n}\n\nexport function isValidParams(input: any) {\n  return typeof input !== \"undefined\" && typeof input !== null;\n}\n\nexport function isValidErrorReason(input: any): input is ErrorResponse {\n  if (!input) return false;\n  if (typeof input !== \"object\") return false;\n  if (!input.code || !isValidNumber(input.code, false)) return false;\n  if (!input.message || !isValidString(input.message, false)) return false;\n\n  return true;\n}\n\nexport function isValidRequest(request: any) {\n  if (isUndefined(request)) return false;\n  if (!isValidString(request.method, false)) return false;\n  return true;\n}\n\nexport function isValidResponse(response: any) {\n  if (isUndefined(response)) return false;\n  if (isUndefined(response.result) && isUndefined(response.error)) return false;\n  if (!isValidNumber(response.id, false)) return false;\n  if (!isValidString(response.jsonrpc, false)) return false;\n  return true;\n}\n\nexport function isValidEvent(event: any) {\n  if (isUndefined(event)) return false;\n  if (!isValidString(event.name, false)) return false;\n  return true;\n}\n\nexport function isValidNamespacesChainId(namespaces: SessionTypes.Namespaces, chainId: string) {\n  if (!isValidChainId(chainId)) return false;\n  const chains = getNamespacesChains(namespaces);\n  if (!chains.includes(chainId)) return false;\n\n  return true;\n}\n\nexport function isValidNamespacesRequest(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  method: string,\n) {\n  if (!isValidString(method, false)) return false;\n  const methods = getNamespacesMethodsForChainId(namespaces, chainId);\n  return methods.includes(method);\n}\n\nexport function isValidNamespacesEvent(\n  namespaces: SessionTypes.Namespaces,\n  chainId: string,\n  eventName: string,\n) {\n  if (!isValidString(eventName, false)) return false;\n  const events = getNamespacesEventsForChainId(namespaces, chainId);\n  return events.includes(eventName);\n}\n\nexport function isConformingNamespaces(\n  requiredNamespaces: ProposalTypes.RequiredNamespaces,\n  namespaces: SessionTypes.Namespaces,\n  context: string,\n) {\n  let error: ErrorObject = null;\n\n  const parsedRequired = parseNamespaces(requiredNamespaces);\n  const parsedApproved = parseApprovedNamespaces(namespaces);\n  const requiredChains = Object.keys(parsedRequired);\n  const approvedChains = Object.keys(parsedApproved);\n\n  const uniqueRequired = filterDuplicateNamespaces(Object.keys(requiredNamespaces));\n  const uniqueApproved = filterDuplicateNamespaces(Object.keys(namespaces));\n  const missingRequiredNamespaces = uniqueRequired.filter(\n    (namespace) => !uniqueApproved.includes(namespace),\n  );\n\n  if (missingRequiredNamespaces.length) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces keys don't satisfy requiredNamespaces.\n      Required: ${missingRequiredNamespaces.toString()}\n      Received: ${Object.keys(namespaces).toString()}`,\n    );\n  }\n\n  if (!hasOverlap(requiredChains, approvedChains)) {\n    error = getInternalError(\n      \"NON_CONFORMING_NAMESPACES\",\n      `${context} namespaces chains don't satisfy required namespaces.\n      Required: ${requiredChains.toString()}\n      Approved: ${approvedChains.toString()}`,\n    );\n  }\n\n  // validate inline defined chains with approved accounts\n  Object.keys(namespaces).forEach((chain) => {\n    if (!chain.includes(\":\")) return;\n    if (error) return;\n    const chains = getAccountsChains(namespaces[chain].accounts);\n    if (!chains.includes(chain)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces accounts don't satisfy namespace accounts for ${chain}\n        Required: ${chain}\n        Approved: ${chains.toString()}`,\n      );\n    }\n  });\n\n  requiredChains.forEach((chain) => {\n    if (error) return;\n\n    if (!hasOverlap(parsedRequired[chain].methods, parsedApproved[chain].methods)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces methods don't satisfy namespace methods for ${chain}`,\n      );\n    } else if (!hasOverlap(parsedRequired[chain].events, parsedApproved[chain].events)) {\n      error = getInternalError(\n        \"NON_CONFORMING_NAMESPACES\",\n        `${context} namespaces events don't satisfy namespace events for ${chain}`,\n      );\n    }\n  });\n\n  return error;\n}\n\nfunction parseNamespaces(namespaces: ProposalTypes.RequiredNamespaces) {\n  const parsed = {};\n  Object.keys(namespaces).forEach((key) => {\n    // e.g. `eip155:1`\n    const isInlineChainDefinition = key.includes(\":\");\n\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      namespaces[key].chains?.forEach((chain) => {\n        parsed[chain] = {\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nfunction filterDuplicateNamespaces(namespaces: string[]) {\n  return [\n    ...new Set(\n      namespaces.map((namespace) =>\n        namespace.includes(\":\") ? namespace.split(\":\")[0] : namespace,\n      ),\n    ),\n  ];\n}\n\nfunction parseApprovedNamespaces(namespaces: SessionTypes.Namespaces) {\n  const parsed = {};\n  Object.keys(namespaces).forEach((key) => {\n    const isInlineChainDefinition = key.includes(\":\");\n    if (isInlineChainDefinition) {\n      parsed[key] = namespaces[key];\n    } else {\n      const chains = getAccountsChains(namespaces[key].accounts);\n      chains?.forEach((chain) => {\n        parsed[chain] = {\n          accounts: namespaces[key].accounts.filter((account: string) =>\n            account.includes(`${chain}:`),\n          ),\n          methods: namespaces[key].methods,\n          events: namespaces[key].events,\n        };\n      });\n    }\n  });\n  return parsed;\n}\n\nexport function isValidRequestExpiry(expiry: number, boundaries: { min: number; max: number }) {\n  return isValidNumber(expiry, false) && expiry <= boundaries.max && expiry >= boundaries.min;\n}\n","import { getEnvironment, ENV_MAP, isBrowser, isReactNative } from \"./misc\";\n\nexport function isOnline(): Promise<boolean> {\n  const env = getEnvironment();\n  return new Promise((resolve) => {\n    switch (env) {\n      case ENV_MAP.browser:\n        resolve(getBrowserOnlineStatus());\n        break;\n      case ENV_MAP.reactNative:\n        resolve(getReactNativeOnlineStatus());\n        break;\n      case ENV_MAP.node:\n        resolve(getNodeOnlineStatus());\n        break;\n      default:\n        resolve(true);\n    }\n  });\n}\n\nexport function getBrowserOnlineStatus() {\n  return isBrowser() && navigator?.onLine;\n}\n\nexport async function getReactNativeOnlineStatus(): Promise<boolean> {\n  // global.NetInfo is set in react-native-compat\n  if (isReactNative() && typeof global !== \"undefined\" && (global as any)?.NetInfo) {\n    const state = await (global as any)?.NetInfo.fetch();\n    return state?.isConnected;\n  }\n  // fallback to true if global.NetInfo is undefined, meaning an older version of react-native-compat is used\n  return true;\n}\n\nexport function getNodeOnlineStatus() {\n  /**\n   * TODO: need to implement\n   */\n  return true;\n}\n\nexport function subscribeToNetworkChange(callbackHandler: (connected: boolean) => void) {\n  const env = getEnvironment();\n  switch (env) {\n    case ENV_MAP.browser:\n      subscribeToBrowserNetworkChange(callbackHandler);\n      break;\n    case ENV_MAP.reactNative:\n      subscribeToReactNativeNetworkChange(callbackHandler);\n      break;\n    case ENV_MAP.node:\n      // wip: need to implement\n      break;\n    default:\n      break;\n  }\n}\n\nexport function subscribeToBrowserNetworkChange(callbackHandler: (connected: boolean) => void) {\n  if (!isReactNative() && isBrowser()) {\n    window.addEventListener(\"online\", () => callbackHandler(true));\n    window.addEventListener(\"offline\", () => callbackHandler(false));\n  }\n}\n\n// global.NetInfo is set in react-native-compat\nexport function subscribeToReactNativeNetworkChange(callbackHandler: (connected: boolean) => void) {\n  if (isReactNative() && typeof global !== \"undefined\" && (global as any)?.NetInfo) {\n    (global as any)?.NetInfo.addEventListener((state: any) => callbackHandler(state?.isConnected));\n  }\n}\n","const memoryStore = {};\n\nexport abstract class MemoryStore {\n  static get<T = unknown>(key: string) {\n    return memoryStore[key] as T | undefined;\n  }\n\n  static set(key: string, value: unknown) {\n    memoryStore[key] = value;\n  }\n\n  static delete(key: string) {\n    delete memoryStore[key];\n  }\n}\n"],"names":["CAIP_DELIMITER","chain","namespace","reference","params","account","address","array","parser","unique","str","value","accounts","namespaces","keys","key","ns","chains","requiredNamespaces","namespaceProps","v","x","E","P","y","l","getDocument","getNavigator","_a","e","queryString","newQueryParams","queryParams","qs","__spreadValues","getWindowMetadata","protocol","version","env","metadata","getLocation","OS","Version","info","detect","os","sdkVersion","id","relayUrl","auth","projectId","useOnCloseEvent","bundleId","packageName","splitUrl","ua","url","domain","obj","type","context","depth","a","b","arr","map","cb","res","word","c","w","expiry","FIVE_MINUTES","expireErrorMessage","timeout","toMiliseconds","cacheResolve","cacheReject","cacheTimeout","result","promiseResolve","promiseReject","err","promise","resolve","reject","error","topic","target","parsed","ttl","now","fromMiliseconds","event","wcDeepLink","json","deeplink","link","requestId","sessionTopic","payload","startApp","storage","arr1","arr2","param","index","r","input","removePadding","encoded","encodedString","ms","DEFAULT_RPC_URL","reconstructedMessage","cacaoSignature","chainId","baseRpcUrl","message","signature","recoverAddress","hashMessage","parsedChain","parseChainId","eip1271MagicValue","dynamicTypeOffset","dynamicTypeLength","nonPrefixedSignature","nonPrefixedHashedMessage","data","response","generateJsonRpcId","didPrefix","iss","segments","cacao","reconstructed","walletAddress","verifySignature","header","statement","uri","nonce","issuedAt","expirationTime","notBefore","resources","resource","recap","decoded","val","requestPayload","authPayload","methods","requested","supportedChains","getCommonValuesInArrays","requestedRecaps","updatedResources","actions","supportedActions","formattedActions","updatedRecap","__spreadProps","_b","action","abilities","ability","resourceAbilities","limits","limit","recap1","recap2","decoded1","decoded2","merged","mergedRecap","base","statementForRecap","currentCounter","uniqueAbilities","recapStatemet","recapStatement","ZERO_INDEX","TYPE_LENGTH","IV_LENGTH","KEY_LENGTH","keyPair","x25519","toString","random","randomBytes","privateKeyA","publicKeyB","sharedKey","fromString","symKey","HKDF","SHA256","hash","byte","senderPublicKey","iv","sealed","ChaCha20Poly1305","encoding","box","concat","bytes","slice1","slice2","slice3","opts","deserialized","keyData","EC","base64UrlToBase64","base64Url","base64","padding","base64UrlDecode","token","headerBase64Url","payloadBase64Url","signatureBase64Url","signatureBuffer","s","signingInput","buffer","hashHex","decodeJWT","jsonrpc","RELAY_JSONRPC","g","delimiter","relay","prefix","name","fromBase64","pathStart","pathEnd","requiredValues","k","universalLink","encodedEnvelope","events","caller","validNamespacesError","isValidNamespaces","required","values","optionalNamespaces","supportedNamespaces","normalizedRequired","normalizedOptional","supportedMethods","supportedEvents","supportedAccounts","isConformingNamespaces","approvedNamespaces","requiredNamespace","method","optionalNamespace","_c","_d","_e","_f","chainsToAdd","methodsToAdd","eventsToAdd","accountsToAdd","mergeArrays","normalizedNamespaces","isValidObject","normalizedKey","_","code","itemCondition","optional","session","sessionKeys","paramsKeys","compatible","hasOverlap","getAccountsChains","getChainsFromNamespace","split","validateUrl","blob","getInternalError","valid","item","getSdkError","validChainsError","validAccountsError","validActionsError","request","getNamespacesChains","getNamespacesMethodsForChainId","eventName","getNamespacesEventsForChainId","parsedRequired","parseNamespaces","parsedApproved","parseApprovedNamespaces","requiredChains","approvedChains","uniqueRequired","filterDuplicateNamespaces","uniqueApproved","missingRequiredNamespaces","boundaries","getEnvironment","ENV_MAP","isBrowser","isReactNative","state","callbackHandler","memoryStore"],"mappings":"","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11],"debugId":null}},
    {"offset": {"line": 3924, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3930, "column": 0}, "map": {"version":3,"file":"constants.js","sourceRoot":"","sources":["../../src/constants.ts"],"names":[],"mappings":";;;;;;;;;;;;AAAO,MAAM,WAAW,GAAG,aAAa,CAAC;AAClC,MAAM,eAAe,GAAG,iBAAiB,CAAC;AAC1C,MAAM,gBAAgB,GAAG,kBAAkB,CAAC;AAC5C,MAAM,cAAc,GAAG,gBAAgB,CAAC;AACxC,MAAM,cAAc,GAAG,gBAAgB,CAAC;AACxC,MAAM,YAAY,GAAG,cAAc,CAAC;AAEpC,MAAM,oBAAoB,GAAG;IAAC,CAAC,KAAK;IAAE,CAAC,KAAK;IAAE,CAAC,KAAK;IAAE,CAAC,KAAK;IAAE,CAAC,KAAK;CAAC,CAAC;AACtE,MAAM,uBAAuB,GAAG;IAAC,CAAC,KAAK;IAAE,CAAC,KAAK;CAAC,CAAC;AAEjD,MAAM,kBAAkB,GAAG;IAChC,CAAC,WAAW,CAAC,EAAE;QAAE,IAAI,EAAE,CAAC,KAAK;QAAE,OAAO,EAAE,aAAa;IAAA,CAAE;IACvD,CAAC,eAAe,CAAC,EAAE;QAAE,IAAI,EAAE,CAAC,KAAK;QAAE,OAAO,EAAE,iBAAiB;IAAA,CAAE;IAC/D,CAAC,gBAAgB,CAAC,EAAE;QAAE,IAAI,EAAE,CAAC,KAAK;QAAE,OAAO,EAAE,kBAAkB;IAAA,CAAE;IACjE,CAAC,cAAc,CAAC,EAAE;QAAE,IAAI,EAAE,CAAC,KAAK;QAAE,OAAO,EAAE,gBAAgB;IAAA,CAAE;IAC7D,CAAC,cAAc,CAAC,EAAE;QAAE,IAAI,EAAE,CAAC,KAAK;QAAE,OAAO,EAAE,gBAAgB;IAAA,CAAE;IAC7D,CAAC,YAAY,CAAC,EAAE;QAAE,IAAI,EAAE,CAAC,KAAK;QAAE,OAAO,EAAE,cAAc;IAAA,CAAE;CAC1D,CAAC;AAEK,MAAM,aAAa,GAAG,YAAY,CAAC","debugId":null}},
    {"offset": {"line": 3986, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 3992, "column": 0}, "map": {"version":3,"file":"error.js","sourceRoot":"","sources":["../../src/error.ts"],"names":[],"mappings":";;;;;;;;;AACA,OAAO,EACL,uBAAuB,EACvB,oBAAoB,EACpB,kBAAkB,EAClB,aAAa,GACd,MAAM,aAAa,CAAC;;AAGf,SAAU,iBAAiB,CAAC,IAAY;IAC5C,OAAO,IAAI,oLAAI,0BAAuB,CAAC,CAAC,CAAC,IAAI,IAAI,oLAAI,0BAAuB,CAAC,CAAC,CAAC,CAAC;AAClF,CAAC;AAEK,SAAU,mBAAmB,CAAC,IAAY;IAC9C,uLAAO,uBAAoB,CAAC,QAAQ,CAAC,IAAI,CAAC,CAAC;AAC7C,CAAC;AAEK,SAAU,gBAAgB,CAAC,IAAY;IAC3C,OAAO,OAAO,IAAI,KAAK,QAAQ,CAAC;AAClC,CAAC;AAEK,SAAU,QAAQ,CAAC,IAAY;IACnC,IAAI,CAAC,MAAM,CAAC,IAAI,iLAAC,qBAAkB,CAAC,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE;QACnD,uLAAO,qBAAkB,iLAAC,gBAAa,CAAC,CAAC;KAC1C;IACD,uLAAO,qBAAkB,CAAC,IAAI,CAAC,CAAC;AAClC,CAAC;AAEK,SAAU,cAAc,CAAC,IAAY;IACzC,MAAM,KAAK,GAAG,MAAM,CAAC,MAAM,iLAAC,qBAAkB,CAAC,CAAC,IAAI,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,CAAC;IAC3E,IAAI,CAAC,KAAK,EAAE;QACV,uLAAO,qBAAkB,iLAAC,gBAAa,CAAC,CAAC;KAC1C;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAEK,SAAU,oBAAoB,CAAC,QAAsB;IACzD,IAAI,OAAO,QAAQ,CAAC,KAAK,CAAC,IAAI,KAAK,WAAW,EAAE;QAC9C,OAAO;YAAE,KAAK,EAAE,KAAK;YAAE,KAAK,EAAE,iCAAiC;QAAA,CAAE,CAAC;KACnE;IACD,IAAI,OAAO,QAAQ,CAAC,KAAK,CAAC,OAAO,KAAK,WAAW,EAAE;QACjD,OAAO;YAAE,KAAK,EAAE,KAAK;YAAE,KAAK,EAAE,oCAAoC;QAAA,CAAE,CAAC;KACtE;IACD,IAAI,CAAC,gBAAgB,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;QAC1C,OAAO;YACL,KAAK,EAAE,KAAK;YACZ,KAAK,EAAE,CAAA,sCAAA,EAAyC,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE;SACtE,CAAC;KACH;IACD,IAAI,mBAAmB,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,EAAE;QAC5C,MAAM,KAAK,GAAG,cAAc,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;QAClD,IACE,KAAK,CAAC,OAAO,qLAAK,qBAAkB,iLAAC,gBAAa,CAAC,CAAC,OAAO,IAC3D,QAAQ,CAAC,KAAK,CAAC,OAAO,KAAK,KAAK,CAAC,OAAO,EACxC;YACA,OAAO;gBACL,KAAK,EAAE,KAAK;gBACZ,KAAK,EAAE,CAAA,yCAAA,EAA4C,QAAQ,CAAC,KAAK,CAAC,IAAI,EAAE;aACzE,CAAC;SACH;KACF;IACD,OAAO;QAAE,KAAK,EAAE,IAAI;IAAA,CAAE,CAAC;AACzB,CAAC;AAEK,SAAU,oBAAoB,CAAC,CAAQ,EAAE,GAAW,EAAE,IAAY;IACtE,OAAO,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,uBAAuB,CAAC,IAAI,CAAC,CAAC,OAAO,CAAC,QAAQ,CAAC,sBAAsB,CAAC,GAC5F,IAAI,KAAK,CAAC,CAAA,YAAA,EAAe,IAAI,CAAA,YAAA,EAAe,GAAG,EAAE,CAAC,GAClD,CAAC,CAAC;AACR,CAAC","debugId":null}},
    {"offset": {"line": 4060, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4066, "column": 0}, "map": {"version":3,"file":"env.js","sourceRoot":"","sources":["../../src/env.ts"],"names":[],"mappings":";;;AAAA,OAAO,EAAE,MAAM,EAAE,MAAM,4BAA4B,CAAC;;AAG7C,MAAM,QAAQ,0KAAG,SAAM,CAAC","debugId":null}},
    {"offset": {"line": 4074, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4089, "column": 0}, "map": {"version":3,"file":"format.js","sourceRoot":"","sources":["../../src/format.ts"],"names":[],"mappings":";;;;;;;;AAAA,OAAO,EAAE,QAAQ,EAAE,cAAc,EAAE,mBAAmB,EAAqB,MAAM,SAAS,CAAC;AAC3F,OAAO,EAAE,cAAc,EAAE,YAAY,EAAE,MAAM,aAAa,CAAC;;;AAGrD,SAAU,SAAS,CAAC,OAAO,GAAG,CAAC;IACnC,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC;IAChD,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,MAAM,EAAE,GAAG,IAAI,CAAC,GAAG,CAAC,EAAE,EAAE,OAAO,CAAC,CAAC,CAAC;IAChE,OAAO,IAAI,GAAG,KAAK,CAAC;AACtB,CAAC;AAEK,SAAU,cAAc,CAAC,OAAO,GAAG,CAAC;IACxC,OAAO,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;AACpC,CAAC;AAEK,SAAU,oBAAoB,CAClC,MAAc,EACd,MAAS,EACT,EAAW;IAEX,OAAO;QACL,EAAE,EAAE,EAAE,IAAI,SAAS,EAAE;QACrB,OAAO,EAAE,KAAK;QACd,MAAM;QACN,MAAM;KACP,CAAC;AACJ,CAAC;AAEK,SAAU,mBAAmB,CAAU,EAAU,EAAE,MAAS;IAChE,OAAO;QACL,EAAE;QACF,OAAO,EAAE,KAAK;QACd,MAAM;KACP,CAAC;AACJ,CAAC;AAEK,SAAU,kBAAkB,CAChC,EAAU,EACV,KAA8B,EAC9B,IAAa;IAEb,OAAO;QACL,EAAE;QACF,OAAO,EAAE,KAAK;QACd,KAAK,EAAE,kBAAkB,CAAC,KAAK,EAAE,IAAI,CAAC;KACvC,CAAC;AACJ,CAAC;AAEK,SAAU,kBAAkB,CAAC,KAA8B,EAAE,IAAa;IAC9E,IAAI,OAAO,KAAK,KAAK,WAAW,EAAE;QAChC,uLAAO,WAAA,AAAQ,kLAAC,iBAAc,CAAC,CAAC;KACjC;IACD,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC7B,KAAK,GAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,mLACA,WAAA,AAAQ,kLAAC,eAAY,CAAC,GAAA;YACzB,OAAO,EAAE,KAAK;QAAA,EACf,CAAC;KACH;IACD,IAAI,OAAO,IAAI,KAAK,WAAW,EAAE;QAC/B,KAAK,CAAC,IAAI,GAAG,IAAI,CAAC;KACnB;IACD,oLAAI,sBAAA,AAAmB,EAAC,KAAK,CAAC,IAAI,CAAC,EAAE;QACnC,KAAK,mLAAG,iBAAA,AAAc,EAAC,KAAK,CAAC,IAAI,CAAC,CAAC;KACpC;IACD,OAAO,KAAK,CAAC;AACf,CAAC","debugId":null}},
    {"offset": {"line": 4148, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4154, "column": 0}, "map": {"version":3,"file":"routing.js","sourceRoot":"","sources":["../../src/routing.ts"],"names":[],"mappings":";;;;;;;AAAM,SAAU,YAAY,CAAC,KAAa;IACxC,IAAI,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;QACvB,OAAO,oBAAoB,CAAC,KAAK,CAAC,CAAC;KACpC;IACD,IAAI,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE;QACrB,OAAO,KAAK,CAAC;KACd;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAEK,SAAU,mBAAmB,CAAC,KAAa;IAC/C,OAAO,KAAK,KAAK,GAAG,CAAC;AACvB,CAAC;AAEK,SAAU,oBAAoB,CAAC,KAAa;IAChD,IAAI,mBAAmB,CAAC,KAAK,CAAC,EAAE;QAC9B,OAAO,IAAI,CAAC;KACb;IACD,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;QACxB,OAAO,KAAK,CAAC;KACd;IACD,IAAI,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;QACjC,OAAO,KAAK,CAAC;KACd;IACD,IAAI,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,MAAM,EAAC,CAAC,CAAC,EAAE,AAAC,CAAC,CAAC,IAAI,EAAE,KAAK,EAAE,CAAC,CAAC,MAAM,KAAK,CAAC,EAAE;QAC9D,OAAO,KAAK,CAAC;KACd;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAEK,SAAU,2BAA2B,CAAC,KAAa;IACvD,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,IAAI,oBAAoB,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AACnG,CAAC;AAEK,SAAU,4BAA4B,CAAC,KAAa;IACxD,OAAO,CAAC,mBAAmB,CAAC,KAAK,CAAC,IAAI,oBAAoB,CAAC,KAAK,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AACnG,CAAC","debugId":null}},
    {"offset": {"line": 4194, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4200, "column": 0}, "map": {"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types.ts"],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 4203, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4218, "column": 0}, "map": {"version":3,"file":"url.js","sourceRoot":"","sources":["../../src/url.ts"],"names":[],"mappings":";;;;;AAAA,MAAM,UAAU,GAAG,UAAU,CAAC;AAE9B,MAAM,QAAQ,GAAG,QAAQ,CAAC;AAE1B,SAAS,cAAc,CAAC,GAAW;IACjC,MAAM,OAAO,GAAG,GAAG,CAAC,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC,CAAC;IACrD,IAAI,CAAC,OAAO,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO;IACxC,OAAO,OAAO,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC;AAED,SAAS,kBAAkB,CAAC,GAAW,EAAE,KAAa;IACpD,MAAM,QAAQ,GAAG,cAAc,CAAC,GAAG,CAAC,CAAC;IACrC,IAAI,OAAO,QAAQ,KAAK,WAAW,EAAE,OAAO,KAAK,CAAC;IAClD,OAAO,IAAI,MAAM,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AAC1C,CAAC;AAEK,SAAU,SAAS,CAAC,GAAW;IACnC,OAAO,kBAAkB,CAAC,GAAG,EAAE,UAAU,CAAC,CAAC;AAC7C,CAAC;AAEK,SAAU,OAAO,CAAC,GAAW;IACjC,OAAO,kBAAkB,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;AAC3C,CAAC;AAEK,SAAU,cAAc,CAAC,GAAW;IACxC,OAAO,IAAI,MAAM,CAAC,4BAA4B,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAC5D,CAAC","debugId":null}},
    {"offset": {"line": 4244, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4250, "column": 0}, "map": {"version":3,"file":"validators.js","sourceRoot":"","sources":["../../src/validators.ts"],"names":[],"mappings":";;;;;;;;AAUM,SAAU,gBAAgB,CAAC,OAAY;IAC3C,OAAO,AACL,OAAO,OAAO,KAAK,QAAQ,IAC3B,IAAI,IAAI,OAAO,IACf,SAAS,IAAI,OAAO,IACpB,OAAO,CAAC,OAAO,KAAK,KAAK,CAC1B,CAAC;AACJ,CAAC;AAEK,SAAU,gBAAgB,CAAU,OAAuB;IAC/D,OAAO,gBAAgB,CAAC,OAAO,CAAC,IAAI,QAAQ,IAAI,OAAO,CAAC;AAC1D,CAAC;AAEK,SAAU,iBAAiB,CAAU,OAAuB;IAChE,OAAO,gBAAgB,CAAC,OAAO,CAAC,IAAI,CAAC,eAAe,CAAC,OAAO,CAAC,IAAI,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC;AAC5F,CAAC;AAEK,SAAU,eAAe,CAAU,OAAuB;IAC9D,OAAO,QAAQ,IAAI,OAAO,CAAC;AAC7B,CAAC;AAEK,SAAU,cAAc,CAAC,OAAuB;IACpD,OAAO,OAAO,IAAI,OAAO,CAAC;AAC5B,CAAC;AAEK,SAAU,0BAA0B,CACxC,UAA6B;IAE7B,OAAO,OAAO,IAAI,UAAU,IAAI,UAAU,CAAC,KAAK,KAAK,KAAK,CAAC;AAC7D,CAAC","debugId":null}},
    {"offset": {"line": 4276, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4282, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 4292, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4313, "column": 0}, "map": {"version":3,"file":"crypto.js","sourceRoot":"","sources":["../../src/crypto.ts"],"names":[],"mappings":";;;;;AAAA,SAAgB,eAAe;IAE7B,OAAO,CAAA,MAAM,KAAA,QAAN,MAAM,KAAA,KAAA,IAAA,KAAA,IAAN,MAAM,CAAE,MAAM,KAAA,CAAI,MAAM,KAAA,QAAN,MAAM,KAAA,KAAA,IAAA,KAAA,IAAN,MAAM,CAAE,QAAQ,CAAA,IAAI,CAAA,CAAE,CAAC;AAClD,CAAC;AAHD,QAAA,eAAA,GAAA,gBAGC;AAED,SAAgB,eAAe;IAC7B,MAAM,aAAa,GAAG,eAAe,EAAE,CAAC;IAExC,OAAO,aAAa,CAAC,MAAM,IAAI,aAAa,CAAC,YAAY,CAAC;AAC5D,CAAC;AAJD,QAAA,eAAA,GAAA,gBAIC;AAED,SAAgB,wBAAwB;IACtC,OAAO,CAAC,CAAC,eAAe,EAAE,IAAI,CAAC,CAAC,eAAe,EAAE,CAAC;AACpD,CAAC;AAFD,QAAA,wBAAA,GAAA,yBAEC","debugId":null}},
    {"offset": {"line": 4331, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4336, "column": 0}, "map": {"version":3,"file":"env.js","sourceRoot":"","sources":["../../src/env.ts"],"names":[],"mappings":";;;;;AAAA,SAAgB,aAAa;IAC3B,OAAO,AACL,OAAO,QAAQ,KAAK,WAAW,IAC/B,OAAO,SAAS,KAAK,WAAW,IAChC,SAAS,CAAC,OAAO,KAAK,aAAa,CACpC,CAAC;AACJ,CAAC;AAND,QAAA,aAAA,GAAA,cAMC;AAED,SAAgB,MAAM;IACpB,OAAO,AACL,OAAO,OAAO,KAAK,WAAW,IAC9B,OAAO,OAAO,CAAC,QAAQ,KAAK,WAAW,IACvC,OAAO,OAAO,CAAC,QAAQ,CAAC,IAAI,KAAK,WAAW,CAC7C,CAAC;AACJ,CAAC;AAND,QAAA,MAAA,GAAA,OAMC;AAED,SAAgB,SAAS;IACvB,OAAO,CAAC,aAAa,EAAE,IAAI,CAAC,MAAM,EAAE,CAAC;AACvC,CAAC;AAFD,QAAA,SAAA,GAAA,UAEC","debugId":null}},
    {"offset": {"line": 4353, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4358, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,yHAAA,SAAyB;AACzB,QAAA,YAAA,sHAAA,SAAsB","debugId":null}},
    {"offset": {"line": 4365, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4371, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/jsonrpc-types/src/misc.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/jsonrpc-types/src/provider.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\n\nexport abstract class IEvents {\n  public abstract events: EventEmitter;\n\n  // events\n  public abstract on(event: string, listener: any): void;\n  public abstract once(event: string, listener: any): void;\n  public abstract off(event: string, listener: any): void;\n  public abstract removeListener(event: string, listener: any): void;\n}\n","import { JsonRpcPayload, JsonRpcRequest, RequestArguments } from \"./jsonrpc\";\nimport { IEvents } from \"./misc\";\n\nexport abstract class IJsonRpcConnection extends IEvents {\n  public abstract connected: boolean;\n  public abstract connecting: boolean;\n  // @ts-ignore - opts is not used in abstract class constructor\n  constructor(opts?: any) {\n    super();\n  }\n\n  public abstract open(opts?: any): Promise<void>;\n  public abstract close(): Promise<void>;\n  public abstract send(payload: JsonRpcPayload, context?: any): Promise<void>;\n}\n\nexport abstract class IBaseJsonRpcProvider extends IEvents {\n  // eslint-disable-next-line no-useless-constructor\n  constructor() {\n    super();\n  }\n\n  public abstract connect(params?: any): Promise<void>;\n\n  public abstract disconnect(): Promise<void>;\n\n  public abstract request<Result = any, Params = any>(\n    request: RequestArguments<Params>,\n    context?: any,\n  ): Promise<Result>;\n\n  // ---------- Protected ----------------------------------------------- //\n\n  protected abstract requestStrict<Result = any, Params = any>(\n    request: JsonRpcRequest<Params>,\n    context?: any,\n  ): Promise<Result>;\n}\n\nexport abstract class IJsonRpcProvider extends IBaseJsonRpcProvider {\n  public abstract connection: IJsonRpcConnection;\n\n  // @ts-ignore - connection is not used in abstract class constructor\n  constructor(connection: string | IJsonRpcConnection) {\n    super();\n  }\n\n  public abstract connect(connection?: string | IJsonRpcConnection): Promise<void>;\n\n  // ---------- Protected ----------------------------------------------- //\n\n  protected abstract setConnection(connection?: string | IJsonRpcConnection): IJsonRpcConnection;\n\n  protected abstract onPayload(payload: JsonRpcPayload): void;\n\n  protected abstract open(connection?: string | IJsonRpcConnection): Promise<void>;\n\n  protected abstract close(): Promise<void>;\n}\n"],"names":["IEvents","opts","connection"],"mappings":";;;;;;AAEO,MAAe;AAAA;AAAA,IAAQ,EAAA,UAAA;IAAA,YAAA,CAAA,CAAA;QAAA,KAAA;IAAA;AAAA;AAAA,MAAA,UAAA;IAAA,aAAA;QAAA,KAAA;IAAA;AAAA;AAAA,MAAA,UAAA;IAAA,YAAA,CAAA,CAAA;QAAA,KAAA;IAAA;AAAA","ignoreList":[0,1],"debugId":null}},
    {"offset": {"line": 4396, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4402, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/jsonrpc-provider/src/provider.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport {\n  RequestArguments,\n  IJsonRpcProvider,\n  IJsonRpcConnection,\n  JsonRpcRequest,\n  JsonRpcPayload,\n  JsonRpcProviderMessage,\n  isJsonRpcResponse,\n  formatJsonRpcRequest,\n  isJsonRpcError,\n  getBigIntRpcId,\n} from \"@walletconnect/jsonrpc-utils\";\n\nexport class JsonRpcProvider extends IJsonRpcProvider {\n  public events = new EventEmitter();\n\n  public connection: IJsonRpcConnection;\n\n  private hasRegisteredEventListeners = false;\n\n  constructor(connection: IJsonRpcConnection) {\n    super(connection);\n    this.connection = this.setConnection(connection);\n    if (this.connection.connected) {\n      this.registerEventListeners();\n    }\n  }\n\n  public async connect(connection: string | IJsonRpcConnection = this.connection): Promise<void> {\n    await this.open(connection);\n  }\n\n  public async disconnect(): Promise<void> {\n    await this.close();\n  }\n\n  public on(event: string, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public async request<Result = any, Params = any>(\n    request: RequestArguments<Params>,\n    context?: any,\n  ): Promise<Result> {\n    return this.requestStrict(\n      formatJsonRpcRequest(\n        request.method,\n        request.params || [],\n        request.id || (getBigIntRpcId().toString() as any),\n      ), // casting to any is required in order to use BigInt as rpcId\n      context,\n    );\n  }\n\n  // ---------- Protected ----------------------------------------------- //\n\n  protected async requestStrict<Result = any, Params = any>(\n    request: JsonRpcRequest<Params>,\n    context?: any,\n  ): Promise<Result> {\n    return new Promise(async (resolve, reject) => {\n      if (!this.connection.connected) {\n        try {\n          await this.open();\n        } catch (e) {\n          reject(e);\n        }\n      }\n      this.events.on(`${request.id}`, (response) => {\n        if (isJsonRpcError(response)) {\n          reject(response.error);\n        } else {\n          resolve(response.result);\n        }\n      });\n      try {\n        await this.connection.send(request, context);\n      } catch (e) {\n        reject(e);\n      }\n    });\n  }\n\n  protected setConnection(connection: IJsonRpcConnection = this.connection) {\n    return connection;\n  }\n\n  protected onPayload(payload: JsonRpcPayload): void {\n    this.events.emit(\"payload\", payload);\n    if (isJsonRpcResponse(payload)) {\n      this.events.emit(`${payload.id}`, payload);\n    } else {\n      this.events.emit(\"message\", {\n        type: payload.method,\n        data: payload.params,\n      } as JsonRpcProviderMessage);\n    }\n  }\n\n  protected onClose(event?: CloseEvent): void {\n    // Code 3000 indicates an abnormal closure signalled by the relay -> emit an error in this case.\n    if (event && event.code === 3000) {\n      this.events.emit(\n        \"error\",\n        new Error(\n          `WebSocket connection closed abnormally with code: ${event.code} ${\n            event.reason ? `(${event.reason})` : \"\"\n          }`,\n        ),\n      );\n    }\n    this.events.emit(\"disconnect\");\n  }\n\n  protected async open(connection: string | IJsonRpcConnection = this.connection) {\n    if (this.connection === connection && this.connection.connected) return;\n    if (this.connection.connected) this.close();\n    if (typeof connection === \"string\") {\n      await this.connection.open(connection);\n      connection = this.connection;\n    }\n    this.connection = this.setConnection(connection);\n    await this.connection.open();\n    this.registerEventListeners();\n    this.events.emit(\"connect\");\n  }\n\n  protected async close() {\n    await this.connection.close();\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private registerEventListeners() {\n    if (this.hasRegisteredEventListeners) return;\n    this.connection.on(\"payload\", (payload: JsonRpcPayload) => this.onPayload(payload));\n    this.connection.on(\"close\", (event?: CloseEvent) => this.onClose(event));\n    this.connection.on(\"error\", (error: Error) => this.events.emit(\"error\", error));\n    this.connection.on(\"register_error\", (_error: Error) => this.onClose());\n    this.hasRegisteredEventListeners = true;\n  }\n}\n\nexport default JsonRpcProvider;\n"],"names":["IJsonRpcProvider","connection","EventEmitter","event","listener","request","context","formatJsonRpcRequest","getBigIntRpcId","resolve","reject","e","response","isJsonRpcError","payload","isJsonRpcResponse","error","_error"],"mappings":"","ignoreList":[0],"debugId":null}},
    {"offset": {"line": 4479, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4485, "column": 0}, "map": {"version":3,"file":"index.es.js","sources":["file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/jsonrpc-ws-connection/src/utils.ts","file://D%3A/CODING_PROJECTS/PROJET_TOTOSHE/RPSWEB/node_modules/%40walletconnect/jsonrpc-ws-connection/src/ws.ts"],"sourcesContent":["export const resolveWebSocketImplementation = () => {\n  if (typeof WebSocket !== \"undefined\") {\n    return WebSocket;\n  } else if (typeof global !== \"undefined\" && typeof global.WebSocket !== \"undefined\") {\n    return global.WebSocket;\n  } else if (typeof window !== \"undefined\" && typeof window.WebSocket !== \"undefined\") {\n    return window.WebSocket;\n  } else if (typeof self !== \"undefined\" && typeof self.WebSocket !== \"undefined\") {\n    return self.WebSocket;\n  }\n\n  return require(\"ws\");\n};\n\nexport const hasBuiltInWebSocket = () =>\n  typeof WebSocket !== \"undefined\" ||\n  (typeof global !== \"undefined\" && typeof global.WebSocket !== \"undefined\") ||\n  (typeof window !== \"undefined\" && typeof window.WebSocket !== \"undefined\") ||\n  (typeof self !== \"undefined\" && typeof self.WebSocket !== \"undefined\");\n\nexport const isBrowser = () => typeof window !== \"undefined\";\n\nexport const truncateQuery = (wssUrl: string) => wssUrl.split(\"?\")[0];\n","import { EventEmitter } from \"events\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport {\n  formatJsonRpcError,\n  IJsonRpcConnection,\n  JsonRpcPayload,\n  isReactNative,\n  isWsUrl,\n  isLocalhostUrl,\n  parseConnectionError,\n} from \"@walletconnect/jsonrpc-utils\";\nimport { truncateQuery, resolveWebSocketImplementation, hasBuiltInWebSocket } from \"./utils\";\n\n// Source: https://nodejs.org/api/events.html#emittersetmaxlistenersn\nconst EVENT_EMITTER_MAX_LISTENERS_DEFAULT = 10;\n\nconst WS = resolveWebSocketImplementation();\n\nexport class WsConnection implements IJsonRpcConnection {\n  public events = new EventEmitter();\n\n  private socket: WebSocket | undefined;\n\n  private registering = false;\n\n  constructor(public url: string) {\n    if (!isWsUrl(url)) {\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);\n    }\n    this.url = url;\n  }\n\n  get connected(): boolean {\n    return typeof this.socket !== \"undefined\";\n  }\n\n  get connecting(): boolean {\n    return this.registering;\n  }\n\n  public on(event: string, listener: any): void {\n    this.events.on(event, listener);\n  }\n\n  public once(event: string, listener: any): void {\n    this.events.once(event, listener);\n  }\n\n  public off(event: string, listener: any): void {\n    this.events.off(event, listener);\n  }\n\n  public removeListener(event: string, listener: any): void {\n    this.events.removeListener(event, listener);\n  }\n\n  public async open(url: string = this.url): Promise<void> {\n    await this.register(url);\n  }\n\n  public async close(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      if (typeof this.socket === \"undefined\") {\n        reject(new Error(\"Connection already closed\"));\n        return;\n      }\n\n      this.socket.onclose = (event) => {\n        this.onClose(event);\n        resolve();\n      };\n\n      this.socket.close();\n    });\n  }\n\n  public async send(payload: JsonRpcPayload): Promise<void> {\n    if (typeof this.socket === \"undefined\") {\n      this.socket = await this.register();\n    }\n    try {\n      this.socket.send(safeJsonStringify(payload));\n    } catch (e) {\n      this.onError(payload.id, e as Error);\n    }\n  }\n\n  // ---------- Private ----------------------------------------------- //\n\n  private register(url = this.url): Promise<WebSocket> {\n    if (!isWsUrl(url)) {\n      throw new Error(`Provided URL is not compatible with WebSocket connection: ${url}`);\n    }\n    if (this.registering) {\n      const currentMaxListeners = this.events.getMaxListeners();\n      if (\n        this.events.listenerCount(\"register_error\") >= currentMaxListeners ||\n        this.events.listenerCount(\"open\") >= currentMaxListeners\n      ) {\n        this.events.setMaxListeners(currentMaxListeners + 1);\n      }\n      return new Promise((resolve, reject) => {\n        this.events.once(\"register_error\", (error) => {\n          this.resetMaxListeners();\n          reject(error);\n        });\n        this.events.once(\"open\", () => {\n          this.resetMaxListeners();\n          if (typeof this.socket === \"undefined\") {\n            return reject(new Error(\"WebSocket connection is missing or invalid\"));\n          }\n          resolve(this.socket);\n        });\n      });\n    }\n    this.url = url;\n    this.registering = true;\n\n    return new Promise((resolve, reject) => {\n      const opts = !isReactNative() ? { rejectUnauthorized: !isLocalhostUrl(url) } : undefined;\n      const socket: WebSocket = new WS(url, [], opts);\n      if (hasBuiltInWebSocket()) {\n        socket.onerror = (event: Event) => {\n          const errorEvent = event as ErrorEvent;\n          reject(this.emitError(errorEvent.error));\n        };\n      } else {\n        (socket as any).on(\"error\", (errorEvent: any) => {\n          reject(this.emitError(errorEvent));\n        });\n      }\n      socket.onopen = () => {\n        this.onOpen(socket);\n        resolve(socket);\n      };\n    });\n  }\n\n  private onOpen(socket: WebSocket) {\n    socket.onmessage = (event: MessageEvent) => this.onPayload(event);\n    socket.onclose = (event) => this.onClose(event);\n    this.socket = socket;\n    this.registering = false;\n    this.events.emit(\"open\");\n  }\n\n  private onClose(event: CloseEvent) {\n    this.socket = undefined;\n    this.registering = false;\n    this.events.emit(\"close\", event);\n  }\n\n  private onPayload(e: { data: any }) {\n    if (typeof e.data === \"undefined\") return;\n    const payload: JsonRpcPayload = typeof e.data === \"string\" ? safeJsonParse(e.data) : e.data;\n    this.events.emit(\"payload\", payload);\n  }\n\n  private onError(id: number, e: Error) {\n    const error = this.parseError(e);\n    const message = error.message || error.toString();\n    const payload = formatJsonRpcError(id, message);\n    this.events.emit(\"payload\", payload);\n  }\n\n  private parseError(e: Error, url = this.url) {\n    return parseConnectionError(e, truncateQuery(url), \"WS\");\n  }\n\n  private resetMaxListeners() {\n    if (this.events.getMaxListeners() > EVENT_EMITTER_MAX_LISTENERS_DEFAULT) {\n      this.events.setMaxListeners(EVENT_EMITTER_MAX_LISTENERS_DEFAULT);\n    }\n  }\n\n  private emitError(errorEvent: Error) {\n    const error = this.parseError(\n      new Error(\n        errorEvent?.message || `WebSocket connection failed for host: ${truncateQuery(this.url)}`,\n      ),\n    );\n    this.events.emit(\"register_error\", error);\n    return error;\n  }\n}\n\nexport default WsConnection;\n"],"names":["wssUrl","EVENT_EMITTER_MAX_LISTENERS_DEFAULT","WS","resolveWebSocketImplementation","url","EventEmitter","isWsUrl","event","listener","resolve","reject","payload","safeJsonStringify","e","currentMaxListeners","error","opts","isReactNative","isLocalhostUrl","socket","hasBuiltInWebSocket","errorEvent","safeJsonParse","id","message","formatJsonRpcError","parseConnectionError","truncateQuery"],"mappings":"","ignoreList":[0,1],"debugId":null}},
    {"offset": {"line": 4600, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4605, "column": 0}, "map": {"version":3,"file":"browser.js","sourceRoot":"","sources":["../../src/browser.ts"],"names":[],"mappings":";;;;;;AAEA,MAAA,iBAAA,QAAA,YAAA,4CAAiE;AACjE,MAAA,gBAAA,QAAA,YAAA,2CAA+D;AAC/D,MAAA,6CAOwB;AAExB,SAAgB,SAAS,CACvB,SAAkB;IAElB,OAAO,CAAA,GAAA,iBAAA,MAAM,EAAC,SAAS,CAAC,CAAC;AAC3B,CAAC;AAJD,QAAA,SAAA,GAAA,UAIC;AAED,SAAgB,QAAQ;IACtB,MAAM,GAAG,GAAG,SAAS,EAAE,CAAC;IACxB,OAAO,GAAG,IAAI,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;AAC5C,CAAC;AAHD,QAAA,QAAA,GAAA,SAGC;AAED,SAAgB,SAAS;IACvB,MAAM,EAAE,GAAG,QAAQ,EAAE,CAAC;IACtB,OAAO,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;AAC3D,CAAC;AAHD,QAAA,SAAA,GAAA,UAGC;AAED,SAAgB,KAAK;IACnB,MAAM,EAAE,GAAG,QAAQ,EAAE,CAAC;IACtB,OAAO,EAAE,GACL,EAAE,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,IAC7B,EAAE,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,IAAI,SAAS,CAAC,cAAc,GAAG,CAAC,CAAC,EACpE,KAAK,CAAC;AACZ,CAAC;AAND,QAAA,KAAA,GAAA,MAMC;AAED,SAAgB,QAAQ;IACtB,MAAM,EAAE,GAAG,QAAQ,EAAE,CAAC;IACtB,OAAO,EAAE,CAAC,CAAC,CAAC,SAAS,EAAE,IAAI,KAAK,EAAE,CAAC,CAAC,CAAC,KAAK,CAAC;AAC7C,CAAC;AAHD,QAAA,QAAA,GAAA,SAGC;AAED,SAAgB,MAAM;IACpB,MAAM,GAAG,GAAG,SAAS,EAAE,CAAC;IACxB,MAAM,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,MAAM,CAAC,CAAC,CAAC,KAAK,CAAC;IAC3E,OAAO,MAAM,CAAC;AAChB,CAAC;AAJD,QAAA,MAAA,GAAA,OAIC;AAED,SAAgB,SAAS;IACvB,MAAM,MAAM,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,CAAC,CAAA,GAAA,QAAA,YAAY,GAAE,CAAC;IAC7C,OAAO,MAAM,CAAC;AAChB,CAAC;AAHD,QAAA,SAAA,GAAA,UAGC;AAEY,QAAA,aAAa,GAAG,aAAa,CAAC,aAAa,CAAC;AAE5C,QAAA,oBAAoB,GAAG,aAAa,CAAC,oBAAoB,CAAC;AAE1D,QAAA,kBAAkB,GAAG,aAAa,CAAC,kBAAkB,CAAC;AAEtD,QAAA,WAAW,GAAG,aAAa,CAAC,WAAW,CAAC;AAExC,QAAA,mBAAmB,GAAG,aAAa,CAAC,mBAAmB,CAAC;AAExD,QAAA,YAAY,GAAG,aAAa,CAAC,YAAY,CAAC;AAE1C,QAAA,kBAAkB,GAAG,aAAa,CAAC,kBAAkB,CAAC;AAEtD,QAAA,WAAW,GAAG,aAAa,CAAC,WAAW,CAAC;AAExC,QAAA,gBAAgB,GAAG,aAAa,CAAC,gBAAgB,CAAC;AAElD,QAAA,SAAS,GAAG,aAAa,CAAC,SAAS,CAAC;AAEpC,QAAA,sBAAsB,GAAG,aAAa,CAAC,sBAAsB,CAAC;AAE9D,QAAA,eAAe,GAAG,aAAa,CAAC,eAAe,CAAC;AAE7D,SAAgB,aAAa;IAC3B,OAAO,cAAc,CAAC,iBAAiB,EAAE,CAAC;AAC5C,CAAC;AAFD,QAAA,aAAA,GAAA,cAEC","debugId":null}},
    {"offset": {"line": 4665, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4670, "column": 0}, "map": {"version":3,"file":"json.js","sourceRoot":"","sources":["../../src/json.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,WAAA,QAAA,YAAA,sCAAqD;AAExC,QAAA,aAAa,GAAG,QAAQ,CAAC,aAAa,CAAC;AAEvC,QAAA,iBAAiB,GAAG,QAAQ,CAAC,iBAAiB,CAAC","debugId":null}},
    {"offset": {"line": 4679, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4684, "column": 0}, "map": {"version":3,"file":"local.js","sourceRoot":"","sources":["../../src/local.ts"],"names":[],"mappings":";;;;;AAAA,MAAA,2BAA0D;AAC1D,MAAA,iCAA4C;AAE5C,SAAgB,QAAQ,CAAC,GAAW,EAAE,IAAS;IAC7C,MAAM,GAAG,GAAG,CAAA,GAAA,OAAA,iBAAiB,EAAC,IAAI,CAAC,CAAC;IACpC,MAAM,KAAK,GAAG,CAAA,GAAA,UAAA,eAAe,GAAE,CAAC;IAChC,IAAI,KAAK,EAAE;QACT,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;KACzB;AACH,CAAC;AAND,QAAA,QAAA,GAAA,SAMC;AAED,SAAgB,QAAQ,CAAC,GAAW;IAClC,IAAI,IAAI,GAAQ,IAAI,CAAC;IACrB,IAAI,GAAG,GAAkB,IAAI,CAAC;IAC9B,MAAM,KAAK,GAAG,CAAA,GAAA,UAAA,eAAe,GAAE,CAAC;IAChC,IAAI,KAAK,EAAE;QACT,GAAG,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;KAC1B;IACD,IAAI,GAAG,GAAG,CAAC,CAAC,CAAC,CAAA,GAAA,OAAA,aAAa,EAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC;IACtC,OAAO,IAAI,CAAC;AACd,CAAC;AATD,QAAA,QAAA,GAAA,SASC;AAED,SAAgB,WAAW,CAAC,GAAW;IACrC,MAAM,KAAK,GAAG,CAAA,GAAA,UAAA,eAAe,GAAE,CAAC;IAChC,IAAI,KAAK,EAAE;QACT,KAAK,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC;KACvB;AACH,CAAC;AALD,QAAA,WAAA,GAAA,YAKC","debugId":null}},
    {"offset": {"line": 4717, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4722, "column": 0}, "map": {"version":3,"file":"mobile.js","sourceRoot":"","sources":["../../src/mobile.ts"],"names":[],"mappings":";;;;;AAEA,MAAA,6BAAmC;AAEtB,QAAA,mBAAmB,GAAG,+BAA+B,CAAC;AAEnE,SAAgB,eAAe,CAAC,GAAW,EAAE,KAA2B;IACtE,MAAM,UAAU,GAAW,kBAAkB,CAAC,GAAG,CAAC,CAAC;IACnD,OAAO,KAAK,CAAC,aAAa,GACtB,GAAG,KAAK,CAAC,aAAa,CAAA,QAAA,EAAW,UAAU,EAAE,GAC7C,KAAK,CAAC,QAAQ,GACd,GAAG,KAAK,CAAC,QAAQ,GAAG,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,GAAG,CAAA,OAAA,EAAU,UAAU,EAAE,GACnF,EAAE,CAAC;AACT,CAAC;AAPD,QAAA,eAAA,GAAA,gBAOC;AAED,SAAgB,kBAAkB,CAAC,IAAqB;IACtD,MAAM,QAAQ,GAAG,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC;IACzC,CAAA,GAAA,QAAA,QAAQ,EAAC,QAAA,mBAAmB,EAAA,OAAA,MAAA,CAAA,OAAA,MAAA,CAAA,CAAA,GAAO,IAAI,GAAA;QAAE,IAAI,EAAE,QAAQ;IAAA,GAAG,CAAC;AAC7D,CAAC;AAHD,QAAA,kBAAA,GAAA,mBAGC;AAED,SAAgB,sBAAsB,CACpC,QAAyB,EACzB,IAAY;IAEZ,OAAO,QAAQ,CAAC,MAAM,CAAC,CAAC,KAA2B,EAAE,CACnD,CADqD,IAChD,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,QAAQ,CAAC,IAAI,CAAC,WAAW,EAAE,CAAC,CACtD,CAAC,CAAC,CAAC,CAAC;AACP,CAAC;AAPD,QAAA,sBAAA,GAAA,uBAOC;AAED,SAAgB,qBAAqB,CAAC,QAAyB,EAAE,SAAoB;IACnF,IAAI,KAAK,GAAG,QAAQ,CAAC;IACrB,IAAI,SAAS,EAAE;QACb,KAAK,GAAG,SAAS,CAAC,GAAG,CAAC,CAAC,IAAY,EAAE,CAAG,CAAD,qBAAuB,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;KACjG;IACD,OAAO,KAAK,CAAC;AACf,CAAC;AAND,QAAA,qBAAA,GAAA,sBAMC","debugId":null}},
    {"offset": {"line": 4753, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4758, "column": 0}, "map": {"version":3,"file":"registry.js","sourceRoot":"","sources":["../../src/registry.ts"],"names":[],"mappings":";;;;;AAEA,MAAM,OAAO,GAAG,oCAAoC,CAAC;AAErD,SAAgB,oBAAoB;IAClC,OAAO,OAAO,GAAG,iBAAiB,CAAC;AACrC,CAAC;AAFD,QAAA,oBAAA,GAAA,qBAEC;AAED,SAAgB,kBAAkB;IAChC,OAAO,OAAO,GAAG,eAAe,CAAC;AACnC,CAAC;AAFD,QAAA,kBAAA,GAAA,mBAEC;AAED,SAAgB,yBAAyB,CAAC,KAAgB,EAAE,WAAiC,QAAQ;;IACnG,OAAO;QACL,IAAI,EAAE,KAAK,CAAC,IAAI,IAAI,EAAE;QACtB,SAAS,EAAE,KAAK,CAAC,QAAQ,CAAC,SAAS,IAAI,EAAE;QACzC,KAAK,EAAE,KAAK,CAAC,QAAQ,CAAC,MAAM,CAAC,OAAO,IAAI,EAAE;QAC1C,IAAI,EAAE,CAAA,KAAA,KAAK,CAAC,SAAS,CAAC,EAAE,MAAA,QAAA,OAAA,KAAA,IAAA,KAAI,EAAE;QAC9B,aAAa,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC,SAAS,IAAI,EAAE;QAC9C,QAAQ,EAAE,KAAK,CAAC,QAAQ,CAAC,CAAC,MAAM,IAAI,EAAE;KACvC,CAAC;AACJ,CAAC;AATD,QAAA,yBAAA,GAAA,0BASC;AAED,SAAgB,oBAAoB,CAAC,QAAsB,EAAE,WAAiC,QAAQ;IACpG,OAAO,MAAM,CAAC,MAAM,CAAM,QAAQ,CAAC,CAChC,MAAM,EAAC,KAAK,CAAC,EAAE,AAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,SAAS,IAAI,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,MAAM,CAAC,CACxE,GAAG,CAAC,CAAC,KAAK,EAAE,CAAG,CAAD,wBAA0B,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC;AAChE,CAAC;AAJD,QAAA,oBAAA,GAAA,qBAIC","debugId":null}},
    {"offset": {"line": 4788, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 4793, "column": 0}, "map": {"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;AAAA,QAAA,YAAA,4HAAA,SAA0B;AAC1B,QAAA,YAAA,yHAAA,SAAuB;AACvB,QAAA,YAAA,0HAAA,SAAwB;AACxB,QAAA,YAAA,2HAAA,SAAyB;AACzB,QAAA,YAAA,6HAAA,SAA2B","debugId":null}},
    {"offset": {"line": 4803, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}