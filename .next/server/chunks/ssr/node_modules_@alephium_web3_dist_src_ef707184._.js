module.exports = {

"[project]/node_modules/@alephium/web3/dist/src/constants.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.MAP_ENTRY_DEPOSIT = exports.MINIMAL_CONTRACT_DEPOSIT = exports.DEFAULT_GAS_ALPH_AMOUNT = exports.DEFAULT_GAS_ATTOALPH_AMOUNT = exports.DEFAULT_GAS_PRICE = exports.DEFAULT_GAS_AMOUNT = exports.NULL_CONTRACT_ADDRESS = exports.ZERO_ADDRESS = exports.DUST_AMOUNT = exports.ONE_ALPH = exports.ALPH_TOKEN_ID = exports.MIN_UTXO_SET_AMOUNT = exports.TOTAL_NUMBER_OF_CHAINS = exports.TOTAL_NUMBER_OF_GROUPS = void 0;
exports.TOTAL_NUMBER_OF_GROUPS = 4;
exports.TOTAL_NUMBER_OF_CHAINS = exports.TOTAL_NUMBER_OF_GROUPS * exports.TOTAL_NUMBER_OF_GROUPS;
exports.MIN_UTXO_SET_AMOUNT = BigInt(1000000000000);
exports.ALPH_TOKEN_ID = ''.padStart(64, '0');
exports.ONE_ALPH = 10n ** 18n;
exports.DUST_AMOUNT = 10n ** 15n;
/**
 * @deprecated `ZERO_ADDRESS` is deprecated. Use `NULL_CONTRACT_ADDRESS` instead.
 */ exports.ZERO_ADDRESS = 'tgx7VNFoP9DJiFMFgXXtafQZkUvyEdDHT9ryamHJYrjq';
exports.NULL_CONTRACT_ADDRESS = 'tgx7VNFoP9DJiFMFgXXtafQZkUvyEdDHT9ryamHJYrjq';
exports.DEFAULT_GAS_AMOUNT = 20000;
exports.DEFAULT_GAS_PRICE = 10n ** 11n;
exports.DEFAULT_GAS_ATTOALPH_AMOUNT = BigInt(exports.DEFAULT_GAS_AMOUNT) * exports.DEFAULT_GAS_PRICE;
exports.DEFAULT_GAS_ALPH_AMOUNT = 0.002;
exports.MINIMAL_CONTRACT_DEPOSIT = exports.ONE_ALPH / 10n;
exports.MAP_ENTRY_DEPOSIT = exports.ONE_ALPH / 10n;
}}),
"[project]/node_modules/@alephium/web3/dist/src/debug.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.disableContractDebugMessage = exports.enableContractDebugMessage = exports.isContractDebugMessageEnabled = exports.disableDebugMode = exports.enableDebugMode = exports.isDebugModeEnabled = void 0;
let debugModeEnabled = false;
function isDebugModeEnabled() {
    return debugModeEnabled;
}
exports.isDebugModeEnabled = isDebugModeEnabled;
function enableDebugMode() {
    debugModeEnabled = true;
}
exports.enableDebugMode = enableDebugMode;
function disableDebugMode() {
    debugModeEnabled = false;
}
exports.disableDebugMode = disableDebugMode;
let contractDebugMessageEnabled = true;
function isContractDebugMessageEnabled() {
    return contractDebugMessageEnabled;
}
exports.isContractDebugMessageEnabled = isContractDebugMessageEnabled;
function enableContractDebugMessage() {
    contractDebugMessageEnabled = true;
}
exports.enableContractDebugMessage = enableContractDebugMessage;
function disableContractDebugMessage() {
    contractDebugMessageEnabled = false;
}
exports.disableContractDebugMessage = disableContractDebugMessage;
}}),
"[project]/node_modules/@alephium/web3/dist/src/error.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TraceableError = void 0;
class TraceableError extends Error {
    constructor(message, innerError){
        const innerErrorMessage = innerError === undefined ? undefined : innerError instanceof Error ? innerError.message : `${innerError}`;
        super(innerErrorMessage ? `${message}, error: ${innerErrorMessage}` : message);
        this.trace = innerError;
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            Object.setPrototypeOf(this, actualProto);
        } else {
            const object = this;
            object.__proto__ = actualProto;
        }
    }
}
exports.TraceableError = TraceableError;
}}),
"[project]/node_modules/@alephium/web3/dist/src/utils/webcrypto.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.WebCrypto = void 0;
const crypto_1 = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';
class WebCrypto {
    constructor(){
        this.subtle = isBrowser ? globalThis.crypto.subtle : crypto_1.webcrypto ? crypto_1.webcrypto.subtle : crypto.subtle;
    }
    getRandomValues(array) {
        if (!ArrayBuffer.isView(array)) {
            throw new TypeError("Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'");
        }
        const bytes = new Uint8Array(array.buffer, array.byteOffset, array.byteLength);
        if (isBrowser) {
            globalThis.crypto.getRandomValues(bytes);
        } else {
            (0, crypto_1.randomFillSync)(bytes);
        }
        return array;
    }
}
exports.WebCrypto = WebCrypto;
}}),
"[project]/node_modules/@alephium/web3/dist/src/utils/bs58.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.base58ToBytes = exports.isBase58 = exports.bs58 = void 0;
/** This source is under MIT License and come originally from https://github.com/cryptocoinjs/bs58 **/ const base_x_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/base-x/src/index.js [app-ssr] (ecmascript)"));
const error_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/error.js [app-ssr] (ecmascript)");
const ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
exports.bs58 = (0, base_x_1.default)(ALPHABET);
function isBase58(s) {
    if (s === '' || s.trim() === '') {
        return false;
    }
    try {
        return exports.bs58.encode(exports.bs58.decode(s)) === s;
    } catch (err) {
        return false;
    }
}
exports.isBase58 = isBase58;
function base58ToBytes(s) {
    try {
        return exports.bs58.decode(s);
    } catch (e) {
        throw new error_1.TraceableError(`Invalid base58 string ${s}`, e);
    }
}
exports.base58ToBytes = base58ToBytes;
exports.default = exports.bs58;
}}),
"[project]/node_modules/@alephium/web3/dist/src/utils/djb2.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
function djb2(bytes) {
    let hash = 5381;
    for(let i = 0; i < bytes.length; i++){
        hash = (hash << 5) + hash + (bytes[`${i}`] & 0xff);
    }
    return hash;
}
exports.default = djb2;
}}),
"[project]/node_modules/@alephium/web3/dist/src/utils/utils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assertType = exports.xorByte = exports.concatBytes = exports.difficultyToTarget = exports.targetToDifficulty = exports.isDevnet = exports.sleep = exports.hexToString = exports.stringToHex = exports.blockChainIndex = exports.binToHex = exports.hexToBinUnsafe = exports.toNonNegativeBigInt = exports.isHexString = exports.signatureDecode = exports.encodeHexSignature = exports.encodeSignature = exports.networkIds = void 0;
const elliptic_1 = __turbopack_context__.r("[project]/node_modules/elliptic/lib/elliptic.js [app-ssr] (ecmascript)");
const bn_js_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/bn.js/lib/bn.js [app-ssr] (ecmascript)"));
const constants_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/constants.js [app-ssr] (ecmascript)");
exports.networkIds = [
    'mainnet',
    'testnet',
    'devnet'
];
const ec = new elliptic_1.ec('secp256k1');
function encodeSignature(signature) {
    let sNormalized = signature.s;
    if (ec.n && signature.s.cmp(ec.nh) === 1) {
        sNormalized = ec.n.sub(signature.s);
    }
    const r = signature.r.toString('hex', 66).slice(2);
    const s = sNormalized.toString('hex', 66).slice(2);
    return r + s;
}
exports.encodeSignature = encodeSignature;
function encodeHexSignature(rHex, sHex) {
    return encodeSignature({
        r: new bn_js_1.default(rHex, 'hex'),
        s: new bn_js_1.default(sHex, 'hex')
    });
}
exports.encodeHexSignature = encodeHexSignature;
// the signature should be in hex string format for 64 bytes
function signatureDecode(ec, signature) {
    if (signature.length !== 128) {
        throw new Error('Invalid signature length');
    }
    const sHex = signature.slice(64, 128);
    const s = new bn_js_1.default(sHex, 'hex');
    if (ec.n && s.cmp(ec.nh) < 1) {
        const decoded = {
            r: signature.slice(0, 64),
            s: sHex
        };
        return decoded;
    } else {
        throw new Error('The signature is not normalized');
    }
}
exports.signatureDecode = signatureDecode;
function isHexString(input) {
    return input.length % 2 === 0 && /^[0-9a-fA-F]*$/.test(input);
}
exports.isHexString = isHexString;
function toNonNegativeBigInt(input) {
    try {
        const bigIntValue = BigInt(input);
        return bigIntValue < 0n ? undefined : bigIntValue;
    } catch  {
        return undefined;
    }
}
exports.toNonNegativeBigInt = toNonNegativeBigInt;
function hexToBinUnsafe(hex) {
    const bytes = [];
    for(let i = 0; i < hex.length; i += 2){
        bytes.push(parseInt(hex.slice(i, i + 2), 16));
    }
    return new Uint8Array(bytes);
}
exports.hexToBinUnsafe = hexToBinUnsafe;
function binToHex(bin) {
    return Array.from(bin).map((byte)=>byte.toString(16).padStart(2, '0')).join('');
}
exports.binToHex = binToHex;
function blockChainIndex(blockHash) {
    if (blockHash.length != 64) {
        throw Error(`Invalid block hash: ${blockHash}`);
    }
    const rawIndex = Number('0x' + blockHash.slice(-4)) % constants_1.TOTAL_NUMBER_OF_CHAINS;
    return {
        fromGroup: Math.floor(rawIndex / constants_1.TOTAL_NUMBER_OF_GROUPS),
        toGroup: rawIndex % constants_1.TOTAL_NUMBER_OF_GROUPS
    };
}
exports.blockChainIndex = blockChainIndex;
function stringToHex(str) {
    let hex = '';
    for(let i = 0; i < str.length; i++){
        hex += '' + str.charCodeAt(i).toString(16);
    }
    return hex;
}
exports.stringToHex = stringToHex;
function hexToString(str) {
    if (!isHexString(str)) {
        throw new Error(`Invalid hex string: ${str}`);
    }
    const bytes = hexToBinUnsafe(str);
    return new TextDecoder().decode(bytes);
}
exports.hexToString = hexToString;
function sleep(ms) {
    return new Promise((resolve)=>setTimeout(resolve, ms));
}
exports.sleep = sleep;
function isDevnet(networkId) {
    return networkId !== 0 && networkId !== 1;
}
exports.isDevnet = isDevnet;
function targetToDifficulty(compactedTarget) {
    if (!isHexString(compactedTarget) || compactedTarget.length !== 8) {
        throw Error(`Invalid target ${compactedTarget}, expected a hex string of length 8`);
    }
    const size = hexToBinUnsafe(compactedTarget.slice(0, 2))[0];
    const mantissa = BigInt('0x' + compactedTarget.slice(2));
    const maxBigInt = 1n << 256n;
    const target = size <= 3 ? mantissa >> BigInt(8 * (3 - size)) : mantissa << BigInt(8 * (size - 3));
    return maxBigInt / target;
}
exports.targetToDifficulty = targetToDifficulty;
function difficultyToTarget(diff) {
    const maxBigInt = 1n << 256n;
    const target = diff === 1n ? maxBigInt - 1n : maxBigInt / diff;
    const size = Math.floor((target.toString(2).length + 7) / 8);
    const mantissa = Number(size <= 3 ? BigInt.asIntN(32, target) << BigInt(8 * (3 - size)) : BigInt.asIntN(32, target >> BigInt(8 * (size - 3))));
    const mantissaBytes = new Uint8Array(4);
    mantissaBytes[0] = size;
    mantissaBytes[1] = mantissa >> 16 & 0xff;
    mantissaBytes[2] = mantissa >> 8 & 0xff;
    mantissaBytes[3] = mantissa & 0xff;
    return binToHex(mantissaBytes);
}
exports.difficultyToTarget = difficultyToTarget;
function concatBytes(arrays) {
    const totalLength = arrays.reduce((acc, arr)=>acc + arr.length, 0);
    const result = new Uint8Array(totalLength);
    let offset = 0;
    for (const array of arrays){
        result.set(array, offset);
        offset += array.length;
    }
    return result;
}
exports.concatBytes = concatBytes;
function xorByte(intValue) {
    const byte0 = intValue >> 24 & 0xff;
    const byte1 = intValue >> 16 & 0xff;
    const byte2 = intValue >> 8 & 0xff;
    const byte3 = intValue & 0xff;
    return (byte0 ^ byte1 ^ byte2 ^ byte3) & 0xff;
}
exports.xorByte = xorByte;
// eslint-disable-next-line @typescript-eslint/no-empty-function, @typescript-eslint/no-unused-vars
function assertType() {}
exports.assertType = assertType;
}}),
"[project]/node_modules/@alephium/web3/dist/src/utils/subscription.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Subscription = void 0;
const eventemitter3_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/eventemitter3/index.js [app-ssr] (ecmascript)"));
class Subscription {
    constructor(options){
        this.pollingInterval = options.pollingInterval;
        this.messageCallback = options.messageCallback;
        this.errorCallback = options.errorCallback;
        this.task = undefined;
        this.cancelled = false;
        this.eventEmitter = new eventemitter3_1.default();
    }
    subscribe() {
        this.eventEmitter.on('tick', async ()=>{
            await this.polling();
            if (!this.cancelled) {
                this.task = setTimeout(()=>this.eventEmitter.emit('tick'), this.pollingInterval);
            }
        });
        this.eventEmitter.emit('tick');
    }
    unsubscribe() {
        this.eventEmitter.removeAllListeners();
        this.cancelled = true;
        if (typeof this.task !== 'undefined') {
            clearTimeout(this.task);
        }
    }
    isCancelled() {
        return this.cancelled;
    }
}
exports.Subscription = Subscription;
}}),
"[project]/node_modules/@alephium/web3/dist/src/utils/sign.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.verifySignature = exports.sign = void 0;
const elliptic_1 = __turbopack_context__.r("[project]/node_modules/elliptic/lib/elliptic.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const necc = __importStar(__turbopack_context__.r("[project]/node_modules/@noble/secp256k1/lib/index.js [app-ssr] (ecmascript)"));
const crypto_1 = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const ec = new elliptic_1.ec('secp256k1');
necc.utils.sha256Sync = (...messages)=>{
    const sha256 = (0, crypto_1.createHash)('sha256');
    for (const message of messages)sha256.update(message);
    return sha256.digest();
};
necc.utils.hmacSha256Sync = (key, ...messages)=>{
    const hash = (0, crypto_1.createHmac)('sha256', key);
    messages.forEach((m)=>hash.update(m));
    return Uint8Array.from(hash.digest());
};
// hash has to be 32 bytes
function sign(hash, privateKey, _keyType) {
    const keyType = _keyType ?? 'default';
    if (keyType === 'default') {
        const key = ec.keyFromPrivate(privateKey);
        const signature = key.sign(hash);
        return (0, utils_1.encodeSignature)(signature);
    } else {
        const signature = necc.schnorr.signSync((0, utils_1.hexToBinUnsafe)(hash), (0, utils_1.hexToBinUnsafe)(privateKey));
        return (0, utils_1.binToHex)(signature);
    }
}
exports.sign = sign;
function verifySignature(hash, publicKey, signature, _keyType) {
    const keyType = _keyType ?? 'default';
    try {
        if (keyType === 'default') {
            const key = ec.keyFromPublic(publicKey, 'hex');
            return key.verify(hash, (0, utils_1.signatureDecode)(ec, signature));
        } else {
            return necc.schnorr.verifySync((0, utils_1.hexToBinUnsafe)(signature), (0, utils_1.hexToBinUnsafe)(hash), (0, utils_1.hexToBinUnsafe)(publicKey));
        }
    } catch (error) {
        return false;
    }
}
exports.verifySignature = verifySignature;
}}),
"[project]/node_modules/@alephium/web3/dist/src/utils/number.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.number256ToNumber = exports.number256ToBigint = exports.convertAlphAmountWithDecimals = exports.convertAmountWithDecimals = exports.prettifyNumber = exports.prettifyExactAmount = exports.prettifyTokenAmount = exports.prettifyAttoAlphAmount = exports.prettifyNumberConfig = exports.isNumeric = void 0;
// Credits:
// 1. https://github.com/argentlabs/argent-x/blob/e63affa7f28b27333dca4081a3dcd375bb2da40b/packages/extension/src/shared/utils/number.ts
// 2. https://github.com/ethers-io/ethers.js/blob/724881f34d428406488a1c9f9dbebe54b6edecda/src.ts/utils/fixednumber.ts
const bignumber_js_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/bignumber.js/bignumber.js [app-ssr] (ecmascript)"));
const isNumeric = (numToCheck)=>!isNaN(parseFloat(numToCheck)) && isFinite(numToCheck);
exports.isNumeric = isNumeric;
exports.prettifyNumberConfig = {
    ALPH: {
        minDecimalPlaces: 2,
        maxDecimalPlaces: 10,
        minDecimalSignificantDigits: 2,
        decimalPlacesWhenZero: 2
    },
    TOKEN: {
        minDecimalPlaces: 4,
        maxDecimalPlaces: 16,
        minDecimalSignificantDigits: 2,
        decimalPlacesWhenZero: 1
    },
    Exact: {
        minDecimalPlaces: 18,
        maxDecimalPlaces: 18,
        minDecimalSignificantDigits: 0,
        decimalPlacesWhenZero: 0
    }
};
function prettifyAttoAlphAmount(amount) {
    return prettifyNumber(amount, 18, exports.prettifyNumberConfig.ALPH);
}
exports.prettifyAttoAlphAmount = prettifyAttoAlphAmount;
function prettifyTokenAmount(amount, decimals) {
    return prettifyNumber(amount, decimals, exports.prettifyNumberConfig.TOKEN);
}
exports.prettifyTokenAmount = prettifyTokenAmount;
function prettifyExactAmount(amount, decimals) {
    return prettifyNumber(amount, decimals, exports.prettifyNumberConfig.Exact);
}
exports.prettifyExactAmount = prettifyExactAmount;
function prettifyNumber(amount, decimals, config) {
    const number = toFixedNumber(number256ToBigint(amount), decimals);
    if (!(0, exports.isNumeric)(number)) {
        return undefined;
    }
    const numberBN = new bignumber_js_1.default(number);
    let untrimmed;
    if (numberBN.gte(1)) {
        /** simplest case, formatting to minDecimalPlaces will look good */ untrimmed = numberBN.toFormat(config.minDecimalPlaces);
    } else {
        /** now need to interrogate the appearance of decimal number < 1 */ /** longest case - max decimal places e.g. 0.0008923088123 -> 0.0008923088 */ const maxDecimalPlacesString = numberBN.toFormat(config.maxDecimalPlaces);
        /** count the zeros, which will then allow us to know the final length with desired significant digits */ const decimalPart = maxDecimalPlacesString.split('.')[1];
        const zeroMatches = decimalPart?.match(/^0+/);
        const leadingZerosInDecimalPart = zeroMatches && zeroMatches.length ? zeroMatches[0].length : 0;
        /** now we can re-format with leadingZerosInDecimalPart + maxDecimalSignificanDigits to give us the pretty version */ /** e.g. 0.0008923088123 -> 0.00089 */ const prettyDecimalPlaces = Math.max(leadingZerosInDecimalPart + config.minDecimalSignificantDigits, config.minDecimalPlaces);
        untrimmed = numberBN.toFormat(prettyDecimalPlaces);
    }
    /** the untrimmed string may have trailing zeros, e.g. 0.0890 */ /** trim to a minimum specified by the config, e.g. we may want to display $0.00 or 0.0 ETH */ let trimmed = untrimmed.replace(/0+$/, '');
    const minLength = 1 + untrimmed.indexOf('.') + config.decimalPlacesWhenZero;
    if (trimmed.length < minLength) {
        trimmed = untrimmed.substring(0, minLength);
    }
    if (trimmed[trimmed.length - 1] === '.') {
        trimmed = trimmed.slice(0, -1);
    }
    return trimmed;
}
exports.prettifyNumber = prettifyNumber;
const BN_N1 = BigInt(-1);
const BN_0 = BigInt(0);
// Constant to pull zeros from for multipliers
const Zeros = '0000';
function toFixedNumber(val, decimals) {
    let negative = '';
    if (val < BN_0) {
        negative = '-';
        val *= BN_N1;
    }
    let str = val.toString();
    // No decimal point for whole values
    if (decimals === 0) {
        return negative + str;
    }
    // Pad out to the whole component (including a whole digit)
    while(str.length <= decimals){
        str = Zeros + str;
    }
    // Insert the decimal point
    const index = str.length - decimals;
    str = str.substring(0, index) + '.' + str.substring(index);
    // Trim the whole component (leaving at least one 0)
    while(str[0] === '0' && str[1] !== '.'){
        str = str.substring(1);
    }
    // Trim the decimal component (leaving at least one 0)
    while(str[str.length - 1] === '0' && str[str.length - 2] !== '.'){
        str = str.substring(0, str.length - 1);
    }
    return negative + str;
}
function convertAmountWithDecimals(amount, decimals) {
    try {
        const result = new bignumber_js_1.default(amount).multipliedBy(Math.pow(10, decimals));
        return BigInt(result.toFormat(0, {
            groupSeparator: ''
        }));
    } catch (e) {
        return undefined;
    }
}
exports.convertAmountWithDecimals = convertAmountWithDecimals;
// E.g. `1.23` ALPH will be converted to `1230000000000000000`
function convertAlphAmountWithDecimals(amount) {
    return convertAmountWithDecimals(amount, 18);
}
exports.convertAlphAmountWithDecimals = convertAlphAmountWithDecimals;
function number256ToBigint(number) {
    return typeof number === 'string' ? BigInt(number) : number;
}
exports.number256ToBigint = number256ToBigint;
function number256ToNumber(number, decimals) {
    return parseFloat(toFixedNumber(number256ToBigint(number), decimals));
}
exports.number256ToNumber = number256ToNumber;
}}),
"[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/webcrypto.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/bs58.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/djb2.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/utils.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/subscription.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/sign.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/number.js [app-ssr] (ecmascript)"), exports);
}}),
"[project]/node_modules/@alephium/web3/dist/src/api/types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.StdInterfaceIds = exports.request = exports.requestWithLog = exports.forwardRequests = exports.getDefaultPrimitiveValue = exports.decodeArrayType = exports.fromApiPrimitiveVal = exports.toApiVal = exports.toApiArray = exports.toApiAddress = exports.toApiByteVec = exports.fromApiNumber256 = exports.toApiNumber256Optional = exports.toApiNumber256 = exports.toApiBoolean = exports.fromApiTokens = exports.fromApiToken = exports.toApiTokens = exports.toApiToken = exports.PrimitiveTypes = void 0;
const constants_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/constants.js [app-ssr] (ecmascript)");
const debug_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/debug.js [app-ssr] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/error.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
exports.PrimitiveTypes = [
    'U256',
    'I256',
    'Bool',
    'ByteVec',
    'Address'
];
utils_1.assertType;
function toApiToken(token) {
    return {
        id: token.id,
        amount: toApiNumber256(token.amount)
    };
}
exports.toApiToken = toApiToken;
function toApiTokens(tokens) {
    return tokens?.map(toApiToken);
}
exports.toApiTokens = toApiTokens;
function fromApiToken(token) {
    return {
        id: token.id,
        amount: fromApiNumber256(token.amount)
    };
}
exports.fromApiToken = fromApiToken;
function fromApiTokens(tokens) {
    return tokens?.map(fromApiToken);
}
exports.fromApiTokens = fromApiTokens;
function toApiBoolean(v) {
    if (typeof v === 'boolean') {
        return v;
    } else {
        throw new Error(`Invalid boolean value: ${v}`);
    }
}
exports.toApiBoolean = toApiBoolean;
// TODO: check integer bounds
function toApiNumber256(v) {
    if (typeof v === 'number' && Number.isInteger(v) || typeof v === 'bigint') {
        return v.toString();
    } else if (typeof v === 'string') {
        try {
            if (BigInt(v).toString() === v) {
                return v;
            }
        } catch (error) {
            throw new error_1.TraceableError(`Invalid value: ${v}, expected a 256 bit number`, error);
        }
    }
    throw new Error(`Invalid value: ${v}, expected a 256 bit number`);
}
exports.toApiNumber256 = toApiNumber256;
function toApiNumber256Optional(v) {
    return v === undefined ? undefined : toApiNumber256(v);
}
exports.toApiNumber256Optional = toApiNumber256Optional;
function fromApiNumber256(n) {
    return BigInt(n);
}
exports.fromApiNumber256 = fromApiNumber256;
function toApiByteVec(v) {
    if (typeof v !== 'string') {
        throw new Error(`Invalid value: ${v}, expected a hex-string`);
    }
    if ((0, utils_1.isHexString)(v)) return v;
    if ((0, utils_1.isBase58)(v)) {
        // try to convert from address to contract id
        const address = (0, utils_1.base58ToBytes)(v);
        if (address.length === 33 && address[0] === 3) {
            return (0, utils_1.binToHex)(address.slice(1));
        }
    }
    throw new Error(`Invalid hex-string: ${v}`);
}
exports.toApiByteVec = toApiByteVec;
function toApiAddress(v) {
    if (typeof v === 'string') {
        if ((0, utils_1.isBase58)(v)) {
            return v;
        }
        throw new Error(`Invalid base58 string: ${v}`);
    } else {
        throw new Error(`Invalid value: ${v}, expected a base58 string`);
    }
}
exports.toApiAddress = toApiAddress;
function toApiArray(tpe, v) {
    if (!Array.isArray(v)) {
        throw new Error(`Expected array, got ${v}`);
    }
    const semiColonIndex = tpe.lastIndexOf(';');
    if (semiColonIndex == -1) {
        throw new Error(`Invalid Val type: ${tpe}`);
    }
    const subType = tpe.slice(1, semiColonIndex);
    const dim = parseInt(tpe.slice(semiColonIndex + 1, -1));
    if (v.length != dim) {
        throw new Error(`Invalid val dimension: ${v}`);
    } else {
        return {
            value: v.map((v)=>toApiVal(v, subType)),
            type: 'Array'
        };
    }
}
exports.toApiArray = toApiArray;
function toApiVal(v, tpe) {
    if (tpe === 'Bool') {
        return {
            value: toApiBoolean(v),
            type: tpe
        };
    } else if (tpe === 'U256' || tpe === 'I256') {
        return {
            value: toApiNumber256(v),
            type: tpe
        };
    } else if (tpe === 'ByteVec') {
        return {
            value: toApiByteVec(v),
            type: tpe
        };
    } else if (tpe === 'Address') {
        return {
            value: toApiAddress(v),
            type: tpe
        };
    } else {
        return toApiArray(tpe, v);
    }
}
exports.toApiVal = toApiVal;
function fromApiPrimitiveVal(value, tpe, systemEvent = false) {
    if (tpe === 'Bool' && value.type === tpe) {
        return value.value;
    } else if ((tpe === 'U256' || tpe === 'I256') && value.type === tpe) {
        return fromApiNumber256(value.value);
    } else if ((tpe === 'ByteVec' || tpe === 'Address') && (value.type === tpe || systemEvent)) {
        return value.value;
    } else {
        throw new Error(`Expected primitive type, got ${tpe}`);
    }
}
exports.fromApiPrimitiveVal = fromApiPrimitiveVal;
function decodeArrayType(tpe) {
    const semiColonIndex = tpe.lastIndexOf(';');
    if (semiColonIndex === -1) {
        throw new Error(`Invalid array type: ${tpe}`);
    }
    const baseType = tpe.slice(1, semiColonIndex);
    const size = parseInt(tpe.slice(semiColonIndex + 1, -1));
    return [
        baseType,
        size
    ];
}
exports.decodeArrayType = decodeArrayType;
function getDefaultPrimitiveValue(tpe) {
    if (tpe === 'U256' || tpe === 'I256') return 0n;
    if (tpe === 'Bool') return false;
    if (tpe === 'ByteVec') return '';
    if (tpe === 'Address') return constants_1.ZERO_ADDRESS;
    throw Error(`Expected primitive type, got ${tpe}`);
}
exports.getDefaultPrimitiveValue = getDefaultPrimitiveValue;
async function call(args, handler) {
    const debugModeEnabled = (0, debug_1.isDebugModeEnabled)();
    const { path, method, params } = args;
    if (debugModeEnabled) {
        console.log(`[REQUEST] ${path} ${method} ${JSON.stringify(params)}`);
    }
    try {
        const response = await handler(args);
        if (debugModeEnabled) {
            console.log(`[RESPONSE] ${path} ${method} ${JSON.stringify(response)}`);
        }
        return response;
    } catch (error) {
        if (debugModeEnabled) {
            console.error(`[ERROR] ${path} ${method} `, error);
        }
        throw new error_1.TraceableError(`Failed to request ${method}`, error);
    }
}
function forwardRequests(api, handler) {
    // Update class properties to forward requests
    for (const [path, pathObject] of Object.entries(api)){
        for (const method of Object.keys(pathObject)){
            pathObject[`${method}`] = async (...params)=>{
                return call({
                    path,
                    method,
                    params
                }, handler);
            };
        }
    }
}
exports.forwardRequests = forwardRequests;
function requestWithLog(api) {
    for (const [path, pathObject] of Object.entries(api)){
        for (const [method, handler] of Object.entries(pathObject)){
            pathObject[`${method}`] = async (...params)=>{
                return call({
                    path,
                    method,
                    params
                }, ()=>handler(...params));
            };
        }
    }
}
exports.requestWithLog = requestWithLog;
async function request(provider, args) {
    const call = provider[`${args.path}`][`${args.method}`];
    return call(...args.params);
}
exports.request = request;
var StdInterfaceIds;
(function(StdInterfaceIds) {
    StdInterfaceIds["FungibleToken"] = "0001";
    StdInterfaceIds["NFTCollection"] = "0002";
    StdInterfaceIds["NFT"] = "0003";
    StdInterfaceIds["NFTCollectionWithRoyalty"] = "000201";
})(StdInterfaceIds = exports.StdInterfaceIds || (exports.StdInterfaceIds = {}));
}}),
"[project]/node_modules/@alephium/web3/dist/src/api/utils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isBalanceEqual = exports.convertHttpResponse = void 0;
__turbopack_context__.r("[project]/node_modules/cross-fetch/dist/node-polyfill.js [app-ssr] (ecmascript)");
function convertHttpResponse(response) {
    if (response.error) {
        const errorMessage = response.error.detail ?? `Unknown error`;
        throw new Error(`[API Error] - ${errorMessage} - Status code: ${response.status}`);
    } else {
        return response.data;
    }
}
exports.convertHttpResponse = convertHttpResponse;
function isBalanceEqual(b0, b1) {
    const isTokenBalanceEqual = (tokens0, tokens1)=>{
        const tokens0Size = tokens0?.length ?? 0;
        const tokens1Size = tokens1?.length ?? 0;
        if (tokens0Size !== tokens1Size) return false;
        if (tokens0Size === 0) return true;
        const _tokens1 = tokens1.map((t)=>({
                ...t,
                used: false
            }));
        return tokens0.every((t0)=>{
            const t1 = _tokens1.find((t)=>!t.used && t0.id === t.id && t0.amount === t.amount);
            if (t1 === undefined) return false;
            t1.used = true;
            return true;
        });
    };
    const isAlphBalanceEqual = b0.balance === b1.balance && b0.lockedBalance === b1.lockedBalance;
    return b0.utxoNum === b1.utxoNum && isAlphBalanceEqual && isTokenBalanceEqual(b0.tokenBalances, b1.tokenBalances) && isTokenBalanceEqual(b0.lockedTokenBalances, b1.lockedTokenBalances);
}
exports.isBalanceEqual = isBalanceEqual;
}}),
"[project]/node_modules/@alephium/web3/dist/src/api/api-alephium.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* eslint-disable */ /* tslint:disable */ /*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Api = exports.HttpClient = exports.ContentType = void 0;
__turbopack_context__.r("[project]/node_modules/cross-fetch/dist/node-polyfill.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/utils.js [app-ssr] (ecmascript)");
var ContentType;
(function(ContentType) {
    ContentType["Json"] = "application/json";
    ContentType["FormData"] = "multipart/form-data";
    ContentType["UrlEncoded"] = "application/x-www-form-urlencoded";
    ContentType["Text"] = "text/plain";
})(ContentType = exports.ContentType || (exports.ContentType = {}));
class HttpClient {
    constructor(apiConfig = {}){
        this.baseUrl = '../';
        this.securityData = null;
        this.abortControllers = new Map();
        this.customFetch = (...fetchParams)=>fetch(...fetchParams);
        this.baseApiParams = {
            credentials: 'same-origin',
            headers: {},
            redirect: 'follow',
            referrerPolicy: 'no-referrer'
        };
        this.setSecurityData = (data)=>{
            this.securityData = data;
        };
        this.contentFormatters = {
            [ContentType.Json]: (input)=>input !== null && (typeof input === 'object' || typeof input === 'string') ? JSON.stringify(input) : input,
            [ContentType.Text]: (input)=>input !== null && typeof input !== 'string' ? JSON.stringify(input) : input,
            [ContentType.FormData]: (input)=>Object.keys(input || {}).reduce((formData, key)=>{
                    const property = input[key];
                    formData.append(key, property instanceof Blob ? property : typeof property === 'object' && property !== null ? JSON.stringify(property) : `${property}`);
                    return formData;
                }, new FormData()),
            [ContentType.UrlEncoded]: (input)=>this.toQueryString(input)
        };
        this.createAbortSignal = (cancelToken)=>{
            if (this.abortControllers.has(cancelToken)) {
                const abortController = this.abortControllers.get(cancelToken);
                if (abortController) {
                    return abortController.signal;
                }
                return void 0;
            }
            const abortController = new AbortController();
            this.abortControllers.set(cancelToken, abortController);
            return abortController.signal;
        };
        this.abortRequest = (cancelToken)=>{
            const abortController = this.abortControllers.get(cancelToken);
            if (abortController) {
                abortController.abort();
                this.abortControllers.delete(cancelToken);
            }
        };
        this.request = async ({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params })=>{
            const secureParams = (typeof secure === 'boolean' ? secure : this.baseApiParams.secure) && this.securityWorker && await this.securityWorker(this.securityData) || {};
            const requestParams = this.mergeRequestParams(params, secureParams);
            const queryString = query && this.toQueryString(query);
            const payloadFormatter = this.contentFormatters[type || ContentType.Json];
            const responseFormat = format || requestParams.format;
            return this.customFetch(`${baseUrl || this.baseUrl || ''}${path}${queryString ? `?${queryString}` : ''}`, {
                ...requestParams,
                headers: {
                    ...requestParams.headers || {},
                    ...type && type !== ContentType.FormData ? {
                        'Content-Type': type
                    } : {}
                },
                signal: cancelToken ? this.createAbortSignal(cancelToken) : requestParams.signal,
                body: typeof body === 'undefined' || body === null ? null : payloadFormatter(body)
            }).then(async (response)=>{
                const r = response;
                r.data = null;
                r.error = null;
                const data = !responseFormat ? r : await response[responseFormat]().then((data)=>{
                    if (r.ok) {
                        r.data = data;
                    } else {
                        r.error = data;
                    }
                    return r;
                }).catch((e)=>{
                    r.error = e;
                    return r;
                });
                if (cancelToken) {
                    this.abortControllers.delete(cancelToken);
                }
                return data;
            });
        };
        Object.assign(this, apiConfig);
    }
    encodeQueryParam(key, value) {
        const encodedKey = encodeURIComponent(key);
        return `${encodedKey}=${encodeURIComponent(typeof value === 'number' ? value : `${value}`)}`;
    }
    addQueryParam(query, key) {
        return this.encodeQueryParam(key, query[key]);
    }
    addArrayQueryParam(query, key) {
        const value = query[key];
        return value.map((v)=>this.encodeQueryParam(key, v)).join('&');
    }
    toQueryString(rawQuery) {
        const query = rawQuery || {};
        const keys = Object.keys(query).filter((key)=>'undefined' !== typeof query[key]);
        return keys.map((key)=>Array.isArray(query[key]) ? this.addArrayQueryParam(query, key) : this.addQueryParam(query, key)).join('&');
    }
    addQueryParams(rawQuery) {
        const queryString = this.toQueryString(rawQuery);
        return queryString ? `?${queryString}` : '';
    }
    mergeRequestParams(params1, params2) {
        return {
            ...this.baseApiParams,
            ...params1,
            ...params2 || {},
            headers: {
                ...this.baseApiParams.headers || {},
                ...params1.headers || {},
                ...params2 && params2.headers || {}
            }
        };
    }
}
exports.HttpClient = HttpClient;
/**
 * @title Alephium API
 * @version 3.12.2
 * @baseUrl ../
 */ class Api extends HttpClient {
    constructor(){
        super(...arguments);
        this.wallets = {
            /**
             * No description
             *
             * @tags Wallets
             * @name GetWallets
             * @summary List available wallets
             * @request GET:/wallets
             */ getWallets: (params = {})=>this.request({
                    path: `/wallets`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name PutWallets
             * @summary Restore a wallet from your mnemonic
             * @request PUT:/wallets
             */ putWallets: (data, params = {})=>this.request({
                    path: `/wallets`,
                    method: 'PUT',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description A new wallet will be created and respond with a mnemonic. Make sure to keep that mnemonic safely as it will allows you to recover your wallet. Default mnemonic size is 24, (options: 12, 15, 18, 21, 24).
             *
             * @tags Wallets
             * @name PostWallets
             * @summary Create a new wallet
             * @request POST:/wallets
             */ postWallets: (data, params = {})=>this.request({
                    path: `/wallets`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name GetWalletsWalletName
             * @summary Get wallet's status
             * @request GET:/wallets/{wallet_name}
             */ getWalletsWalletName: (walletName, params = {})=>this.request({
                    path: `/wallets/${walletName}`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name DeleteWalletsWalletName
             * @summary Delete your wallet file (can be recovered with your mnemonic)
             * @request DELETE:/wallets/{wallet_name}
             */ deleteWalletsWalletName: (walletName, query, params = {})=>this.request({
                    path: `/wallets/${walletName}`,
                    method: 'DELETE',
                    query: query,
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name PostWalletsWalletNameLock
             * @summary Lock your wallet
             * @request POST:/wallets/{wallet_name}/lock
             */ postWalletsWalletNameLock: (walletName, params = {})=>this.request({
                    path: `/wallets/${walletName}/lock`,
                    method: 'POST',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name PostWalletsWalletNameUnlock
             * @summary Unlock your wallet
             * @request POST:/wallets/{wallet_name}/unlock
             */ postWalletsWalletNameUnlock: (walletName, data, params = {})=>this.request({
                    path: `/wallets/${walletName}/unlock`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name GetWalletsWalletNameBalances
             * @summary Get your total balance
             * @request GET:/wallets/{wallet_name}/balances
             */ getWalletsWalletNameBalances: (walletName, params = {})=>this.request({
                    path: `/wallets/${walletName}/balances`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name PostWalletsWalletNameRevealMnemonic
             * @summary Reveal your mnemonic. !!! use it with caution !!!
             * @request POST:/wallets/{wallet_name}/reveal-mnemonic
             */ postWalletsWalletNameRevealMnemonic: (walletName, data, params = {})=>this.request({
                    path: `/wallets/${walletName}/reveal-mnemonic`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name PostWalletsWalletNameTransfer
             * @summary Transfer ALPH from the active address
             * @request POST:/wallets/{wallet_name}/transfer
             */ postWalletsWalletNameTransfer: (walletName, data, params = {})=>this.request({
                    path: `/wallets/${walletName}/transfer`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name PostWalletsWalletNameSweepActiveAddress
             * @summary Transfer all unlocked ALPH from the active address to another address
             * @request POST:/wallets/{wallet_name}/sweep-active-address
             */ postWalletsWalletNameSweepActiveAddress: (walletName, data, params = {})=>this.request({
                    path: `/wallets/${walletName}/sweep-active-address`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name PostWalletsWalletNameSweepAllAddresses
             * @summary Transfer unlocked ALPH from all addresses (including all mining addresses if applicable) to another address
             * @request POST:/wallets/{wallet_name}/sweep-all-addresses
             */ postWalletsWalletNameSweepAllAddresses: (walletName, data, params = {})=>this.request({
                    path: `/wallets/${walletName}/sweep-all-addresses`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name PostWalletsWalletNameSign
             * @summary Sign the given data and return back the signature
             * @request POST:/wallets/{wallet_name}/sign
             */ postWalletsWalletNameSign: (walletName, data, params = {})=>this.request({
                    path: `/wallets/${walletName}/sign`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name GetWalletsWalletNameAddresses
             * @summary List all your wallet's addresses
             * @request GET:/wallets/{wallet_name}/addresses
             */ getWalletsWalletNameAddresses: (walletName, params = {})=>this.request({
                    path: `/wallets/${walletName}/addresses`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name GetWalletsWalletNameAddressesAddress
             * @summary Get address' info
             * @request GET:/wallets/{wallet_name}/addresses/{address}
             */ getWalletsWalletNameAddressesAddress: (walletName, address, params = {})=>this.request({
                    path: `/wallets/${walletName}/addresses/${address}`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description This endpoint can only be called if the wallet was created with the `isMiner = true` flag
             *
             * @tags Miners
             * @name GetWalletsWalletNameMinerAddresses
             * @summary List all miner addresses per group
             * @request GET:/wallets/{wallet_name}/miner-addresses
             */ getWalletsWalletNameMinerAddresses: (walletName, params = {})=>this.request({
                    path: `/wallets/${walletName}/miner-addresses`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Cannot be called from a miner wallet
             *
             * @tags Wallets
             * @name PostWalletsWalletNameDeriveNextAddress
             * @summary Derive your next address
             * @request POST:/wallets/{wallet_name}/derive-next-address
             */ postWalletsWalletNameDeriveNextAddress: (walletName, query, params = {})=>this.request({
                    path: `/wallets/${walletName}/derive-next-address`,
                    method: 'POST',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Your wallet need to have been created with the miner flag set to true
             *
             * @tags Miners
             * @name PostWalletsWalletNameDeriveNextMinerAddresses
             * @summary Derive your next miner addresses for each group
             * @request POST:/wallets/{wallet_name}/derive-next-miner-addresses
             */ postWalletsWalletNameDeriveNextMinerAddresses: (walletName, params = {})=>this.request({
                    path: `/wallets/${walletName}/derive-next-miner-addresses`,
                    method: 'POST',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Wallets
             * @name PostWalletsWalletNameChangeActiveAddress
             * @summary Choose the active address
             * @request POST:/wallets/{wallet_name}/change-active-address
             */ postWalletsWalletNameChangeActiveAddress: (walletName, data, params = {})=>this.request({
                    path: `/wallets/${walletName}/change-active-address`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.infos = {
            /**
             * No description
             *
             * @tags Infos
             * @name GetInfosNode
             * @summary Get info about that node
             * @request GET:/infos/node
             */ getInfosNode: (params = {})=>this.request({
                    path: `/infos/node`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Infos
             * @name GetInfosVersion
             * @summary Get version about that node
             * @request GET:/infos/version
             */ getInfosVersion: (params = {})=>this.request({
                    path: `/infos/version`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Infos
             * @name GetInfosChainParams
             * @summary Get key params about your blockchain
             * @request GET:/infos/chain-params
             */ getInfosChainParams: (params = {})=>this.request({
                    path: `/infos/chain-params`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Infos
             * @name GetInfosSelfClique
             * @summary Get info about your own clique
             * @request GET:/infos/self-clique
             */ getInfosSelfClique: (params = {})=>this.request({
                    path: `/infos/self-clique`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Infos
             * @name GetInfosInterCliquePeerInfo
             * @summary Get infos about the inter cliques
             * @request GET:/infos/inter-clique-peer-info
             */ getInfosInterCliquePeerInfo: (params = {})=>this.request({
                    path: `/infos/inter-clique-peer-info`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Infos
             * @name GetInfosDiscoveredNeighbors
             * @summary Get discovered neighbors
             * @request GET:/infos/discovered-neighbors
             */ getInfosDiscoveredNeighbors: (params = {})=>this.request({
                    path: `/infos/discovered-neighbors`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Infos
             * @name GetInfosMisbehaviors
             * @summary Get the misbehaviors of peers
             * @request GET:/infos/misbehaviors
             */ getInfosMisbehaviors: (params = {})=>this.request({
                    path: `/infos/misbehaviors`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Infos
             * @name PostInfosMisbehaviors
             * @summary Ban/Unban given peers
             * @request POST:/infos/misbehaviors
             */ postInfosMisbehaviors: (data, params = {})=>this.request({
                    path: `/infos/misbehaviors`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Infos
             * @name GetInfosUnreachable
             * @summary Get the unreachable brokers
             * @request GET:/infos/unreachable
             */ getInfosUnreachable: (params = {})=>this.request({
                    path: `/infos/unreachable`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Infos
             * @name PostInfosDiscovery
             * @summary Set brokers to be unreachable/reachable
             * @request POST:/infos/discovery
             */ postInfosDiscovery: (data, params = {})=>this.request({
                    path: `/infos/discovery`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Infos
             * @name GetInfosHistoryHashrate
             * @summary Get history average hashrate on the given time interval
             * @request GET:/infos/history-hashrate
             */ getInfosHistoryHashrate: (query, params = {})=>this.request({
                    path: `/infos/history-hashrate`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Infos
             * @name GetInfosCurrentHashrate
             * @summary Get average hashrate from `now - timespan(millis)` to `now`
             * @request GET:/infos/current-hashrate
             */ getInfosCurrentHashrate: (query, params = {})=>this.request({
                    path: `/infos/current-hashrate`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Infos
             * @name GetInfosCurrentDifficulty
             * @summary Get the average difficulty of the latest blocks from all shards
             * @request GET:/infos/current-difficulty
             */ getInfosCurrentDifficulty: (params = {})=>this.request({
                    path: `/infos/current-difficulty`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.blockflow = {
            /**
             * No description
             *
             * @tags Blockflow
             * @name GetBlockflowBlocks
             * @summary List blocks on the given time interval
             * @request GET:/blockflow/blocks
             */ getBlockflowBlocks: (query, params = {})=>this.request({
                    path: `/blockflow/blocks`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Blockflow
             * @name GetBlockflowBlocksWithEvents
             * @summary List blocks with events on the given time interval
             * @request GET:/blockflow/blocks-with-events
             */ getBlockflowBlocksWithEvents: (query, params = {})=>this.request({
                    path: `/blockflow/blocks-with-events`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Blockflow
             * @name GetBlockflowRichBlocks
             * @summary Given a time interval, list blocks containing events and transactions with enriched input information when node indexes are enabled.
             * @request GET:/blockflow/rich-blocks
             */ getBlockflowRichBlocks: (query, params = {})=>this.request({
                    path: `/blockflow/rich-blocks`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Blockflow
             * @name GetBlockflowBlocksBlockHash
             * @summary Get a block with hash
             * @request GET:/blockflow/blocks/{block_hash}
             */ getBlockflowBlocksBlockHash: (blockHash, params = {})=>this.request({
                    path: `/blockflow/blocks/${blockHash}`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Blockflow
             * @name GetBlockflowMainChainBlockByGhostUncleGhostUncleHash
             * @summary Get a mainchain block by ghost uncle hash
             * @request GET:/blockflow/main-chain-block-by-ghost-uncle/{ghost_uncle_hash}
             */ getBlockflowMainChainBlockByGhostUncleGhostUncleHash: (ghostUncleHash, params = {})=>this.request({
                    path: `/blockflow/main-chain-block-by-ghost-uncle/${ghostUncleHash}`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Blockflow
             * @name GetBlockflowBlocksWithEventsBlockHash
             * @summary Get a block and events with hash
             * @request GET:/blockflow/blocks-with-events/{block_hash}
             */ getBlockflowBlocksWithEventsBlockHash: (blockHash, params = {})=>this.request({
                    path: `/blockflow/blocks-with-events/${blockHash}`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Blockflow
             * @name GetBlockflowRichBlocksBlockHash
             * @summary Get a block containing events and transactions with enriched input information when node indexes are enabled.
             * @request GET:/blockflow/rich-blocks/{block_hash}
             */ getBlockflowRichBlocksBlockHash: (blockHash, params = {})=>this.request({
                    path: `/blockflow/rich-blocks/${blockHash}`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Blockflow
             * @name GetBlockflowIsBlockInMainChain
             * @summary Check if the block is in main chain
             * @request GET:/blockflow/is-block-in-main-chain
             */ getBlockflowIsBlockInMainChain: (query, params = {})=>this.request({
                    path: `/blockflow/is-block-in-main-chain`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Blockflow
             * @name GetBlockflowHashes
             * @summary Get all block's hashes at given height for given groups
             * @request GET:/blockflow/hashes
             */ getBlockflowHashes: (query, params = {})=>this.request({
                    path: `/blockflow/hashes`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Blockflow
             * @name GetBlockflowChainInfo
             * @summary Get infos about the chain from the given groups
             * @request GET:/blockflow/chain-info
             */ getBlockflowChainInfo: (query, params = {})=>this.request({
                    path: `/blockflow/chain-info`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Blockflow
             * @name GetBlockflowHeadersBlockHash
             * @summary Get block header
             * @request GET:/blockflow/headers/{block_hash}
             */ getBlockflowHeadersBlockHash: (blockHash, params = {})=>this.request({
                    path: `/blockflow/headers/${blockHash}`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Blockflow
             * @name GetBlockflowRawBlocksBlockHash
             * @summary Get raw block in hex format
             * @request GET:/blockflow/raw-blocks/{block_hash}
             */ getBlockflowRawBlocksBlockHash: (blockHash, params = {})=>this.request({
                    path: `/blockflow/raw-blocks/${blockHash}`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.addresses = {
            /**
             * No description
             *
             * @tags Addresses
             * @name GetAddressesAddressBalance
             * @summary Get the balance of an address
             * @request GET:/addresses/{address}/balance
             */ getAddressesAddressBalance: (address, query, params = {})=>this.request({
                    path: `/addresses/${address}/balance`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Addresses
             * @name GetAddressesAddressUtxos
             * @summary Get the UTXOs of an address
             * @request GET:/addresses/{address}/utxos
             */ getAddressesAddressUtxos: (address, params = {})=>this.request({
                    path: `/addresses/${address}/utxos`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Addresses
             * @name GetAddressesAddressGroup
             * @summary Get the group of an address
             * @request GET:/addresses/{address}/group
             */ getAddressesAddressGroup: (address, params = {})=>this.request({
                    path: `/addresses/${address}/group`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.transactions = {
            /**
             * No description
             *
             * @tags Transactions
             * @name PostTransactionsBuild
             * @summary Build an unsigned transfer transaction to a number of recipients
             * @request POST:/transactions/build
             */ postTransactionsBuild: (data, params = {})=>this.request({
                    path: `/transactions/build`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Transactions
             * @name PostTransactionsBuildTransferFromOneToManyGroups
             * @summary Build unsigned transfer transactions from an address of one group to addresses of many groups. Each target group requires a dedicated transaction or more in case large number of outputs needed to be split.
             * @request POST:/transactions/build-transfer-from-one-to-many-groups
             */ postTransactionsBuildTransferFromOneToManyGroups: (data, params = {})=>this.request({
                    path: `/transactions/build-transfer-from-one-to-many-groups`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Transactions
             * @name PostTransactionsBuildMultiAddresses
             * @summary Build an unsigned transaction with multiple addresses to a number of recipients
             * @request POST:/transactions/build-multi-addresses
             */ postTransactionsBuildMultiAddresses: (data, params = {})=>this.request({
                    path: `/transactions/build-multi-addresses`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Transactions
             * @name PostTransactionsSweepAddressBuild
             * @summary Build unsigned transactions to send all unlocked ALPH and token balances of one address to another address
             * @request POST:/transactions/sweep-address/build
             */ postTransactionsSweepAddressBuild: (data, params = {})=>this.request({
                    path: `/transactions/sweep-address/build`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Transactions
             * @name PostTransactionsSubmit
             * @summary Submit a signed transaction
             * @request POST:/transactions/submit
             */ postTransactionsSubmit: (data, params = {})=>this.request({
                    path: `/transactions/submit`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Transactions
             * @name PostTransactionsDecodeUnsignedTx
             * @summary Decode an unsigned transaction
             * @request POST:/transactions/decode-unsigned-tx
             */ postTransactionsDecodeUnsignedTx: (data, params = {})=>this.request({
                    path: `/transactions/decode-unsigned-tx`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Transactions
             * @name GetTransactionsDetailsTxid
             * @summary Get transaction details
             * @request GET:/transactions/details/{txId}
             */ getTransactionsDetailsTxid: (txId, query, params = {})=>this.request({
                    path: `/transactions/details/${txId}`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Transactions
             * @name GetTransactionsRichDetailsTxid
             * @summary Get transaction with enriched input information when node indexes are enabled.
             * @request GET:/transactions/rich-details/{txId}
             */ getTransactionsRichDetailsTxid: (txId, query, params = {})=>this.request({
                    path: `/transactions/rich-details/${txId}`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Transactions
             * @name GetTransactionsRawTxid
             * @summary Get raw transaction in hex format
             * @request GET:/transactions/raw/{txId}
             */ getTransactionsRawTxid: (txId, query, params = {})=>this.request({
                    path: `/transactions/raw/${txId}`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Transactions
             * @name GetTransactionsStatus
             * @summary Get tx status
             * @request GET:/transactions/status
             */ getTransactionsStatus: (query, params = {})=>this.request({
                    path: `/transactions/status`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Transactions
             * @name GetTransactionsTxIdFromOutputref
             * @summary Get transaction id from transaction output ref
             * @request GET:/transactions/tx-id-from-outputref
             */ getTransactionsTxIdFromOutputref: (query, params = {})=>this.request({
                    path: `/transactions/tx-id-from-outputref`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Transactions
             * @name PostTransactionsBuildChained
             * @summary Build a chain of transactions
             * @request POST:/transactions/build-chained
             */ postTransactionsBuildChained: (data, params = {})=>this.request({
                    path: `/transactions/build-chained`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.mempool = {
            /**
             * No description
             *
             * @tags Mempool
             * @name GetMempoolTransactions
             * @summary List mempool transactions
             * @request GET:/mempool/transactions
             */ getMempoolTransactions: (params = {})=>this.request({
                    path: `/mempool/transactions`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Mempool
             * @name DeleteMempoolTransactions
             * @summary Remove all transactions from mempool
             * @request DELETE:/mempool/transactions
             */ deleteMempoolTransactions: (params = {})=>this.request({
                    path: `/mempool/transactions`,
                    method: 'DELETE',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Mempool
             * @name PutMempoolTransactionsRebroadcast
             * @summary Rebroadcase a mempool transaction to the network
             * @request PUT:/mempool/transactions/rebroadcast
             */ putMempoolTransactionsRebroadcast: (query, params = {})=>this.request({
                    path: `/mempool/transactions/rebroadcast`,
                    method: 'PUT',
                    query: query,
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Mempool
             * @name PutMempoolTransactionsValidate
             * @summary Validate all mempool transactions and remove invalid ones
             * @request PUT:/mempool/transactions/validate
             */ putMempoolTransactionsValidate: (params = {})=>this.request({
                    path: `/mempool/transactions/validate`,
                    method: 'PUT',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.contracts = {
            /**
             * No description
             *
             * @tags Contracts
             * @name PostContractsCompileScript
             * @summary Compile a script
             * @request POST:/contracts/compile-script
             */ postContractsCompileScript: (data, params = {})=>this.request({
                    path: `/contracts/compile-script`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name PostContractsUnsignedTxExecuteScript
             * @summary Build an unsigned script
             * @request POST:/contracts/unsigned-tx/execute-script
             */ postContractsUnsignedTxExecuteScript: (data, params = {})=>this.request({
                    path: `/contracts/unsigned-tx/execute-script`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name PostContractsCompileContract
             * @summary Compile a smart contract
             * @request POST:/contracts/compile-contract
             */ postContractsCompileContract: (data, params = {})=>this.request({
                    path: `/contracts/compile-contract`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name PostContractsCompileProject
             * @summary Compile a project
             * @request POST:/contracts/compile-project
             */ postContractsCompileProject: (data, params = {})=>this.request({
                    path: `/contracts/compile-project`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name PostContractsUnsignedTxDeployContract
             * @summary Build an unsigned contract
             * @request POST:/contracts/unsigned-tx/deploy-contract
             */ postContractsUnsignedTxDeployContract: (data, params = {})=>this.request({
                    path: `/contracts/unsigned-tx/deploy-contract`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name GetContractsAddressState
             * @summary Get contract state
             * @request GET:/contracts/{address}/state
             */ getContractsAddressState: (address, params = {})=>this.request({
                    path: `/contracts/${address}/state`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name GetContractsCodehashCode
             * @summary Get contract code by code hash
             * @request GET:/contracts/{codeHash}/code
             */ getContractsCodehashCode: (codeHash, params = {})=>this.request({
                    path: `/contracts/${codeHash}/code`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name PostContractsTestContract
             * @summary Test contract
             * @request POST:/contracts/test-contract
             */ postContractsTestContract: (data, params = {})=>this.request({
                    path: `/contracts/test-contract`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name PostContractsCallContract
             * @summary Call contract
             * @request POST:/contracts/call-contract
             */ postContractsCallContract: (data, params = {})=>this.request({
                    path: `/contracts/call-contract`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name PostContractsMulticallContract
             * @summary Multiple call contract
             * @request POST:/contracts/multicall-contract
             */ postContractsMulticallContract: (data, params = {})=>this.request({
                    path: `/contracts/multicall-contract`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name GetContractsAddressParent
             * @summary Get parent contract address
             * @request GET:/contracts/{address}/parent
             */ getContractsAddressParent: (address, params = {})=>this.request({
                    path: `/contracts/${address}/parent`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name GetContractsAddressSubContracts
             * @summary Get sub-contract addresses
             * @request GET:/contracts/{address}/sub-contracts
             */ getContractsAddressSubContracts: (address, query, params = {})=>this.request({
                    path: `/contracts/${address}/sub-contracts`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name GetContractsAddressSubContractsCurrentCount
             * @summary Get current value of the sub-contracts counter for a contract
             * @request GET:/contracts/{address}/sub-contracts/current-count
             */ getContractsAddressSubContractsCurrentCount: (address, params = {})=>this.request({
                    path: `/contracts/${address}/sub-contracts/current-count`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Contracts
             * @name PostContractsCallTxScript
             * @summary Call TxScript
             * @request POST:/contracts/call-tx-script
             */ postContractsCallTxScript: (data, params = {})=>this.request({
                    path: `/contracts/call-tx-script`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.multisig = {
            /**
             * No description
             *
             * @tags Multi-signature
             * @name PostMultisigAddress
             * @summary Create the multisig address and unlock script
             * @request POST:/multisig/address
             */ postMultisigAddress: (data, params = {})=>this.request({
                    path: `/multisig/address`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Multi-signature
             * @name PostMultisigBuild
             * @summary Build a multisig unsigned transaction
             * @request POST:/multisig/build
             */ postMultisigBuild: (data, params = {})=>this.request({
                    path: `/multisig/build`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Multi-signature
             * @name PostMultisigSweep
             * @summary Sweep all unlocked ALPH and token balances of a multisig address to another address
             * @request POST:/multisig/sweep
             */ postMultisigSweep: (data, params = {})=>this.request({
                    path: `/multisig/sweep`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Multi-signature
             * @name PostMultisigSubmit
             * @summary Submit a multi-signed transaction
             * @request POST:/multisig/submit
             */ postMultisigSubmit: (data, params = {})=>this.request({
                    path: `/multisig/submit`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.miners = {
            /**
             * No description
             *
             * @tags Miners
             * @name PostMinersCpuMining
             * @summary Execute an action on CPU miner. !!! for test only !!!
             * @request POST:/miners/cpu-mining
             */ postMinersCpuMining: (query, params = {})=>this.request({
                    path: `/miners/cpu-mining`,
                    method: 'POST',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Miners
             * @name PostMinersCpuMiningMineOneBlock
             * @summary Mine a block on CPU miner. !!! for test only !!!
             * @request POST:/miners/cpu-mining/mine-one-block
             */ postMinersCpuMiningMineOneBlock: (query, params = {})=>this.request({
                    path: `/miners/cpu-mining/mine-one-block`,
                    method: 'POST',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Miners
             * @name GetMinersAddresses
             * @summary List miner's addresses
             * @request GET:/miners/addresses
             */ getMinersAddresses: (params = {})=>this.request({
                    path: `/miners/addresses`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Miners
             * @name PutMinersAddresses
             * @summary Update miner's addresses, but better to use user.conf instead
             * @request PUT:/miners/addresses
             */ putMinersAddresses: (data, params = {})=>this.request({
                    path: `/miners/addresses`,
                    method: 'PUT',
                    body: data,
                    type: ContentType.Json,
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.events = {
            /**
             * No description
             *
             * @tags Events
             * @name GetEventsContractContractaddress
             * @summary Get events for a contract within a counter range
             * @request GET:/events/contract/{contractAddress}
             */ getEventsContractContractaddress: (contractAddress, query, params = {})=>this.request({
                    path: `/events/contract/${contractAddress}`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Events
             * @name GetEventsContractContractaddressCurrentCount
             * @summary Get current value of the events counter for a contract
             * @request GET:/events/contract/{contractAddress}/current-count
             */ getEventsContractContractaddressCurrentCount: (contractAddress, params = {})=>this.request({
                    path: `/events/contract/${contractAddress}/current-count`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Events
             * @name GetEventsTxIdTxid
             * @summary Get contract events for a transaction
             * @request GET:/events/tx-id/{txId}
             */ getEventsTxIdTxid: (txId, query, params = {})=>this.request({
                    path: `/events/tx-id/${txId}`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Events
             * @name GetEventsBlockHashBlockhash
             * @summary Get contract events for a block
             * @request GET:/events/block-hash/{blockHash}
             */ getEventsBlockHashBlockhash: (blockHash, query, params = {})=>this.request({
                    path: `/events/block-hash/${blockHash}`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.utils = {
            /**
             * No description
             *
             * @tags Utils
             * @name PostUtilsVerifySignature
             * @summary Verify the SecP256K1 signature of some data
             * @request POST:/utils/verify-signature
             */ postUtilsVerifySignature: (data, params = {})=>this.request({
                    path: `/utils/verify-signature`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Utils
             * @name PostUtilsTargetToHashrate
             * @summary Convert a target to hashrate
             * @request POST:/utils/target-to-hashrate
             */ postUtilsTargetToHashrate: (data, params = {})=>this.request({
                    path: `/utils/target-to-hashrate`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Utils
             * @name PutUtilsCheckHashIndexing
             * @summary Check and repair the indexing of block hashes
             * @request PUT:/utils/check-hash-indexing
             */ putUtilsCheckHashIndexing: (params = {})=>this.request({
                    path: `/utils/check-hash-indexing`,
                    method: 'PUT',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
    }
}
exports.Api = Api;
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/reader.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Reader = void 0;
class Reader {
    constructor(bytes){
        this.index = 0;
        this.bytes = bytes;
    }
    consumeByte() {
        if (this.index >= this.bytes.length) {
            throw new Error(`Index out of range: unable to consume byte at index ${this.index}, data length: ${this.bytes.length}`);
        }
        const byte = this.bytes[`${this.index}`];
        this.index += 1;
        return byte;
    }
    consumeBytes(num) {
        const from = this.index;
        const to = this.index + num;
        if (from > to || to > this.bytes.length) {
            throw new Error(`Index out of range: unable to consume bytes from index ${from} to ${to}, data length: ${this.bytes.length}`);
        }
        const bytes = this.bytes.slice(from, to);
        this.index = to;
        return bytes;
    }
    consumeAll() {
        return this.consumeBytes(this.bytes.length - this.index);
    }
}
exports.Reader = Reader;
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.boolCodec = exports.byteCodec = exports.byte32Codec = exports.EnumCodec = exports.ObjectCodec = exports.FixedSizeCodec = exports.assert = exports.Codec = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const reader_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/reader.js [app-ssr] (ecmascript)");
class Codec {
    decode(input) {
        const reader = new reader_1.Reader(input);
        return this._decode(reader);
    }
    bimap(from, to) {
        return new class extends Codec {
            constructor(codecT){
                super();
                this.codecT = codecT;
            }
            encode(input) {
                return this.codecT.encode(to(input));
            }
            _decode(input) {
                return from(this.codecT._decode(input));
            }
        }(this);
    }
}
exports.Codec = Codec;
function assert(value, message) {
    if (!value) {
        throw new Error(message);
    }
}
exports.assert = assert;
class FixedSizeCodec extends Codec {
    constructor(size){
        super();
        this.size = size;
    }
    encode(input) {
        assert(input.length === this.size, `Invalid length, expected ${this.size}, got ${input.length}`);
        return input;
    }
    _decode(input) {
        return input.consumeBytes(this.size);
    }
}
exports.FixedSizeCodec = FixedSizeCodec;
class ObjectCodec extends Codec {
    constructor(codecs){
        super();
        this.codecs = codecs;
        this.keys = Object.keys(codecs);
    }
    encode(value) {
        const bytes = [];
        for (const key of this.keys){
            bytes.push(this.codecs[key].encode(value[key]));
        }
        return (0, utils_1.concatBytes)(bytes);
    }
    _decode(input) {
        const result = {};
        for (const key of this.keys){
            result[key] = this.codecs[key]._decode(input);
        }
        return result;
    }
}
exports.ObjectCodec = ObjectCodec;
class EnumCodec extends Codec {
    constructor(name, codecs){
        super();
        this.name = name;
        this.codecs = codecs;
        this.kinds = Object.keys(codecs);
    }
    encode(value) {
        const index = this.kinds.findIndex((t)=>t === value.kind);
        if (index === -1) {
            throw new Error(`Invalid ${this.name} kind ${value.kind}, expected one of ${this.kinds}`);
        }
        const codec = this.codecs[value.kind];
        return new Uint8Array([
            index,
            ...codec.encode(value.value)
        ]);
    }
    _decode(input) {
        const index = input.consumeByte();
        if (index >= 0 && index < this.kinds.length) {
            const kind = this.kinds[`${index}`];
            const codec = this.codecs[kind];
            return {
                kind,
                value: codec._decode(input)
            };
        }
        throw new Error(`Invalid encoded ${this.name} kind: ${index}`);
    }
}
exports.EnumCodec = EnumCodec;
exports.byte32Codec = new FixedSizeCodec(32);
exports.byteCodec = new class extends Codec {
    encode(input) {
        assert(input >= 0 && input < 256, `Invalid byte: ${input}`);
        return new Uint8Array([
            input
        ]);
    }
    _decode(input) {
        return input.consumeByte();
    }
}();
exports.boolCodec = new class extends Codec {
    encode(input) {
        return new Uint8Array([
            input ? 1 : 0
        ]);
    }
    _decode(input) {
        const byte = input.consumeByte();
        if (byte === 1) {
            return true;
        } else if (byte === 0) {
            return false;
        } else {
            throw new Error(`Invalid encoded bool value ${byte}, expected 0 or 1`);
        }
    }
}();
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/bigint-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BigIntCodec = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ class BigIntCodec {
    static encode(value) {
        // Special case for zero.
        if (value === 0n) {
            return new Uint8Array([
                0
            ]);
        }
        const isNegative = value < 0n;
        let absValue = isNegative ? -value : value;
        const bytes = [];
        // Extract bytes from absolute value.
        while(absValue > 0n){
            bytes.push(Number(absValue & 0xffn));
            absValue >>= 8n;
        }
        // If the bigint is positive and the most significant byte has its high bit set,
        // prefix the byte array with a zero byte to signify positive value.
        if (!isNegative && (bytes[bytes.length - 1] & 0x80) !== 0) {
            bytes.push(0);
        }
        // If the bigint is negative, compute the two's complement of the byte array.
        if (isNegative) {
            let carry = true;
            for(let i = 0; i < bytes.length; i++){
                bytes[i] = ~bytes[i] & 0xff; // Invert the bits of the byte.
                if (carry) {
                    if (bytes[i] === 0xff) {
                        bytes[i] = 0;
                    } else {
                        bytes[i] += 1;
                        carry = false;
                    }
                }
            }
            // If there's still a carry, and the most significant byte is not 0xFF (to store the negative sign bit),
            // or if no bytes were set (which means the value was -1), append a 0xFF byte to hold the carry.
            if (carry || bytes.length === 0 || (bytes[bytes.length - 1] & 0x80) === 0) {
                bytes.push(0xff);
            }
        }
        // The byte array needs to be reversed since we've constructed it in little-endian order.
        return new Uint8Array(bytes.reverse());
    }
    static decodeUnsigned(encoded) {
        // Special case for zero.
        if (encoded.length === 1 && encoded[0] === 0) {
            return 0n;
        }
        // Convert the byte array to a bigint
        let value = 0n;
        for (const byte of encoded){
            value = value << 8n | BigInt(byte);
        }
        return value;
    }
    static decodeSigned(encoded) {
        // Special case for zero.
        if (encoded.length === 1 && encoded[0] === 0) {
            return 0n;
        }
        // Determine if the number is negative by checking the most significant byte (MSB)
        const isNegative = (encoded[0] & 0x80) !== 0;
        // Convert the byte array to a bigint
        let value = 0n;
        for (const byte of encoded){
            value = value << 8n | BigInt(byte);
        }
        // If the number is negative, convert from two's complement
        if (isNegative) {
            // Create a mask for the value's bit length
            const mask = (1n << 8n * BigInt(encoded.length)) - 1n;
            value = -(~value & mask) - 1n;
        }
        return value;
    }
}
exports.BigIntCodec = BigIntCodec;
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.i32Codec = exports.i256Codec = exports.Signed = exports.u32Codec = exports.u256Codec = exports.UnSigned = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const bigint_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/bigint-codec.js [app-ssr] (ecmascript)");
const maskRest = 0xc0;
const maskMode = 0x3f;
const maskModeNeg = 0xffffffc0;
const SingleByteMode = {
    type: 'SingleByte',
    prefix: 0x00,
    negPrefix: 0xc0
};
const TwoByteMode = {
    type: 'TwoByte',
    prefix: 0x40,
    negPrefix: 0x80
};
const FourByteMode = {
    type: 'FourByte',
    prefix: 0x80,
    negPrefix: 0x40
};
const MultiByte = {
    type: 'MultiByte',
    prefix: 0xc0
};
function decodeMode(input) {
    const byte = input.consumeByte();
    switch(byte & maskRest){
        case SingleByteMode.prefix:
            return {
                mode: SingleByteMode,
                body: new Uint8Array([
                    byte
                ])
            };
        case TwoByteMode.prefix:
            return {
                mode: TwoByteMode,
                body: new Uint8Array([
                    byte,
                    ...input.consumeBytes(1)
                ])
            };
        case FourByteMode.prefix:
            return {
                mode: FourByteMode,
                body: new Uint8Array([
                    byte,
                    ...input.consumeBytes(3)
                ])
            };
        default:
            {
                const length = (byte & maskMode) + 4;
                return {
                    mode: MultiByte,
                    body: new Uint8Array([
                        byte,
                        ...input.consumeBytes(length)
                    ])
                };
            }
    }
}
class UnSigned {
    static encodeU32(value) {
        (0, codec_1.assert)(value >= 0 && value < UnSigned.u32UpperBound, `Invalid u32 value: ${value}`);
        if (value < UnSigned.oneByteBound) {
            return new Uint8Array([
                SingleByteMode.prefix + value & 0xff
            ]);
        } else if (value < UnSigned.twoByteBound) {
            return new Uint8Array([
                TwoByteMode.prefix + (value >> 8) & 0xff,
                value & 0xff
            ]);
        } else if (value < UnSigned.fourByteBound) {
            return new Uint8Array([
                FourByteMode.prefix + (value >> 24) & 0xff,
                value >> 16 & 0xff,
                value >> 8 & 0xff,
                value & 0xff
            ]);
        } else {
            return new Uint8Array([
                MultiByte.prefix,
                value >> 24 & 0xff,
                value >> 16 & 0xff,
                value >> 8 & 0xff,
                value & 0xff
            ]);
        }
    }
    static encodeU256(value) {
        (0, codec_1.assert)(value >= 0n && value < UnSigned.u256UpperBound, `Invalid u256 value: ${value}`);
        if (value < UnSigned.fourByteBound) {
            return UnSigned.encodeU32(Number(value));
        } else {
            let bytes = bigint_codec_1.BigIntCodec.encode(value);
            if (bytes[0] === 0) {
                bytes = bytes.slice(1);
            }
            const header = bytes.length - 4 + MultiByte.prefix & 0xff;
            return new Uint8Array([
                header,
                ...bytes
            ]);
        }
    }
    static decodeInt(mode, body) {
        switch(mode.type){
            case 'SingleByte':
                (0, codec_1.assert)(body.length === 1, 'Length should be 2');
                return body[0];
            case 'TwoByte':
                (0, codec_1.assert)(body.length === 2, 'Length should be 2');
                return (body[0] & maskMode) << 8 | body[1] & 0xff;
            case 'FourByte':
                (0, codec_1.assert)(body.length === 4, 'Length should be 4');
                return ((body[0] & maskMode) << 24 | (body[1] & 0xff) << 16 | (body[2] & 0xff) << 8 | body[3] & 0xff) >>> 0;
        }
    }
    static decodeU32(mode, body) {
        switch(mode.type){
            case 'SingleByte':
            case 'TwoByte':
            case 'FourByte':
                return UnSigned.decodeInt(mode, body);
            case 'MultiByte':
                (0, codec_1.assert)(body.length >= 5, 'Length should be greater than 5');
                if (body.length === 5) {
                    return (body[1] << 24 | (body[2] & 0xff) << 16 | (body[3] & 0xff) << 8 | body[4] & 0xff) >>> 0;
                } else {
                    throw new Error(`Expect 4 bytes int, but get ${body.length - 1} bytes int`);
                }
        }
    }
    static decodeU256(mode, body) {
        switch(mode.type){
            case 'SingleByte':
            case 'TwoByte':
            case 'FourByte':
                return BigInt(UnSigned.decodeInt(mode, body));
            case 'MultiByte':
                return bigint_codec_1.BigIntCodec.decodeUnsigned(body.slice(1, body.length));
        }
    }
}
exports.UnSigned = UnSigned;
UnSigned.oneByteBound = BigInt(0x40);
UnSigned.twoByteBound = UnSigned.oneByteBound << BigInt(8);
UnSigned.fourByteBound = UnSigned.oneByteBound << BigInt(8 * 3);
UnSigned.u256UpperBound = BigInt(1) << BigInt(256);
UnSigned.u32UpperBound = 2 ** 32;
exports.u256Codec = new class extends codec_1.Codec {
    encode(input) {
        return UnSigned.encodeU256(input);
    }
    _decode(input) {
        const { mode, body } = decodeMode(input);
        return UnSigned.decodeU256(mode, body);
    }
}();
exports.u32Codec = new class extends codec_1.Codec {
    encode(input) {
        return UnSigned.encodeU32(input);
    }
    _decode(input) {
        const { mode, body } = decodeMode(input);
        return UnSigned.decodeU32(mode, body);
    }
}();
class Signed {
    static encodeI32(value) {
        (0, codec_1.assert)(value >= Signed.i32LowerBound && value < Signed.i32UpperBound, `Invalid i32 value: ${value}`);
        if (value >= 0) {
            return Signed.encodePositiveI32(value);
        } else {
            return Signed.encodeNegativeI32(value);
        }
    }
    static encodePositiveI32(value) {
        if (value < this.oneByteBound) {
            return new Uint8Array([
                SingleByteMode.prefix + value & 0xff
            ]);
        } else if (value < this.twoByteBound) {
            return new Uint8Array([
                TwoByteMode.prefix + (value >> 8) & 0xff,
                value & 0xff
            ]);
        } else if (value < this.fourByteBound) {
            return new Uint8Array([
                FourByteMode.prefix + (value >> 24) & 0xff,
                value >> 16 & 0xff,
                value >> 8 & 0xff,
                value & 0xff
            ]);
        } else {
            return new Uint8Array([
                MultiByte.prefix,
                value >> 24 & 0xff,
                value >> 16 & 0xff,
                value >> 8 & 0xff,
                value & 0xff
            ]);
        }
    }
    static encodeNegativeI32(value) {
        if (value >= -this.oneByteBound) {
            return new Uint8Array([
                (value ^ SingleByteMode.negPrefix) & 0xff
            ]);
        } else if (value >= -this.twoByteBound) {
            return new Uint8Array([
                (value >> 8 ^ TwoByteMode.negPrefix) & 0xff,
                value & 0xff
            ]);
        } else if (value >= -this.fourByteBound) {
            return new Uint8Array([
                (value >> 24 ^ FourByteMode.negPrefix) & 0xff,
                value >> 16 & 0xff,
                value >> 8 & 0xff,
                value & 0xff
            ]);
        } else {
            return new Uint8Array([
                MultiByte.prefix,
                value >> 24 & 0xff,
                value >> 16 & 0xff,
                value >> 8 & 0xff,
                value & 0xff
            ]);
        }
    }
    static encodeI256(value) {
        (0, codec_1.assert)(value >= Signed.i256LowerBound && value < Signed.i256UpperBound, `Invalid i256 value: ${value}`);
        if (value >= -0x20000000 && value < 0x20000000) {
            return this.encodeI32(Number(value));
        } else {
            const bytes = bigint_codec_1.BigIntCodec.encode(value);
            const header = bytes.length - 4 + MultiByte.prefix & 0xff;
            return new Uint8Array([
                header,
                ...bytes
            ]);
        }
    }
    static decodeInt(mode, body) {
        const isPositive = (body[0] & Signed.signFlag) === 0;
        if (isPositive) {
            return Signed.decodePositiveInt(mode, body);
        } else {
            return Signed.decodeNegativeInt(mode, body);
        }
    }
    static decodePositiveInt(mode, body) {
        switch(mode.type){
            case 'SingleByte':
                return body[0];
            case 'TwoByte':
                (0, codec_1.assert)(body.length === 2, 'Length should be 2');
                return (body[0] & maskMode) << 8 | body[1] & 0xff;
            case 'FourByte':
                (0, codec_1.assert)(body.length === 4, 'Length should be 4');
                return (body[0] & maskMode) << 24 | (body[1] & 0xff) << 16 | (body[2] & 0xff) << 8 | body[3] & 0xff;
        }
    }
    static decodeNegativeInt(mode, body) {
        switch(mode.type){
            case 'SingleByte':
                return body[0] | maskModeNeg;
            case 'TwoByte':
                (0, codec_1.assert)(body.length === 2, 'Length should be 2');
                return (body[0] | maskModeNeg) << 8 | body[1] & 0xff;
            case 'FourByte':
                (0, codec_1.assert)(body.length === 4, 'Length should be 4');
                return (body[0] | maskModeNeg) << 24 | (body[1] & 0xff) << 16 | (body[2] & 0xff) << 8 | body[3] & 0xff;
        }
    }
    static decodeI32(mode, body) {
        switch(mode.type){
            case 'SingleByte':
            case 'TwoByte':
            case 'FourByte':
                return Signed.decodeInt(mode, body);
            case 'MultiByte':
                if (body.length === 5) {
                    return body[1] << 24 | (body[2] & 0xff) << 16 | (body[3] & 0xff) << 8 | body[4] & 0xff;
                } else {
                    throw new Error(`Expect 4 bytes int, but get ${body.length - 1} bytes int`);
                }
        }
    }
    static decodeI256(mode, body) {
        switch(mode.type){
            case 'SingleByte':
            case 'TwoByte':
            case 'FourByte':
                return BigInt(Signed.decodeInt(mode, body));
            case 'MultiByte':
                const bytes = body.slice(1, body.length);
                (0, codec_1.assert)(bytes.length <= 32, 'Expect <= 32 bytes for I256');
                return bigint_codec_1.BigIntCodec.decodeSigned(bytes);
        }
    }
}
exports.Signed = Signed;
Signed.signFlag = 0x20; // 0b00100000
Signed.oneByteBound = BigInt(0x20);
Signed.twoByteBound = Signed.oneByteBound << BigInt(8);
Signed.fourByteBound = Signed.oneByteBound << BigInt(8 * 3);
Signed.i256UpperBound = BigInt(1) << BigInt(255);
Signed.i256LowerBound = -Signed.i256UpperBound;
Signed.i32UpperBound = 2 ** 31;
Signed.i32LowerBound = -Signed.i32UpperBound;
exports.i256Codec = new class extends codec_1.Codec {
    encode(input) {
        return Signed.encodeI256(input);
    }
    _decode(input) {
        const { mode, body } = decodeMode(input);
        return Signed.decodeI256(mode, body);
    }
}();
exports.i32Codec = new class extends codec_1.Codec {
    encode(input) {
        return Signed.encodeI32(input);
    }
    _decode(input) {
        const { mode, body } = decodeMode(input);
        return Signed.decodeI32(mode, body);
    }
}();
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ArrayCodec = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const compact_int_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
class ArrayCodec extends codec_1.Codec {
    constructor(childCodec){
        super();
        this.childCodec = childCodec;
    }
    encode(input) {
        const bytes = [
            compact_int_codec_1.i32Codec.encode(input.length)
        ];
        for (const element of input){
            bytes.push(this.childCodec.encode(element));
        }
        return (0, utils_1.concatBytes)(bytes);
    }
    _decode(input) {
        const length = compact_int_codec_1.i32Codec._decode(input);
        const array = [];
        for(let index = 0; index < length; index += 1){
            array.push(this.childCodec._decode(input));
        }
        return array;
    }
}
exports.ArrayCodec = ArrayCodec;
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/lockup-script-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.lockupScriptCodec = exports.p2cCodec = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const compact_int_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
exports.p2cCodec = codec_1.byte32Codec;
const p2mpkhCodec = new codec_1.ObjectCodec({
    publicKeyHashes: new array_codec_1.ArrayCodec(codec_1.byte32Codec),
    m: compact_int_codec_1.i32Codec
});
exports.lockupScriptCodec = new codec_1.EnumCodec('lockup script', {
    P2PKH: codec_1.byte32Codec,
    P2MPKH: p2mpkhCodec,
    P2SH: codec_1.byte32Codec,
    P2C: codec_1.byte32Codec
});
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/int-as-4bytes-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.intAs4BytesCodec = exports.IntAs4BytesCodec = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
class IntAs4BytesCodec extends codec_1.Codec {
    encode(value) {
        return new Uint8Array([
            value >> 24 & 0xff,
            value >> 16 & 0xff,
            value >> 8 & 0xff,
            value & 0xff
        ]);
    }
    _decode(input) {
        const bytes = input.consumeBytes(4);
        return (bytes[0] & 0xff) << 24 | (bytes[1] & 0xff) << 16 | (bytes[2] & 0xff) << 8 | bytes[3] & 0xff;
    }
}
exports.IntAs4BytesCodec = IntAs4BytesCodec;
exports.intAs4BytesCodec = new IntAs4BytesCodec();
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/timestamp-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.timestampCodec = exports.TimestampCodec = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
class TimestampCodec extends codec_1.Codec {
    encode(input) {
        (0, codec_1.assert)(input >= 0n && input < TimestampCodec.max, `Invalid timestamp: ${input}`);
        const byteArray = new Uint8Array(8);
        for(let index = 0; index < 8; index += 1){
            byteArray[`${index}`] = Number(input >> BigInt((7 - index) * 8) & BigInt(0xff));
        }
        return byteArray;
    }
    _decode(input) {
        const bytes = input.consumeBytes(8);
        return BigInt(`0x${(0, utils_1.binToHex)(bytes)}`);
    }
}
exports.TimestampCodec = TimestampCodec;
TimestampCodec.max = 1n << 64n;
exports.timestampCodec = new TimestampCodec();
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/bytestring-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.byteStringsCodec = exports.byteStringCodec = exports.ByteStringCodec = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const compact_int_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
class ByteStringCodec extends codec_1.Codec {
    encode(input) {
        return (0, utils_1.concatBytes)([
            compact_int_codec_1.i32Codec.encode(input.length),
            input
        ]);
    }
    _decode(input) {
        const length = compact_int_codec_1.i32Codec._decode(input);
        return input.consumeBytes(length);
    }
}
exports.ByteStringCodec = ByteStringCodec;
exports.byteStringCodec = new ByteStringCodec();
exports.byteStringsCodec = new array_codec_1.ArrayCodec(exports.byteStringCodec);
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/hash.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createHint = exports.djbIntHash = exports.blakeHash = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const blakejs_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/blakejs/index.js [app-ssr] (ecmascript)"));
function blakeHash(raw) {
    return blakejs_1.default.blake2b(raw, undefined, 32);
}
exports.blakeHash = blakeHash;
function djbIntHash(bytes) {
    let hash = 5381;
    bytes.forEach((byte)=>{
        hash = (hash << 5) + hash + (byte & 0xff);
    });
    return hash;
}
exports.djbIntHash = djbIntHash;
function createHint(input) {
    return djbIntHash(input) | 1;
}
exports.createHint = createHint;
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/token-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tokensCodec = exports.tokenCodec = void 0;
const compact_int_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
exports.tokenCodec = new codec_1.ObjectCodec({
    tokenId: codec_1.byte32Codec,
    amount: compact_int_codec_1.u256Codec
});
exports.tokensCodec = new array_codec_1.ArrayCodec(exports.tokenCodec);
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/asset-output-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.assetOutputsCodec = exports.assetOutputCodec = exports.AssetOutputCodec = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
const compact_int_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)");
const int_as_4bytes_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/int-as-4bytes-codec.js [app-ssr] (ecmascript)");
const timestamp_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/timestamp-codec.js [app-ssr] (ecmascript)");
const bytestring_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/bytestring-codec.js [app-ssr] (ecmascript)");
const lockup_script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/lockup-script-codec.js [app-ssr] (ecmascript)");
const hash_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/hash.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const token_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/token-codec.js [app-ssr] (ecmascript)");
class AssetOutputCodec extends codec_1.ObjectCodec {
    static toFixedAssetOutputs(txIdBytes, outputs) {
        return outputs.map((output, index)=>AssetOutputCodec.toFixedAssetOutput(txIdBytes, output, index));
    }
    static toFixedAssetOutput(txIdBytes, output, index) {
        const attoAlphAmount = output.amount.toString();
        const lockTime = Number(output.lockTime);
        const tokens = output.tokens.map((token)=>{
            return {
                id: (0, utils_1.binToHex)(token.tokenId),
                amount: token.amount.toString()
            };
        });
        const message = (0, utils_1.binToHex)(output.additionalData);
        const scriptType = output.lockupScript.kind;
        const key = (0, utils_1.binToHex)((0, hash_1.blakeHash)((0, utils_1.concatBytes)([
            txIdBytes,
            int_as_4bytes_codec_1.intAs4BytesCodec.encode(index)
        ])));
        const outputLockupScript = output.lockupScript.value;
        const address = utils_1.bs58.encode(lockup_script_codec_1.lockupScriptCodec.encode(output.lockupScript));
        let hint = undefined;
        if (scriptType === 'P2PKH') {
            hint = (0, hash_1.createHint)(outputLockupScript);
        } else if (scriptType === 'P2MPKH') {
            hint = (0, hash_1.createHint)(outputLockupScript.publicKeyHashes[0]);
        } else if (scriptType === 'P2SH') {
            hint = (0, hash_1.createHint)(outputLockupScript);
        } else if (scriptType === 'P2C') {
            throw new Error(`P2C script type not allowed for asset output`);
        } else {
            throw new Error(`Unexpected output script type: ${scriptType}`);
        }
        return {
            hint,
            key,
            attoAlphAmount,
            lockTime,
            tokens,
            address,
            message
        };
    }
    static fromFixedAssetOutputs(fixedOutputs) {
        return fixedOutputs.map((output)=>{
            return AssetOutputCodec.fromFixedAssetOutput(output);
        });
    }
    static fromFixedAssetOutput(fixedOutput) {
        const amount = BigInt(fixedOutput.attoAlphAmount);
        const lockTime = BigInt(fixedOutput.lockTime);
        const lockupScript = lockup_script_codec_1.lockupScriptCodec.decode(utils_1.bs58.decode(fixedOutput.address));
        const tokens = fixedOutput.tokens.map((token)=>{
            return {
                tokenId: (0, utils_1.hexToBinUnsafe)(token.id),
                amount: BigInt(token.amount)
            };
        });
        const additionalData = (0, utils_1.hexToBinUnsafe)(fixedOutput.message);
        return {
            amount,
            lockupScript,
            lockTime,
            tokens,
            additionalData
        };
    }
}
exports.AssetOutputCodec = AssetOutputCodec;
exports.assetOutputCodec = new AssetOutputCodec({
    amount: compact_int_codec_1.u256Codec,
    lockupScript: lockup_script_codec_1.lockupScriptCodec,
    lockTime: timestamp_codec_1.timestampCodec,
    tokens: token_codec_1.tokensCodec,
    additionalData: bytestring_codec_1.byteStringCodec
});
exports.assetOutputsCodec = new array_codec_1.ArrayCodec(exports.assetOutputCodec);
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/contract-output-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.contractOutputCodec = exports.ContractOutputCodec = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const compact_int_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)");
const lockup_script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/lockup-script-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const token_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/token-codec.js [app-ssr] (ecmascript)");
const hash_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/hash.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const int_as_4bytes_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/int-as-4bytes-codec.js [app-ssr] (ecmascript)");
const lockup_script_codec_2 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/lockup-script-codec.js [app-ssr] (ecmascript)");
class ContractOutputCodec extends codec_1.ObjectCodec {
    static convertToApiContractOutput(txIdBytes, output, index) {
        const hint = (0, hash_1.createHint)(output.lockupScript);
        const key = (0, utils_1.binToHex)((0, hash_1.blakeHash)((0, utils_1.concatBytes)([
            txIdBytes,
            int_as_4bytes_codec_1.intAs4BytesCodec.encode(index)
        ])));
        const attoAlphAmount = output.amount.toString();
        const address = utils_1.bs58.encode(new Uint8Array([
            0x03,
            ...output.lockupScript
        ]));
        const tokens = output.tokens.map((token)=>{
            return {
                id: (0, utils_1.binToHex)(token.tokenId),
                amount: token.amount.toString()
            };
        });
        return {
            hint,
            key,
            attoAlphAmount,
            address,
            tokens,
            type: 'ContractOutput'
        };
    }
    static convertToOutput(apiContractOutput) {
        const amount = BigInt(apiContractOutput.attoAlphAmount);
        const lockupScript = lockup_script_codec_2.lockupScriptCodec.decode(utils_1.bs58.decode(apiContractOutput.address)).value;
        const tokens = apiContractOutput.tokens.map((token)=>{
            return {
                tokenId: (0, utils_1.hexToBinUnsafe)(token.id),
                amount: BigInt(token.amount)
            };
        });
        return {
            amount,
            lockupScript,
            tokens
        };
    }
}
exports.ContractOutputCodec = ContractOutputCodec;
exports.contractOutputCodec = new ContractOutputCodec({
    amount: compact_int_codec_1.u256Codec,
    lockupScript: lockup_script_codec_1.p2cCodec,
    tokens: token_codec_1.tokensCodec
});
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/contract-output-ref-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.contractOutputRefsCodec = exports.contractOutputRefCodec = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const int_as_4bytes_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/int-as-4bytes-codec.js [app-ssr] (ecmascript)");
exports.contractOutputRefCodec = new codec_1.ObjectCodec({
    hint: int_as_4bytes_codec_1.intAs4BytesCodec,
    key: codec_1.byte32Codec
});
exports.contractOutputRefsCodec = new array_codec_1.ArrayCodec(exports.contractOutputRefCodec);
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/either-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.either = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
function either(name, l, r) {
    return new codec_1.EnumCodec(name, {
        Left: l,
        Right: r
    });
}
exports.either = either;
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/instr-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.I256Add = exports.BoolToByteVec = exports.BoolNeq = exports.BoolEq = exports.BoolOr = exports.BoolAnd = exports.BoolNot = exports.Pop = exports.StoreLocal = exports.LoadLocal = exports.AddressConst = exports.BytesConst = exports.U256Const = exports.I256Const = exports.U256Const5 = exports.U256Const4 = exports.U256Const3 = exports.U256Const2 = exports.U256Const1 = exports.U256Const0 = exports.I256ConstN1 = exports.I256Const5 = exports.I256Const4 = exports.I256Const3 = exports.I256Const2 = exports.I256Const1 = exports.I256Const0 = exports.ConstFalse = exports.ConstTrue = exports.Return = exports.CallExternal = exports.CallLocal = exports.CallExternalBySelectorCode = exports.MethodSelectorCode = exports.CreateMapEntryCode = exports.LoadImmFieldCode = exports.StoreMutFieldCode = exports.LoadMutFieldCode = exports.DEBUGCode = exports.IfFalseCode = exports.IfTrueCode = exports.JumpCode = exports.StoreLocalCode = exports.LoadLocalCode = exports.AddressConstCode = exports.BytesConstCode = exports.U256ConstCode = exports.I256ConstCode = exports.CallExternalCode = exports.CallLocalCode = void 0;
exports.Sha3 = exports.Sha256 = exports.Keccak256 = exports.Blake2b = exports.Assert = exports.IfFalse = exports.IfTrue = exports.Jump = exports.IsContractAddress = exports.IsAssetAddress = exports.AddressToByteVec = exports.AddressNeq = exports.AddressEq = exports.ByteVecConcat = exports.ByteVecSize = exports.ByteVecNeq = exports.ByteVecEq = exports.U256ToByteVec = exports.U256ToI256 = exports.I256ToByteVec = exports.I256ToU256 = exports.U256SHR = exports.U256SHL = exports.U256Xor = exports.U256BitOr = exports.U256BitAnd = exports.U256ModMul = exports.U256ModSub = exports.U256ModAdd = exports.U256Ge = exports.U256Gt = exports.U256Le = exports.U256Lt = exports.U256Neq = exports.U256Eq = exports.U256Mod = exports.U256Div = exports.U256Mul = exports.U256Sub = exports.U256Add = exports.I256Ge = exports.I256Gt = exports.I256Le = exports.I256Lt = exports.I256Neq = exports.I256Eq = exports.I256Mod = exports.I256Div = exports.I256Mul = exports.I256Sub = void 0;
exports.U256Exp = exports.I256Exp = exports.TxGasFee = exports.TxGasAmount = exports.TxGasPrice = exports.DEBUG = exports.BlockHash = exports.Swap = exports.AssertWithErrorCode = exports.Dup = exports.StoreLocalByIndex = exports.LoadLocalByIndex = exports.ContractIdToAddress = exports.Log9 = exports.Log8 = exports.Log7 = exports.Log6 = exports.EthEcRecover = exports.U256From32Byte = exports.U256From16Byte = exports.U256From8Byte = exports.U256From4Byte = exports.U256From2Byte = exports.U256From1Byte = exports.U256To32Byte = exports.U256To16Byte = exports.U256To8Byte = exports.U256To4Byte = exports.U256To2Byte = exports.U256To1Byte = exports.Zeros = exports.Encode = exports.ByteVecToAddress = exports.ByteVecSlice = exports.Log5 = exports.Log4 = exports.Log3 = exports.Log2 = exports.Log1 = exports.VerifyRelativeLocktime = exports.VerifyAbsoluteLocktime = exports.TxInputsSize = exports.TxInputAddressAt = exports.TxId = exports.BlockTarget = exports.BlockTimeStamp = exports.NetworkId = exports.VerifyED25519 = exports.VerifySecP256K1 = exports.VerifyTxSignature = void 0;
exports.CreateSubContractAndTransferToken = exports.CopyCreateContractAndTransferToken = exports.CreateContractAndTransferToken = exports.ContractExists = exports.StoreMutFieldByIndex = exports.LoadMutFieldByIndex = exports.CopyCreateSubContractWithToken = exports.CopyCreateSubContract = exports.CreateSubContractWithToken = exports.CreateSubContract = exports.LockApprovedAssets = exports.BurnToken = exports.CopyCreateContractWithToken = exports.MigrateWithFields = exports.MigrateSimple = exports.ContractCodeHash = exports.ContractInitialStateHash = exports.CallerCodeHash = exports.CallerInitialStateHash = exports.IsCalledFromTxScript = exports.CallerAddress = exports.CallerContractId = exports.SelfAddress = exports.SelfContractId = exports.DestroySelf = exports.CopyCreateContract = exports.CreateContractWithToken = exports.CreateContract = exports.TransferTokenToSelf = exports.TransferTokenFromSelf = exports.TransferToken = exports.TransferAlphToSelf = exports.TransferAlphFromSelf = exports.TransferAlph = exports.IsPaying = exports.TokenRemaining = exports.AlphRemaining = exports.ApproveToken = exports.ApproveAlph = exports.StoreMutField = exports.LoadMutField = exports.GroupOfAddress = exports.BoolToString = exports.I256ToString = exports.U256ToString = exports.AddModN = exports.MulModN = exports.GetSegregatedSignature = exports.VerifyBIP340Schnorr = exports.U256ModExp = void 0;
exports.toI256 = exports.toU256 = exports.instrsCodec = exports.instrCodec = exports.InstrCodec = exports.CallExternalBySelector = exports.MethodSelector = exports.CreateMapEntry = exports.MinimalContractDeposit = exports.PayGasFee = exports.LoadImmFieldByIndex = exports.LoadImmField = exports.ALPHTokenId = exports.SubContractIdOf = exports.SubContractId = exports.NullContractAddress = exports.CopyCreateSubContractAndTransferToken = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ // auto-generated, do not edit
const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
const compact_int_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)");
const bytestring_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/bytestring-codec.js [app-ssr] (ecmascript)");
const lockup_script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/lockup-script-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const int_as_4bytes_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/int-as-4bytes-codec.js [app-ssr] (ecmascript)");
exports.CallLocalCode = 0x00;
exports.CallExternalCode = 0x01;
exports.I256ConstCode = 0x12;
exports.U256ConstCode = 0x13;
exports.BytesConstCode = 0x14;
exports.AddressConstCode = 0x15;
exports.LoadLocalCode = 0x16;
exports.StoreLocalCode = 0x17;
exports.JumpCode = 0x4a;
exports.IfTrueCode = 0x4b;
exports.IfFalseCode = 0x4c;
exports.DEBUGCode = 0x7e;
exports.LoadMutFieldCode = 0xa0;
exports.StoreMutFieldCode = 0xa1;
exports.LoadImmFieldCode = 0xce;
exports.CreateMapEntryCode = 0xd2;
exports.MethodSelectorCode = 0xd3;
exports.CallExternalBySelectorCode = 0xd4;
const CallLocal = (index)=>{
    return {
        name: 'CallLocal',
        code: 0x00,
        index
    };
};
exports.CallLocal = CallLocal;
const CallExternal = (index)=>{
    return {
        name: 'CallExternal',
        code: 0x01,
        index
    };
};
exports.CallExternal = CallExternal;
exports.Return = {
    name: 'Return',
    code: 0x02
};
exports.ConstTrue = {
    name: 'ConstTrue',
    code: 0x03
};
exports.ConstFalse = {
    name: 'ConstFalse',
    code: 0x04
};
exports.I256Const0 = {
    name: 'I256Const0',
    code: 0x05
};
exports.I256Const1 = {
    name: 'I256Const1',
    code: 0x06
};
exports.I256Const2 = {
    name: 'I256Const2',
    code: 0x07
};
exports.I256Const3 = {
    name: 'I256Const3',
    code: 0x08
};
exports.I256Const4 = {
    name: 'I256Const4',
    code: 0x09
};
exports.I256Const5 = {
    name: 'I256Const5',
    code: 0x0a
};
exports.I256ConstN1 = {
    name: 'I256ConstN1',
    code: 0x0b
};
exports.U256Const0 = {
    name: 'U256Const0',
    code: 0x0c
};
exports.U256Const1 = {
    name: 'U256Const1',
    code: 0x0d
};
exports.U256Const2 = {
    name: 'U256Const2',
    code: 0x0e
};
exports.U256Const3 = {
    name: 'U256Const3',
    code: 0x0f
};
exports.U256Const4 = {
    name: 'U256Const4',
    code: 0x10
};
exports.U256Const5 = {
    name: 'U256Const5',
    code: 0x11
};
const I256Const = (value)=>{
    return {
        name: 'I256Const',
        code: 0x12,
        value
    };
};
exports.I256Const = I256Const;
const U256Const = (value)=>{
    return {
        name: 'U256Const',
        code: 0x13,
        value
    };
};
exports.U256Const = U256Const;
const BytesConst = (value)=>{
    return {
        name: 'BytesConst',
        code: 0x14,
        value
    };
};
exports.BytesConst = BytesConst;
const AddressConst = (value)=>{
    return {
        name: 'AddressConst',
        code: 0x15,
        value
    };
};
exports.AddressConst = AddressConst;
const LoadLocal = (index)=>{
    return {
        name: 'LoadLocal',
        code: 0x16,
        index
    };
};
exports.LoadLocal = LoadLocal;
const StoreLocal = (index)=>{
    return {
        name: 'StoreLocal',
        code: 0x17,
        index
    };
};
exports.StoreLocal = StoreLocal;
exports.Pop = {
    name: 'Pop',
    code: 0x18
};
exports.BoolNot = {
    name: 'BoolNot',
    code: 0x19
};
exports.BoolAnd = {
    name: 'BoolAnd',
    code: 0x1a
};
exports.BoolOr = {
    name: 'BoolOr',
    code: 0x1b
};
exports.BoolEq = {
    name: 'BoolEq',
    code: 0x1c
};
exports.BoolNeq = {
    name: 'BoolNeq',
    code: 0x1d
};
exports.BoolToByteVec = {
    name: 'BoolToByteVec',
    code: 0x1e
};
exports.I256Add = {
    name: 'I256Add',
    code: 0x1f
};
exports.I256Sub = {
    name: 'I256Sub',
    code: 0x20
};
exports.I256Mul = {
    name: 'I256Mul',
    code: 0x21
};
exports.I256Div = {
    name: 'I256Div',
    code: 0x22
};
exports.I256Mod = {
    name: 'I256Mod',
    code: 0x23
};
exports.I256Eq = {
    name: 'I256Eq',
    code: 0x24
};
exports.I256Neq = {
    name: 'I256Neq',
    code: 0x25
};
exports.I256Lt = {
    name: 'I256Lt',
    code: 0x26
};
exports.I256Le = {
    name: 'I256Le',
    code: 0x27
};
exports.I256Gt = {
    name: 'I256Gt',
    code: 0x28
};
exports.I256Ge = {
    name: 'I256Ge',
    code: 0x29
};
exports.U256Add = {
    name: 'U256Add',
    code: 0x2a
};
exports.U256Sub = {
    name: 'U256Sub',
    code: 0x2b
};
exports.U256Mul = {
    name: 'U256Mul',
    code: 0x2c
};
exports.U256Div = {
    name: 'U256Div',
    code: 0x2d
};
exports.U256Mod = {
    name: 'U256Mod',
    code: 0x2e
};
exports.U256Eq = {
    name: 'U256Eq',
    code: 0x2f
};
exports.U256Neq = {
    name: 'U256Neq',
    code: 0x30
};
exports.U256Lt = {
    name: 'U256Lt',
    code: 0x31
};
exports.U256Le = {
    name: 'U256Le',
    code: 0x32
};
exports.U256Gt = {
    name: 'U256Gt',
    code: 0x33
};
exports.U256Ge = {
    name: 'U256Ge',
    code: 0x34
};
exports.U256ModAdd = {
    name: 'U256ModAdd',
    code: 0x35
};
exports.U256ModSub = {
    name: 'U256ModSub',
    code: 0x36
};
exports.U256ModMul = {
    name: 'U256ModMul',
    code: 0x37
};
exports.U256BitAnd = {
    name: 'U256BitAnd',
    code: 0x38
};
exports.U256BitOr = {
    name: 'U256BitOr',
    code: 0x39
};
exports.U256Xor = {
    name: 'U256Xor',
    code: 0x3a
};
exports.U256SHL = {
    name: 'U256SHL',
    code: 0x3b
};
exports.U256SHR = {
    name: 'U256SHR',
    code: 0x3c
};
exports.I256ToU256 = {
    name: 'I256ToU256',
    code: 0x3d
};
exports.I256ToByteVec = {
    name: 'I256ToByteVec',
    code: 0x3e
};
exports.U256ToI256 = {
    name: 'U256ToI256',
    code: 0x3f
};
exports.U256ToByteVec = {
    name: 'U256ToByteVec',
    code: 0x40
};
exports.ByteVecEq = {
    name: 'ByteVecEq',
    code: 0x41
};
exports.ByteVecNeq = {
    name: 'ByteVecNeq',
    code: 0x42
};
exports.ByteVecSize = {
    name: 'ByteVecSize',
    code: 0x43
};
exports.ByteVecConcat = {
    name: 'ByteVecConcat',
    code: 0x44
};
exports.AddressEq = {
    name: 'AddressEq',
    code: 0x45
};
exports.AddressNeq = {
    name: 'AddressNeq',
    code: 0x46
};
exports.AddressToByteVec = {
    name: 'AddressToByteVec',
    code: 0x47
};
exports.IsAssetAddress = {
    name: 'IsAssetAddress',
    code: 0x48
};
exports.IsContractAddress = {
    name: 'IsContractAddress',
    code: 0x49
};
const Jump = (offset)=>{
    return {
        name: 'Jump',
        code: 0x4a,
        offset
    };
};
exports.Jump = Jump;
const IfTrue = (offset)=>{
    return {
        name: 'IfTrue',
        code: 0x4b,
        offset
    };
};
exports.IfTrue = IfTrue;
const IfFalse = (offset)=>{
    return {
        name: 'IfFalse',
        code: 0x4c,
        offset
    };
};
exports.IfFalse = IfFalse;
exports.Assert = {
    name: 'Assert',
    code: 0x4d
};
exports.Blake2b = {
    name: 'Blake2b',
    code: 0x4e
};
exports.Keccak256 = {
    name: 'Keccak256',
    code: 0x4f
};
exports.Sha256 = {
    name: 'Sha256',
    code: 0x50
};
exports.Sha3 = {
    name: 'Sha3',
    code: 0x51
};
exports.VerifyTxSignature = {
    name: 'VerifyTxSignature',
    code: 0x52
};
exports.VerifySecP256K1 = {
    name: 'VerifySecP256K1',
    code: 0x53
};
exports.VerifyED25519 = {
    name: 'VerifyED25519',
    code: 0x54
};
exports.NetworkId = {
    name: 'NetworkId',
    code: 0x55
};
exports.BlockTimeStamp = {
    name: 'BlockTimeStamp',
    code: 0x56
};
exports.BlockTarget = {
    name: 'BlockTarget',
    code: 0x57
};
exports.TxId = {
    name: 'TxId',
    code: 0x58
};
exports.TxInputAddressAt = {
    name: 'TxInputAddressAt',
    code: 0x59
};
exports.TxInputsSize = {
    name: 'TxInputsSize',
    code: 0x5a
};
exports.VerifyAbsoluteLocktime = {
    name: 'VerifyAbsoluteLocktime',
    code: 0x5b
};
exports.VerifyRelativeLocktime = {
    name: 'VerifyRelativeLocktime',
    code: 0x5c
};
exports.Log1 = {
    name: 'Log1',
    code: 0x5d
};
exports.Log2 = {
    name: 'Log2',
    code: 0x5e
};
exports.Log3 = {
    name: 'Log3',
    code: 0x5f
};
exports.Log4 = {
    name: 'Log4',
    code: 0x60
};
exports.Log5 = {
    name: 'Log5',
    code: 0x61
};
exports.ByteVecSlice = {
    name: 'ByteVecSlice',
    code: 0x62
};
exports.ByteVecToAddress = {
    name: 'ByteVecToAddress',
    code: 0x63
};
exports.Encode = {
    name: 'Encode',
    code: 0x64
};
exports.Zeros = {
    name: 'Zeros',
    code: 0x65
};
exports.U256To1Byte = {
    name: 'U256To1Byte',
    code: 0x66
};
exports.U256To2Byte = {
    name: 'U256To2Byte',
    code: 0x67
};
exports.U256To4Byte = {
    name: 'U256To4Byte',
    code: 0x68
};
exports.U256To8Byte = {
    name: 'U256To8Byte',
    code: 0x69
};
exports.U256To16Byte = {
    name: 'U256To16Byte',
    code: 0x6a
};
exports.U256To32Byte = {
    name: 'U256To32Byte',
    code: 0x6b
};
exports.U256From1Byte = {
    name: 'U256From1Byte',
    code: 0x6c
};
exports.U256From2Byte = {
    name: 'U256From2Byte',
    code: 0x6d
};
exports.U256From4Byte = {
    name: 'U256From4Byte',
    code: 0x6e
};
exports.U256From8Byte = {
    name: 'U256From8Byte',
    code: 0x6f
};
exports.U256From16Byte = {
    name: 'U256From16Byte',
    code: 0x70
};
exports.U256From32Byte = {
    name: 'U256From32Byte',
    code: 0x71
};
exports.EthEcRecover = {
    name: 'EthEcRecover',
    code: 0x72
};
exports.Log6 = {
    name: 'Log6',
    code: 0x73
};
exports.Log7 = {
    name: 'Log7',
    code: 0x74
};
exports.Log8 = {
    name: 'Log8',
    code: 0x75
};
exports.Log9 = {
    name: 'Log9',
    code: 0x76
};
exports.ContractIdToAddress = {
    name: 'ContractIdToAddress',
    code: 0x77
};
exports.LoadLocalByIndex = {
    name: 'LoadLocalByIndex',
    code: 0x78
};
exports.StoreLocalByIndex = {
    name: 'StoreLocalByIndex',
    code: 0x79
};
exports.Dup = {
    name: 'Dup',
    code: 0x7a
};
exports.AssertWithErrorCode = {
    name: 'AssertWithErrorCode',
    code: 0x7b
};
exports.Swap = {
    name: 'Swap',
    code: 0x7c
};
exports.BlockHash = {
    name: 'BlockHash',
    code: 0x7d
};
const DEBUG = (stringParts)=>{
    return {
        name: 'DEBUG',
        code: 0x7e,
        stringParts
    };
};
exports.DEBUG = DEBUG;
exports.TxGasPrice = {
    name: 'TxGasPrice',
    code: 0x7f
};
exports.TxGasAmount = {
    name: 'TxGasAmount',
    code: 0x80
};
exports.TxGasFee = {
    name: 'TxGasFee',
    code: 0x81
};
exports.I256Exp = {
    name: 'I256Exp',
    code: 0x82
};
exports.U256Exp = {
    name: 'U256Exp',
    code: 0x83
};
exports.U256ModExp = {
    name: 'U256ModExp',
    code: 0x84
};
exports.VerifyBIP340Schnorr = {
    name: 'VerifyBIP340Schnorr',
    code: 0x85
};
exports.GetSegregatedSignature = {
    name: 'GetSegregatedSignature',
    code: 0x86
};
exports.MulModN = {
    name: 'MulModN',
    code: 0x87
};
exports.AddModN = {
    name: 'AddModN',
    code: 0x88
};
exports.U256ToString = {
    name: 'U256ToString',
    code: 0x89
};
exports.I256ToString = {
    name: 'I256ToString',
    code: 0x8a
};
exports.BoolToString = {
    name: 'BoolToString',
    code: 0x8b
};
exports.GroupOfAddress = {
    name: 'GroupOfAddress',
    code: 0x8c
};
const LoadMutField = (index)=>{
    return {
        name: 'LoadMutField',
        code: 0xa0,
        index
    };
};
exports.LoadMutField = LoadMutField;
const StoreMutField = (index)=>{
    return {
        name: 'StoreMutField',
        code: 0xa1,
        index
    };
};
exports.StoreMutField = StoreMutField;
exports.ApproveAlph = {
    name: 'ApproveAlph',
    code: 0xa2
};
exports.ApproveToken = {
    name: 'ApproveToken',
    code: 0xa3
};
exports.AlphRemaining = {
    name: 'AlphRemaining',
    code: 0xa4
};
exports.TokenRemaining = {
    name: 'TokenRemaining',
    code: 0xa5
};
exports.IsPaying = {
    name: 'IsPaying',
    code: 0xa6
};
exports.TransferAlph = {
    name: 'TransferAlph',
    code: 0xa7
};
exports.TransferAlphFromSelf = {
    name: 'TransferAlphFromSelf',
    code: 0xa8
};
exports.TransferAlphToSelf = {
    name: 'TransferAlphToSelf',
    code: 0xa9
};
exports.TransferToken = {
    name: 'TransferToken',
    code: 0xaa
};
exports.TransferTokenFromSelf = {
    name: 'TransferTokenFromSelf',
    code: 0xab
};
exports.TransferTokenToSelf = {
    name: 'TransferTokenToSelf',
    code: 0xac
};
exports.CreateContract = {
    name: 'CreateContract',
    code: 0xad
};
exports.CreateContractWithToken = {
    name: 'CreateContractWithToken',
    code: 0xae
};
exports.CopyCreateContract = {
    name: 'CopyCreateContract',
    code: 0xaf
};
exports.DestroySelf = {
    name: 'DestroySelf',
    code: 0xb0
};
exports.SelfContractId = {
    name: 'SelfContractId',
    code: 0xb1
};
exports.SelfAddress = {
    name: 'SelfAddress',
    code: 0xb2
};
exports.CallerContractId = {
    name: 'CallerContractId',
    code: 0xb3
};
exports.CallerAddress = {
    name: 'CallerAddress',
    code: 0xb4
};
exports.IsCalledFromTxScript = {
    name: 'IsCalledFromTxScript',
    code: 0xb5
};
exports.CallerInitialStateHash = {
    name: 'CallerInitialStateHash',
    code: 0xb6
};
exports.CallerCodeHash = {
    name: 'CallerCodeHash',
    code: 0xb7
};
exports.ContractInitialStateHash = {
    name: 'ContractInitialStateHash',
    code: 0xb8
};
exports.ContractCodeHash = {
    name: 'ContractCodeHash',
    code: 0xb9
};
exports.MigrateSimple = {
    name: 'MigrateSimple',
    code: 0xba
};
exports.MigrateWithFields = {
    name: 'MigrateWithFields',
    code: 0xbb
};
exports.CopyCreateContractWithToken = {
    name: 'CopyCreateContractWithToken',
    code: 0xbc
};
exports.BurnToken = {
    name: 'BurnToken',
    code: 0xbd
};
exports.LockApprovedAssets = {
    name: 'LockApprovedAssets',
    code: 0xbe
};
exports.CreateSubContract = {
    name: 'CreateSubContract',
    code: 0xbf
};
exports.CreateSubContractWithToken = {
    name: 'CreateSubContractWithToken',
    code: 0xc0
};
exports.CopyCreateSubContract = {
    name: 'CopyCreateSubContract',
    code: 0xc1
};
exports.CopyCreateSubContractWithToken = {
    name: 'CopyCreateSubContractWithToken',
    code: 0xc2
};
exports.LoadMutFieldByIndex = {
    name: 'LoadMutFieldByIndex',
    code: 0xc3
};
exports.StoreMutFieldByIndex = {
    name: 'StoreMutFieldByIndex',
    code: 0xc4
};
exports.ContractExists = {
    name: 'ContractExists',
    code: 0xc5
};
exports.CreateContractAndTransferToken = {
    name: 'CreateContractAndTransferToken',
    code: 0xc6
};
exports.CopyCreateContractAndTransferToken = {
    name: 'CopyCreateContractAndTransferToken',
    code: 0xc7
};
exports.CreateSubContractAndTransferToken = {
    name: 'CreateSubContractAndTransferToken',
    code: 0xc8
};
exports.CopyCreateSubContractAndTransferToken = {
    name: 'CopyCreateSubContractAndTransferToken',
    code: 0xc9
};
exports.NullContractAddress = {
    name: 'NullContractAddress',
    code: 0xca
};
exports.SubContractId = {
    name: 'SubContractId',
    code: 0xcb
};
exports.SubContractIdOf = {
    name: 'SubContractIdOf',
    code: 0xcc
};
exports.ALPHTokenId = {
    name: 'ALPHTokenId',
    code: 0xcd
};
const LoadImmField = (index)=>{
    return {
        name: 'LoadImmField',
        code: 0xce,
        index
    };
};
exports.LoadImmField = LoadImmField;
exports.LoadImmFieldByIndex = {
    name: 'LoadImmFieldByIndex',
    code: 0xcf
};
exports.PayGasFee = {
    name: 'PayGasFee',
    code: 0xd0
};
exports.MinimalContractDeposit = {
    name: 'MinimalContractDeposit',
    code: 0xd1
};
const CreateMapEntry = (immFieldsNum, mutFieldsNum)=>{
    return {
        name: 'CreateMapEntry',
        code: 0xd2,
        immFieldsNum,
        mutFieldsNum
    };
};
exports.CreateMapEntry = CreateMapEntry;
const MethodSelector = (selector)=>{
    return {
        name: 'MethodSelector',
        code: 0xd3,
        selector
    };
};
exports.MethodSelector = MethodSelector;
const CallExternalBySelector = (selector)=>{
    return {
        name: 'CallExternalBySelector',
        code: 0xd4,
        selector
    };
};
exports.CallExternalBySelector = CallExternalBySelector;
class InstrCodec extends codec_1.Codec {
    encode(instr) {
        switch(instr.name){
            case 'CallLocal':
                return new Uint8Array([
                    0x00,
                    ...codec_1.byteCodec.encode(instr.index)
                ]);
            case 'CallExternal':
                return new Uint8Array([
                    0x01,
                    ...codec_1.byteCodec.encode(instr.index)
                ]);
            case 'Return':
                return new Uint8Array([
                    0x02
                ]);
            case 'ConstTrue':
                return new Uint8Array([
                    0x03
                ]);
            case 'ConstFalse':
                return new Uint8Array([
                    0x04
                ]);
            case 'I256Const0':
                return new Uint8Array([
                    0x05
                ]);
            case 'I256Const1':
                return new Uint8Array([
                    0x06
                ]);
            case 'I256Const2':
                return new Uint8Array([
                    0x07
                ]);
            case 'I256Const3':
                return new Uint8Array([
                    0x08
                ]);
            case 'I256Const4':
                return new Uint8Array([
                    0x09
                ]);
            case 'I256Const5':
                return new Uint8Array([
                    0x0a
                ]);
            case 'I256ConstN1':
                return new Uint8Array([
                    0x0b
                ]);
            case 'U256Const0':
                return new Uint8Array([
                    0x0c
                ]);
            case 'U256Const1':
                return new Uint8Array([
                    0x0d
                ]);
            case 'U256Const2':
                return new Uint8Array([
                    0x0e
                ]);
            case 'U256Const3':
                return new Uint8Array([
                    0x0f
                ]);
            case 'U256Const4':
                return new Uint8Array([
                    0x10
                ]);
            case 'U256Const5':
                return new Uint8Array([
                    0x11
                ]);
            case 'I256Const':
                return new Uint8Array([
                    0x12,
                    ...compact_int_codec_1.i256Codec.encode(instr.value)
                ]);
            case 'U256Const':
                return new Uint8Array([
                    0x13,
                    ...compact_int_codec_1.u256Codec.encode(instr.value)
                ]);
            case 'BytesConst':
                return new Uint8Array([
                    0x14,
                    ...bytestring_codec_1.byteStringCodec.encode(instr.value)
                ]);
            case 'AddressConst':
                return new Uint8Array([
                    0x15,
                    ...lockup_script_codec_1.lockupScriptCodec.encode(instr.value)
                ]);
            case 'LoadLocal':
                return new Uint8Array([
                    0x16,
                    ...codec_1.byteCodec.encode(instr.index)
                ]);
            case 'StoreLocal':
                return new Uint8Array([
                    0x17,
                    ...codec_1.byteCodec.encode(instr.index)
                ]);
            case 'Pop':
                return new Uint8Array([
                    0x18
                ]);
            case 'BoolNot':
                return new Uint8Array([
                    0x19
                ]);
            case 'BoolAnd':
                return new Uint8Array([
                    0x1a
                ]);
            case 'BoolOr':
                return new Uint8Array([
                    0x1b
                ]);
            case 'BoolEq':
                return new Uint8Array([
                    0x1c
                ]);
            case 'BoolNeq':
                return new Uint8Array([
                    0x1d
                ]);
            case 'BoolToByteVec':
                return new Uint8Array([
                    0x1e
                ]);
            case 'I256Add':
                return new Uint8Array([
                    0x1f
                ]);
            case 'I256Sub':
                return new Uint8Array([
                    0x20
                ]);
            case 'I256Mul':
                return new Uint8Array([
                    0x21
                ]);
            case 'I256Div':
                return new Uint8Array([
                    0x22
                ]);
            case 'I256Mod':
                return new Uint8Array([
                    0x23
                ]);
            case 'I256Eq':
                return new Uint8Array([
                    0x24
                ]);
            case 'I256Neq':
                return new Uint8Array([
                    0x25
                ]);
            case 'I256Lt':
                return new Uint8Array([
                    0x26
                ]);
            case 'I256Le':
                return new Uint8Array([
                    0x27
                ]);
            case 'I256Gt':
                return new Uint8Array([
                    0x28
                ]);
            case 'I256Ge':
                return new Uint8Array([
                    0x29
                ]);
            case 'U256Add':
                return new Uint8Array([
                    0x2a
                ]);
            case 'U256Sub':
                return new Uint8Array([
                    0x2b
                ]);
            case 'U256Mul':
                return new Uint8Array([
                    0x2c
                ]);
            case 'U256Div':
                return new Uint8Array([
                    0x2d
                ]);
            case 'U256Mod':
                return new Uint8Array([
                    0x2e
                ]);
            case 'U256Eq':
                return new Uint8Array([
                    0x2f
                ]);
            case 'U256Neq':
                return new Uint8Array([
                    0x30
                ]);
            case 'U256Lt':
                return new Uint8Array([
                    0x31
                ]);
            case 'U256Le':
                return new Uint8Array([
                    0x32
                ]);
            case 'U256Gt':
                return new Uint8Array([
                    0x33
                ]);
            case 'U256Ge':
                return new Uint8Array([
                    0x34
                ]);
            case 'U256ModAdd':
                return new Uint8Array([
                    0x35
                ]);
            case 'U256ModSub':
                return new Uint8Array([
                    0x36
                ]);
            case 'U256ModMul':
                return new Uint8Array([
                    0x37
                ]);
            case 'U256BitAnd':
                return new Uint8Array([
                    0x38
                ]);
            case 'U256BitOr':
                return new Uint8Array([
                    0x39
                ]);
            case 'U256Xor':
                return new Uint8Array([
                    0x3a
                ]);
            case 'U256SHL':
                return new Uint8Array([
                    0x3b
                ]);
            case 'U256SHR':
                return new Uint8Array([
                    0x3c
                ]);
            case 'I256ToU256':
                return new Uint8Array([
                    0x3d
                ]);
            case 'I256ToByteVec':
                return new Uint8Array([
                    0x3e
                ]);
            case 'U256ToI256':
                return new Uint8Array([
                    0x3f
                ]);
            case 'U256ToByteVec':
                return new Uint8Array([
                    0x40
                ]);
            case 'ByteVecEq':
                return new Uint8Array([
                    0x41
                ]);
            case 'ByteVecNeq':
                return new Uint8Array([
                    0x42
                ]);
            case 'ByteVecSize':
                return new Uint8Array([
                    0x43
                ]);
            case 'ByteVecConcat':
                return new Uint8Array([
                    0x44
                ]);
            case 'AddressEq':
                return new Uint8Array([
                    0x45
                ]);
            case 'AddressNeq':
                return new Uint8Array([
                    0x46
                ]);
            case 'AddressToByteVec':
                return new Uint8Array([
                    0x47
                ]);
            case 'IsAssetAddress':
                return new Uint8Array([
                    0x48
                ]);
            case 'IsContractAddress':
                return new Uint8Array([
                    0x49
                ]);
            case 'Jump':
                return new Uint8Array([
                    0x4a,
                    ...compact_int_codec_1.i32Codec.encode(instr.offset)
                ]);
            case 'IfTrue':
                return new Uint8Array([
                    0x4b,
                    ...compact_int_codec_1.i32Codec.encode(instr.offset)
                ]);
            case 'IfFalse':
                return new Uint8Array([
                    0x4c,
                    ...compact_int_codec_1.i32Codec.encode(instr.offset)
                ]);
            case 'Assert':
                return new Uint8Array([
                    0x4d
                ]);
            case 'Blake2b':
                return new Uint8Array([
                    0x4e
                ]);
            case 'Keccak256':
                return new Uint8Array([
                    0x4f
                ]);
            case 'Sha256':
                return new Uint8Array([
                    0x50
                ]);
            case 'Sha3':
                return new Uint8Array([
                    0x51
                ]);
            case 'VerifyTxSignature':
                return new Uint8Array([
                    0x52
                ]);
            case 'VerifySecP256K1':
                return new Uint8Array([
                    0x53
                ]);
            case 'VerifyED25519':
                return new Uint8Array([
                    0x54
                ]);
            case 'NetworkId':
                return new Uint8Array([
                    0x55
                ]);
            case 'BlockTimeStamp':
                return new Uint8Array([
                    0x56
                ]);
            case 'BlockTarget':
                return new Uint8Array([
                    0x57
                ]);
            case 'TxId':
                return new Uint8Array([
                    0x58
                ]);
            case 'TxInputAddressAt':
                return new Uint8Array([
                    0x59
                ]);
            case 'TxInputsSize':
                return new Uint8Array([
                    0x5a
                ]);
            case 'VerifyAbsoluteLocktime':
                return new Uint8Array([
                    0x5b
                ]);
            case 'VerifyRelativeLocktime':
                return new Uint8Array([
                    0x5c
                ]);
            case 'Log1':
                return new Uint8Array([
                    0x5d
                ]);
            case 'Log2':
                return new Uint8Array([
                    0x5e
                ]);
            case 'Log3':
                return new Uint8Array([
                    0x5f
                ]);
            case 'Log4':
                return new Uint8Array([
                    0x60
                ]);
            case 'Log5':
                return new Uint8Array([
                    0x61
                ]);
            case 'ByteVecSlice':
                return new Uint8Array([
                    0x62
                ]);
            case 'ByteVecToAddress':
                return new Uint8Array([
                    0x63
                ]);
            case 'Encode':
                return new Uint8Array([
                    0x64
                ]);
            case 'Zeros':
                return new Uint8Array([
                    0x65
                ]);
            case 'U256To1Byte':
                return new Uint8Array([
                    0x66
                ]);
            case 'U256To2Byte':
                return new Uint8Array([
                    0x67
                ]);
            case 'U256To4Byte':
                return new Uint8Array([
                    0x68
                ]);
            case 'U256To8Byte':
                return new Uint8Array([
                    0x69
                ]);
            case 'U256To16Byte':
                return new Uint8Array([
                    0x6a
                ]);
            case 'U256To32Byte':
                return new Uint8Array([
                    0x6b
                ]);
            case 'U256From1Byte':
                return new Uint8Array([
                    0x6c
                ]);
            case 'U256From2Byte':
                return new Uint8Array([
                    0x6d
                ]);
            case 'U256From4Byte':
                return new Uint8Array([
                    0x6e
                ]);
            case 'U256From8Byte':
                return new Uint8Array([
                    0x6f
                ]);
            case 'U256From16Byte':
                return new Uint8Array([
                    0x70
                ]);
            case 'U256From32Byte':
                return new Uint8Array([
                    0x71
                ]);
            case 'EthEcRecover':
                return new Uint8Array([
                    0x72
                ]);
            case 'Log6':
                return new Uint8Array([
                    0x73
                ]);
            case 'Log7':
                return new Uint8Array([
                    0x74
                ]);
            case 'Log8':
                return new Uint8Array([
                    0x75
                ]);
            case 'Log9':
                return new Uint8Array([
                    0x76
                ]);
            case 'ContractIdToAddress':
                return new Uint8Array([
                    0x77
                ]);
            case 'LoadLocalByIndex':
                return new Uint8Array([
                    0x78
                ]);
            case 'StoreLocalByIndex':
                return new Uint8Array([
                    0x79
                ]);
            case 'Dup':
                return new Uint8Array([
                    0x7a
                ]);
            case 'AssertWithErrorCode':
                return new Uint8Array([
                    0x7b
                ]);
            case 'Swap':
                return new Uint8Array([
                    0x7c
                ]);
            case 'BlockHash':
                return new Uint8Array([
                    0x7d
                ]);
            case 'DEBUG':
                return new Uint8Array([
                    0x7e,
                    ...bytestring_codec_1.byteStringsCodec.encode(instr.stringParts)
                ]);
            case 'TxGasPrice':
                return new Uint8Array([
                    0x7f
                ]);
            case 'TxGasAmount':
                return new Uint8Array([
                    0x80
                ]);
            case 'TxGasFee':
                return new Uint8Array([
                    0x81
                ]);
            case 'I256Exp':
                return new Uint8Array([
                    0x82
                ]);
            case 'U256Exp':
                return new Uint8Array([
                    0x83
                ]);
            case 'U256ModExp':
                return new Uint8Array([
                    0x84
                ]);
            case 'VerifyBIP340Schnorr':
                return new Uint8Array([
                    0x85
                ]);
            case 'GetSegregatedSignature':
                return new Uint8Array([
                    0x86
                ]);
            case 'MulModN':
                return new Uint8Array([
                    0x87
                ]);
            case 'AddModN':
                return new Uint8Array([
                    0x88
                ]);
            case 'U256ToString':
                return new Uint8Array([
                    0x89
                ]);
            case 'I256ToString':
                return new Uint8Array([
                    0x8a
                ]);
            case 'BoolToString':
                return new Uint8Array([
                    0x8b
                ]);
            case 'GroupOfAddress':
                return new Uint8Array([
                    0x8c
                ]);
            case 'LoadMutField':
                return new Uint8Array([
                    0xa0,
                    ...codec_1.byteCodec.encode(instr.index)
                ]);
            case 'StoreMutField':
                return new Uint8Array([
                    0xa1,
                    ...codec_1.byteCodec.encode(instr.index)
                ]);
            case 'ApproveAlph':
                return new Uint8Array([
                    0xa2
                ]);
            case 'ApproveToken':
                return new Uint8Array([
                    0xa3
                ]);
            case 'AlphRemaining':
                return new Uint8Array([
                    0xa4
                ]);
            case 'TokenRemaining':
                return new Uint8Array([
                    0xa5
                ]);
            case 'IsPaying':
                return new Uint8Array([
                    0xa6
                ]);
            case 'TransferAlph':
                return new Uint8Array([
                    0xa7
                ]);
            case 'TransferAlphFromSelf':
                return new Uint8Array([
                    0xa8
                ]);
            case 'TransferAlphToSelf':
                return new Uint8Array([
                    0xa9
                ]);
            case 'TransferToken':
                return new Uint8Array([
                    0xaa
                ]);
            case 'TransferTokenFromSelf':
                return new Uint8Array([
                    0xab
                ]);
            case 'TransferTokenToSelf':
                return new Uint8Array([
                    0xac
                ]);
            case 'CreateContract':
                return new Uint8Array([
                    0xad
                ]);
            case 'CreateContractWithToken':
                return new Uint8Array([
                    0xae
                ]);
            case 'CopyCreateContract':
                return new Uint8Array([
                    0xaf
                ]);
            case 'DestroySelf':
                return new Uint8Array([
                    0xb0
                ]);
            case 'SelfContractId':
                return new Uint8Array([
                    0xb1
                ]);
            case 'SelfAddress':
                return new Uint8Array([
                    0xb2
                ]);
            case 'CallerContractId':
                return new Uint8Array([
                    0xb3
                ]);
            case 'CallerAddress':
                return new Uint8Array([
                    0xb4
                ]);
            case 'IsCalledFromTxScript':
                return new Uint8Array([
                    0xb5
                ]);
            case 'CallerInitialStateHash':
                return new Uint8Array([
                    0xb6
                ]);
            case 'CallerCodeHash':
                return new Uint8Array([
                    0xb7
                ]);
            case 'ContractInitialStateHash':
                return new Uint8Array([
                    0xb8
                ]);
            case 'ContractCodeHash':
                return new Uint8Array([
                    0xb9
                ]);
            case 'MigrateSimple':
                return new Uint8Array([
                    0xba
                ]);
            case 'MigrateWithFields':
                return new Uint8Array([
                    0xbb
                ]);
            case 'CopyCreateContractWithToken':
                return new Uint8Array([
                    0xbc
                ]);
            case 'BurnToken':
                return new Uint8Array([
                    0xbd
                ]);
            case 'LockApprovedAssets':
                return new Uint8Array([
                    0xbe
                ]);
            case 'CreateSubContract':
                return new Uint8Array([
                    0xbf
                ]);
            case 'CreateSubContractWithToken':
                return new Uint8Array([
                    0xc0
                ]);
            case 'CopyCreateSubContract':
                return new Uint8Array([
                    0xc1
                ]);
            case 'CopyCreateSubContractWithToken':
                return new Uint8Array([
                    0xc2
                ]);
            case 'LoadMutFieldByIndex':
                return new Uint8Array([
                    0xc3
                ]);
            case 'StoreMutFieldByIndex':
                return new Uint8Array([
                    0xc4
                ]);
            case 'ContractExists':
                return new Uint8Array([
                    0xc5
                ]);
            case 'CreateContractAndTransferToken':
                return new Uint8Array([
                    0xc6
                ]);
            case 'CopyCreateContractAndTransferToken':
                return new Uint8Array([
                    0xc7
                ]);
            case 'CreateSubContractAndTransferToken':
                return new Uint8Array([
                    0xc8
                ]);
            case 'CopyCreateSubContractAndTransferToken':
                return new Uint8Array([
                    0xc9
                ]);
            case 'NullContractAddress':
                return new Uint8Array([
                    0xca
                ]);
            case 'SubContractId':
                return new Uint8Array([
                    0xcb
                ]);
            case 'SubContractIdOf':
                return new Uint8Array([
                    0xcc
                ]);
            case 'ALPHTokenId':
                return new Uint8Array([
                    0xcd
                ]);
            case 'LoadImmField':
                return new Uint8Array([
                    0xce,
                    ...codec_1.byteCodec.encode(instr.index)
                ]);
            case 'LoadImmFieldByIndex':
                return new Uint8Array([
                    0xcf
                ]);
            case 'PayGasFee':
                return new Uint8Array([
                    0xd0
                ]);
            case 'MinimalContractDeposit':
                return new Uint8Array([
                    0xd1
                ]);
            case 'CreateMapEntry':
                return new Uint8Array([
                    0xd2,
                    ...codec_1.byteCodec.encode(instr.immFieldsNum),
                    ...codec_1.byteCodec.encode(instr.mutFieldsNum)
                ]);
            case 'MethodSelector':
                return new Uint8Array([
                    0xd3,
                    ...int_as_4bytes_codec_1.intAs4BytesCodec.encode(instr.selector)
                ]);
            case 'CallExternalBySelector':
                return new Uint8Array([
                    0xd4,
                    ...int_as_4bytes_codec_1.intAs4BytesCodec.encode(instr.selector)
                ]);
        }
    }
    _decode(input) {
        const code = input.consumeByte();
        switch(code){
            case 0x00:
                return (0, exports.CallLocal)(codec_1.byteCodec._decode(input));
            case 0x01:
                return (0, exports.CallExternal)(codec_1.byteCodec._decode(input));
            case 0x02:
                return exports.Return;
            case 0x03:
                return exports.ConstTrue;
            case 0x04:
                return exports.ConstFalse;
            case 0x05:
                return exports.I256Const0;
            case 0x06:
                return exports.I256Const1;
            case 0x07:
                return exports.I256Const2;
            case 0x08:
                return exports.I256Const3;
            case 0x09:
                return exports.I256Const4;
            case 0x0a:
                return exports.I256Const5;
            case 0x0b:
                return exports.I256ConstN1;
            case 0x0c:
                return exports.U256Const0;
            case 0x0d:
                return exports.U256Const1;
            case 0x0e:
                return exports.U256Const2;
            case 0x0f:
                return exports.U256Const3;
            case 0x10:
                return exports.U256Const4;
            case 0x11:
                return exports.U256Const5;
            case 0x12:
                return (0, exports.I256Const)(compact_int_codec_1.i256Codec._decode(input));
            case 0x13:
                return (0, exports.U256Const)(compact_int_codec_1.u256Codec._decode(input));
            case 0x14:
                return (0, exports.BytesConst)(bytestring_codec_1.byteStringCodec._decode(input));
            case 0x15:
                return (0, exports.AddressConst)(lockup_script_codec_1.lockupScriptCodec._decode(input));
            case 0x16:
                return (0, exports.LoadLocal)(codec_1.byteCodec._decode(input));
            case 0x17:
                return (0, exports.StoreLocal)(codec_1.byteCodec._decode(input));
            case 0x18:
                return exports.Pop;
            case 0x19:
                return exports.BoolNot;
            case 0x1a:
                return exports.BoolAnd;
            case 0x1b:
                return exports.BoolOr;
            case 0x1c:
                return exports.BoolEq;
            case 0x1d:
                return exports.BoolNeq;
            case 0x1e:
                return exports.BoolToByteVec;
            case 0x1f:
                return exports.I256Add;
            case 0x20:
                return exports.I256Sub;
            case 0x21:
                return exports.I256Mul;
            case 0x22:
                return exports.I256Div;
            case 0x23:
                return exports.I256Mod;
            case 0x24:
                return exports.I256Eq;
            case 0x25:
                return exports.I256Neq;
            case 0x26:
                return exports.I256Lt;
            case 0x27:
                return exports.I256Le;
            case 0x28:
                return exports.I256Gt;
            case 0x29:
                return exports.I256Ge;
            case 0x2a:
                return exports.U256Add;
            case 0x2b:
                return exports.U256Sub;
            case 0x2c:
                return exports.U256Mul;
            case 0x2d:
                return exports.U256Div;
            case 0x2e:
                return exports.U256Mod;
            case 0x2f:
                return exports.U256Eq;
            case 0x30:
                return exports.U256Neq;
            case 0x31:
                return exports.U256Lt;
            case 0x32:
                return exports.U256Le;
            case 0x33:
                return exports.U256Gt;
            case 0x34:
                return exports.U256Ge;
            case 0x35:
                return exports.U256ModAdd;
            case 0x36:
                return exports.U256ModSub;
            case 0x37:
                return exports.U256ModMul;
            case 0x38:
                return exports.U256BitAnd;
            case 0x39:
                return exports.U256BitOr;
            case 0x3a:
                return exports.U256Xor;
            case 0x3b:
                return exports.U256SHL;
            case 0x3c:
                return exports.U256SHR;
            case 0x3d:
                return exports.I256ToU256;
            case 0x3e:
                return exports.I256ToByteVec;
            case 0x3f:
                return exports.U256ToI256;
            case 0x40:
                return exports.U256ToByteVec;
            case 0x41:
                return exports.ByteVecEq;
            case 0x42:
                return exports.ByteVecNeq;
            case 0x43:
                return exports.ByteVecSize;
            case 0x44:
                return exports.ByteVecConcat;
            case 0x45:
                return exports.AddressEq;
            case 0x46:
                return exports.AddressNeq;
            case 0x47:
                return exports.AddressToByteVec;
            case 0x48:
                return exports.IsAssetAddress;
            case 0x49:
                return exports.IsContractAddress;
            case 0x4a:
                return (0, exports.Jump)(compact_int_codec_1.i32Codec._decode(input));
            case 0x4b:
                return (0, exports.IfTrue)(compact_int_codec_1.i32Codec._decode(input));
            case 0x4c:
                return (0, exports.IfFalse)(compact_int_codec_1.i32Codec._decode(input));
            case 0x4d:
                return exports.Assert;
            case 0x4e:
                return exports.Blake2b;
            case 0x4f:
                return exports.Keccak256;
            case 0x50:
                return exports.Sha256;
            case 0x51:
                return exports.Sha3;
            case 0x52:
                return exports.VerifyTxSignature;
            case 0x53:
                return exports.VerifySecP256K1;
            case 0x54:
                return exports.VerifyED25519;
            case 0x55:
                return exports.NetworkId;
            case 0x56:
                return exports.BlockTimeStamp;
            case 0x57:
                return exports.BlockTarget;
            case 0x58:
                return exports.TxId;
            case 0x59:
                return exports.TxInputAddressAt;
            case 0x5a:
                return exports.TxInputsSize;
            case 0x5b:
                return exports.VerifyAbsoluteLocktime;
            case 0x5c:
                return exports.VerifyRelativeLocktime;
            case 0x5d:
                return exports.Log1;
            case 0x5e:
                return exports.Log2;
            case 0x5f:
                return exports.Log3;
            case 0x60:
                return exports.Log4;
            case 0x61:
                return exports.Log5;
            case 0x62:
                return exports.ByteVecSlice;
            case 0x63:
                return exports.ByteVecToAddress;
            case 0x64:
                return exports.Encode;
            case 0x65:
                return exports.Zeros;
            case 0x66:
                return exports.U256To1Byte;
            case 0x67:
                return exports.U256To2Byte;
            case 0x68:
                return exports.U256To4Byte;
            case 0x69:
                return exports.U256To8Byte;
            case 0x6a:
                return exports.U256To16Byte;
            case 0x6b:
                return exports.U256To32Byte;
            case 0x6c:
                return exports.U256From1Byte;
            case 0x6d:
                return exports.U256From2Byte;
            case 0x6e:
                return exports.U256From4Byte;
            case 0x6f:
                return exports.U256From8Byte;
            case 0x70:
                return exports.U256From16Byte;
            case 0x71:
                return exports.U256From32Byte;
            case 0x72:
                return exports.EthEcRecover;
            case 0x73:
                return exports.Log6;
            case 0x74:
                return exports.Log7;
            case 0x75:
                return exports.Log8;
            case 0x76:
                return exports.Log9;
            case 0x77:
                return exports.ContractIdToAddress;
            case 0x78:
                return exports.LoadLocalByIndex;
            case 0x79:
                return exports.StoreLocalByIndex;
            case 0x7a:
                return exports.Dup;
            case 0x7b:
                return exports.AssertWithErrorCode;
            case 0x7c:
                return exports.Swap;
            case 0x7d:
                return exports.BlockHash;
            case 0x7e:
                return (0, exports.DEBUG)(bytestring_codec_1.byteStringsCodec._decode(input));
            case 0x7f:
                return exports.TxGasPrice;
            case 0x80:
                return exports.TxGasAmount;
            case 0x81:
                return exports.TxGasFee;
            case 0x82:
                return exports.I256Exp;
            case 0x83:
                return exports.U256Exp;
            case 0x84:
                return exports.U256ModExp;
            case 0x85:
                return exports.VerifyBIP340Schnorr;
            case 0x86:
                return exports.GetSegregatedSignature;
            case 0x87:
                return exports.MulModN;
            case 0x88:
                return exports.AddModN;
            case 0x89:
                return exports.U256ToString;
            case 0x8a:
                return exports.I256ToString;
            case 0x8b:
                return exports.BoolToString;
            case 0x8c:
                return exports.GroupOfAddress;
            case 0xa0:
                return (0, exports.LoadMutField)(codec_1.byteCodec._decode(input));
            case 0xa1:
                return (0, exports.StoreMutField)(codec_1.byteCodec._decode(input));
            case 0xa2:
                return exports.ApproveAlph;
            case 0xa3:
                return exports.ApproveToken;
            case 0xa4:
                return exports.AlphRemaining;
            case 0xa5:
                return exports.TokenRemaining;
            case 0xa6:
                return exports.IsPaying;
            case 0xa7:
                return exports.TransferAlph;
            case 0xa8:
                return exports.TransferAlphFromSelf;
            case 0xa9:
                return exports.TransferAlphToSelf;
            case 0xaa:
                return exports.TransferToken;
            case 0xab:
                return exports.TransferTokenFromSelf;
            case 0xac:
                return exports.TransferTokenToSelf;
            case 0xad:
                return exports.CreateContract;
            case 0xae:
                return exports.CreateContractWithToken;
            case 0xaf:
                return exports.CopyCreateContract;
            case 0xb0:
                return exports.DestroySelf;
            case 0xb1:
                return exports.SelfContractId;
            case 0xb2:
                return exports.SelfAddress;
            case 0xb3:
                return exports.CallerContractId;
            case 0xb4:
                return exports.CallerAddress;
            case 0xb5:
                return exports.IsCalledFromTxScript;
            case 0xb6:
                return exports.CallerInitialStateHash;
            case 0xb7:
                return exports.CallerCodeHash;
            case 0xb8:
                return exports.ContractInitialStateHash;
            case 0xb9:
                return exports.ContractCodeHash;
            case 0xba:
                return exports.MigrateSimple;
            case 0xbb:
                return exports.MigrateWithFields;
            case 0xbc:
                return exports.CopyCreateContractWithToken;
            case 0xbd:
                return exports.BurnToken;
            case 0xbe:
                return exports.LockApprovedAssets;
            case 0xbf:
                return exports.CreateSubContract;
            case 0xc0:
                return exports.CreateSubContractWithToken;
            case 0xc1:
                return exports.CopyCreateSubContract;
            case 0xc2:
                return exports.CopyCreateSubContractWithToken;
            case 0xc3:
                return exports.LoadMutFieldByIndex;
            case 0xc4:
                return exports.StoreMutFieldByIndex;
            case 0xc5:
                return exports.ContractExists;
            case 0xc6:
                return exports.CreateContractAndTransferToken;
            case 0xc7:
                return exports.CopyCreateContractAndTransferToken;
            case 0xc8:
                return exports.CreateSubContractAndTransferToken;
            case 0xc9:
                return exports.CopyCreateSubContractAndTransferToken;
            case 0xca:
                return exports.NullContractAddress;
            case 0xcb:
                return exports.SubContractId;
            case 0xcc:
                return exports.SubContractIdOf;
            case 0xcd:
                return exports.ALPHTokenId;
            case 0xce:
                return (0, exports.LoadImmField)(codec_1.byteCodec._decode(input));
            case 0xcf:
                return exports.LoadImmFieldByIndex;
            case 0xd0:
                return exports.PayGasFee;
            case 0xd1:
                return exports.MinimalContractDeposit;
            case 0xd2:
                return (0, exports.CreateMapEntry)(codec_1.byteCodec._decode(input), codec_1.byteCodec._decode(input));
            case 0xd3:
                return (0, exports.MethodSelector)(int_as_4bytes_codec_1.intAs4BytesCodec._decode(input));
            case 0xd4:
                return (0, exports.CallExternalBySelector)(int_as_4bytes_codec_1.intAs4BytesCodec._decode(input));
            default:
                throw new Error(`Unknown instr code: ${code}`);
        }
    }
}
exports.InstrCodec = InstrCodec;
exports.instrCodec = new InstrCodec();
exports.instrsCodec = new array_codec_1.ArrayCodec(exports.instrCodec);
function checkU256(number) {
    if (number < 0n || number >= 2n ** 256n) {
        throw new Error(`Invalid u256 number: ${number}`);
    }
}
function toU256(number) {
    checkU256(number);
    switch(number){
        case 0n:
            return exports.U256Const0;
        case 1n:
            return exports.U256Const1;
        case 2n:
            return exports.U256Const2;
        case 3n:
            return exports.U256Const3;
        case 4n:
            return exports.U256Const4;
        case 5n:
            return exports.U256Const5;
        default:
            return (0, exports.U256Const)(number);
    }
}
exports.toU256 = toU256;
function checkI256(number) {
    const upperBound = 2n ** 255n;
    if (number < -upperBound || number >= upperBound) {
        throw new Error(`Invalid i256 number: ${number}`);
    }
}
function toI256(number) {
    checkI256(number);
    switch(number){
        case 0n:
            return exports.I256Const0;
        case 1n:
            return exports.I256Const1;
        case 2n:
            return exports.I256Const2;
        case 3n:
            return exports.I256Const3;
        case 4n:
            return exports.I256Const4;
        case 5n:
            return exports.I256Const5;
        case -1n:
            return exports.I256ConstN1;
        default:
            return (0, exports.I256Const)(number);
    }
}
exports.toI256 = toI256;
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/method-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.methodsCodec = exports.methodCodec = exports.MethodCodec = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
const compact_int_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const instr_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/instr-codec.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
function decodeAssetModifier(encoded) {
    const usePayToContractOnly = (encoded & 4) !== 0;
    switch(encoded & 3){
        case 0:
            return {
                usePayToContractOnly,
                usePreapprovedAssets: false,
                useContractAssets: false
            };
        case 1:
            return {
                usePayToContractOnly,
                usePreapprovedAssets: true,
                useContractAssets: true
            };
        case 2:
            return {
                usePayToContractOnly,
                usePreapprovedAssets: false,
                useContractAssets: true
            };
        case 3:
            return {
                usePayToContractOnly,
                usePreapprovedAssets: true,
                useContractAssets: false
            };
        default:
            throw new Error(`Invalid asset modifier: ${encoded}`);
    }
}
function encodeAssetModifier(arg) {
    const encoded = !arg.usePreapprovedAssets && !arg.useContractAssets ? 0 : arg.usePreapprovedAssets && arg.useContractAssets ? 1 : !arg.usePreapprovedAssets && arg.useContractAssets ? 2 : 3;
    return encoded | (arg.usePayToContractOnly ? 4 : 0);
}
class MethodCodec extends codec_1.Codec {
    encode(method) {
        const bytes = [];
        bytes.push(codec_1.boolCodec.encode(method.isPublic));
        bytes.push(new Uint8Array([
            encodeAssetModifier(method)
        ]));
        bytes.push(compact_int_codec_1.i32Codec.encode(method.argsLength));
        bytes.push(compact_int_codec_1.i32Codec.encode(method.localsLength));
        bytes.push(compact_int_codec_1.i32Codec.encode(method.returnLength));
        bytes.push(instr_codec_1.instrsCodec.encode(method.instrs));
        return (0, utils_1.concatBytes)(bytes);
    }
    _decode(input) {
        const isPublic = codec_1.boolCodec._decode(input);
        const assetModifier = decodeAssetModifier(codec_1.byteCodec._decode(input));
        const argsLength = compact_int_codec_1.i32Codec._decode(input);
        const localsLength = compact_int_codec_1.i32Codec._decode(input);
        const returnLength = compact_int_codec_1.i32Codec._decode(input);
        const instrs = instr_codec_1.instrsCodec._decode(input);
        return {
            ...assetModifier,
            isPublic,
            argsLength,
            localsLength,
            returnLength,
            instrs
        };
    }
}
exports.MethodCodec = MethodCodec;
exports.methodCodec = new MethodCodec();
exports.methodsCodec = new array_codec_1.ArrayCodec(exports.methodCodec);
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/option-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.option = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const undefinedCodec = new class extends codec_1.Codec {
    encode() {
        return new Uint8Array([]);
    }
    _decode() {
        return undefined;
    }
}();
function option(codec) {
    return new codec_1.EnumCodec('option', {
        None: undefinedCodec,
        Some: codec
    });
}
exports.option = option;
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/script-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.statefulScriptCodecOpt = exports.scriptCodec = exports.ScriptCodec = void 0;
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const method_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/method-codec.js [app-ssr] (ecmascript)");
const option_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/option-codec.js [app-ssr] (ecmascript)");
class ScriptCodec extends codec_1.Codec {
    encode(input) {
        return method_codec_1.methodsCodec.encode(input.methods);
    }
    _decode(input) {
        return {
            methods: method_codec_1.methodsCodec._decode(input)
        };
    }
}
exports.ScriptCodec = ScriptCodec;
exports.scriptCodec = new ScriptCodec();
exports.statefulScriptCodecOpt = (0, option_codec_1.option)(exports.scriptCodec);
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/val.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.valsCodec = exports.valCodec = void 0;
const compact_int_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)");
const bytestring_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/bytestring-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const lockup_script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/lockup-script-codec.js [app-ssr] (ecmascript)");
const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
exports.valCodec = new codec_1.EnumCodec('val', {
    Bool: codec_1.boolCodec,
    I256: compact_int_codec_1.i256Codec,
    U256: compact_int_codec_1.u256Codec,
    ByteVec: bytestring_codec_1.byteStringCodec,
    Address: lockup_script_codec_1.lockupScriptCodec
});
exports.valsCodec = new array_codec_1.ArrayCodec(exports.valCodec);
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/unlock-script-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.encodedSameAsPrevious = exports.unlockScriptCodec = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
const compact_int_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/script-codec.js [app-ssr] (ecmascript)");
const val_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/val.js [app-ssr] (ecmascript)");
const p2pkhCodec = new codec_1.FixedSizeCodec(33);
const keyWithIndexCodec = new codec_1.ObjectCodec({
    publicKey: p2pkhCodec,
    index: compact_int_codec_1.i32Codec
});
const p2mpkhCodec = new array_codec_1.ArrayCodec(keyWithIndexCodec);
const p2shCodec = new codec_1.ObjectCodec({
    script: script_codec_1.scriptCodec,
    params: val_1.valsCodec
});
const sameAsPreviousCodec = new class extends codec_1.Codec {
    encode() {
        return new Uint8Array([]);
    }
    _decode() {
        return 'SameAsPrevious';
    }
}();
exports.unlockScriptCodec = new codec_1.EnumCodec('unlock script', {
    P2PKH: p2pkhCodec,
    P2MPKH: p2mpkhCodec,
    P2SH: p2shCodec,
    SameAsPrevious: sameAsPreviousCodec
});
exports.encodedSameAsPrevious = exports.unlockScriptCodec.encode({
    kind: 'SameAsPrevious',
    value: 'SameAsPrevious'
});
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/input-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.inputsCodec = exports.inputCodec = exports.InputCodec = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const unlock_script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/unlock-script-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
const int_as_4bytes_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/int-as-4bytes-codec.js [app-ssr] (ecmascript)");
class InputCodec extends codec_1.ObjectCodec {
    static toAssetInputs(inputs) {
        return inputs.map((input)=>{
            const hint = input.hint;
            const key = (0, utils_1.binToHex)(input.key);
            const unlockScript = unlock_script_codec_1.unlockScriptCodec.encode(input.unlockScript);
            return {
                outputRef: {
                    hint,
                    key
                },
                unlockScript: (0, utils_1.binToHex)(unlockScript)
            };
        });
    }
    static fromAssetInputs(inputs) {
        return inputs.map((input)=>{
            const hint = input.outputRef.hint;
            const key = (0, utils_1.hexToBinUnsafe)(input.outputRef.key);
            const unlockScript = unlock_script_codec_1.unlockScriptCodec.decode((0, utils_1.hexToBinUnsafe)(input.unlockScript));
            return {
                hint,
                key,
                unlockScript
            };
        });
    }
}
exports.InputCodec = InputCodec;
exports.inputCodec = new InputCodec({
    hint: int_as_4bytes_codec_1.intAs4BytesCodec,
    key: codec_1.byte32Codec,
    unlockScript: unlock_script_codec_1.unlockScriptCodec
});
exports.inputsCodec = new array_codec_1.ArrayCodec(exports.inputCodec);
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/signature-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.signaturesCodec = exports.signatureCodec = void 0;
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
exports.signatureCodec = new codec_1.FixedSizeCodec(64);
exports.signaturesCodec = new array_codec_1.ArrayCodec(exports.signatureCodec);
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/unsigned-tx-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unsignedTxCodec = exports.UnsignedTxCodec = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/script-codec.js [app-ssr] (ecmascript)");
const compact_int_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)");
const input_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/input-codec.js [app-ssr] (ecmascript)");
const asset_output_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/asset-output-codec.js [app-ssr] (ecmascript)");
const hash_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/hash.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
class UnsignedTxCodec extends codec_1.ObjectCodec {
    encodeApiUnsignedTx(input) {
        const decoded = UnsignedTxCodec.fromApiUnsignedTx(input);
        return this.encode(decoded);
    }
    decodeApiUnsignedTx(input) {
        const decoded = this.decode(input);
        return UnsignedTxCodec.toApiUnsignedTx(decoded);
    }
    static txId(unsignedTx) {
        return (0, utils_1.binToHex)((0, hash_1.blakeHash)(exports.unsignedTxCodec.encode(unsignedTx)));
    }
    static toApiUnsignedTx(unsigned) {
        const txId = UnsignedTxCodec.txId(unsigned);
        const txIdBytes = (0, utils_1.hexToBinUnsafe)(txId);
        const version = unsigned.version;
        const networkId = unsigned.networkId;
        const gasAmount = unsigned.gasAmount;
        const gasPrice = unsigned.gasPrice.toString();
        const inputs = input_codec_1.InputCodec.toAssetInputs(unsigned.inputs);
        const fixedOutputs = asset_output_codec_1.AssetOutputCodec.toFixedAssetOutputs(txIdBytes, unsigned.fixedOutputs);
        let scriptOpt = undefined;
        if (unsigned.statefulScript.kind === 'Some') {
            scriptOpt = (0, utils_1.binToHex)(script_codec_1.scriptCodec.encode(unsigned.statefulScript.value));
        }
        return {
            txId,
            version,
            networkId,
            gasAmount,
            scriptOpt,
            gasPrice,
            inputs,
            fixedOutputs
        };
    }
    static fromApiUnsignedTx(unsignedTx) {
        const version = unsignedTx.version;
        const networkId = unsignedTx.networkId;
        const gasAmount = unsignedTx.gasAmount;
        const gasPrice = BigInt(unsignedTx.gasPrice);
        const inputs = input_codec_1.InputCodec.fromAssetInputs(unsignedTx.inputs);
        const fixedOutputs = asset_output_codec_1.AssetOutputCodec.fromFixedAssetOutputs(unsignedTx.fixedOutputs);
        const statefulScript = unsignedTx.scriptOpt !== undefined ? {
            kind: 'Some',
            value: script_codec_1.scriptCodec.decode((0, utils_1.hexToBinUnsafe)(unsignedTx.scriptOpt))
        } : {
            kind: 'None',
            value: undefined
        };
        return {
            version,
            networkId,
            gasAmount,
            gasPrice,
            inputs,
            fixedOutputs,
            statefulScript
        };
    }
}
exports.UnsignedTxCodec = UnsignedTxCodec;
exports.unsignedTxCodec = new UnsignedTxCodec({
    version: codec_1.byteCodec,
    networkId: codec_1.byteCodec,
    statefulScript: script_codec_1.statefulScriptCodecOpt,
    gasAmount: compact_int_codec_1.i32Codec,
    gasPrice: compact_int_codec_1.u256Codec,
    inputs: input_codec_1.inputsCodec,
    fixedOutputs: asset_output_codec_1.assetOutputsCodec
});
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/output-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.outputsCodec = exports.outputCodec = void 0;
const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
const either_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/either-codec.js [app-ssr] (ecmascript)");
const asset_output_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/asset-output-codec.js [app-ssr] (ecmascript)");
const contract_output_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/contract-output-codec.js [app-ssr] (ecmascript)");
exports.outputCodec = (0, either_codec_1.either)('output', asset_output_codec_1.assetOutputCodec, contract_output_codec_1.contractOutputCodec);
exports.outputsCodec = new array_codec_1.ArrayCodec(exports.outputCodec);
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/transaction-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.transactionCodec = exports.TransactionCodec = void 0;
const unsigned_tx_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/unsigned-tx-codec.js [app-ssr] (ecmascript)");
const signature_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/signature-codec.js [app-ssr] (ecmascript)");
const contract_output_ref_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/contract-output-ref-codec.js [app-ssr] (ecmascript)");
const asset_output_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/asset-output-codec.js [app-ssr] (ecmascript)");
const contract_output_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/contract-output-codec.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const output_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/output-codec.js [app-ssr] (ecmascript)");
class TransactionCodec extends codec_1.ObjectCodec {
    encodeApiTransaction(input) {
        const decodedTx = TransactionCodec.fromApiTransaction(input);
        return this.encode(decodedTx);
    }
    decodeApiTransaction(input) {
        const decodedTx = this.decode(input);
        return TransactionCodec.toApiTransaction(decodedTx);
    }
    static toApiTransaction(transaction) {
        const txId = unsigned_tx_codec_1.UnsignedTxCodec.txId(transaction.unsigned);
        const unsigned = unsigned_tx_codec_1.UnsignedTxCodec.toApiUnsignedTx(transaction.unsigned);
        const scriptExecutionOk = !!transaction.scriptExecutionOk;
        const contractInputs = transaction.contractInputs.map((contractInput)=>{
            const hint = contractInput.hint;
            const key = (0, utils_1.binToHex)(contractInput.key);
            return {
                hint,
                key
            };
        });
        const txIdBytes = (0, utils_1.hexToBinUnsafe)(txId);
        const generatedOutputs = transaction.generatedOutputs.map((output, index)=>{
            if (output.kind === 'Left') {
                const fixedAssetOutput = asset_output_codec_1.AssetOutputCodec.toFixedAssetOutput(txIdBytes, output.value, index);
                return {
                    ...fixedAssetOutput,
                    type: 'AssetOutput'
                };
            } else {
                return contract_output_codec_1.ContractOutputCodec.convertToApiContractOutput(txIdBytes, output.value, index);
            }
        });
        const inputSignatures = transaction.inputSignatures.map((signature)=>(0, utils_1.binToHex)(signature));
        const scriptSignatures = transaction.scriptSignatures.map((signature)=>(0, utils_1.binToHex)(signature));
        return {
            unsigned,
            scriptExecutionOk,
            contractInputs,
            generatedOutputs,
            inputSignatures,
            scriptSignatures
        };
    }
    static fromApiTransaction(tx) {
        const unsigned = unsigned_tx_codec_1.UnsignedTxCodec.fromApiUnsignedTx(tx.unsigned);
        const scriptExecutionOk = tx.scriptExecutionOk ? 1 : 0;
        const contractInputs = tx.contractInputs.map((contractInput)=>{
            return {
                hint: contractInput.hint,
                key: (0, utils_1.hexToBinUnsafe)(contractInput.key)
            };
        });
        const generatedOutputs = tx.generatedOutputs.map((output)=>{
            if (output.type === 'AssetOutput') {
                return {
                    kind: 'Left',
                    value: asset_output_codec_1.AssetOutputCodec.fromFixedAssetOutput(output)
                };
            } else if (output.type === 'ContractOutput') {
                return {
                    kind: 'Right',
                    value: contract_output_codec_1.ContractOutputCodec.convertToOutput(output)
                };
            } else {
                throw new Error('Invalid output type');
            }
        });
        const inputSignatures = tx.inputSignatures.map((signature)=>{
            return (0, utils_1.hexToBinUnsafe)(signature);
        });
        const scriptSignatures = tx.scriptSignatures.map((signature)=>{
            return (0, utils_1.hexToBinUnsafe)(signature);
        });
        return {
            unsigned,
            scriptExecutionOk,
            contractInputs: contractInputs,
            generatedOutputs: generatedOutputs,
            inputSignatures: inputSignatures,
            scriptSignatures: scriptSignatures
        };
    }
}
exports.TransactionCodec = TransactionCodec;
exports.transactionCodec = new TransactionCodec({
    unsigned: unsigned_tx_codec_1.unsignedTxCodec,
    scriptExecutionOk: codec_1.byteCodec,
    contractInputs: contract_output_ref_codec_1.contractOutputRefsCodec,
    generatedOutputs: output_codec_1.outputsCodec,
    inputSignatures: signature_codec_1.signaturesCodec,
    scriptSignatures: signature_codec_1.signaturesCodec
});
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/contract-codec.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.contractCodec = exports.ContractCodec = void 0;
const array_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const compact_int_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)");
const method_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/method-codec.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const i32sCodec = new array_codec_1.ArrayCodec(compact_int_codec_1.i32Codec);
class ContractCodec extends codec_1.Codec {
    encode(input) {
        return (0, utils_1.concatBytes)([
            compact_int_codec_1.i32Codec.encode(input.fieldLength),
            i32sCodec.encode(input.methodIndexes),
            input.methods
        ]);
    }
    _decode(input) {
        const fieldLength = compact_int_codec_1.i32Codec._decode(input);
        const methodIndexes = i32sCodec._decode(input);
        const methods = input.consumeAll();
        return {
            fieldLength,
            methodIndexes,
            methods
        };
    }
    decodeContract(input) {
        const halfDecoded = this.decode(input);
        const fieldLength = halfDecoded.fieldLength;
        const methodIndexes = halfDecoded.methodIndexes;
        const methods = [];
        for(let i = 0, start = 0; i < methodIndexes.length; i++){
            const end = methodIndexes[i];
            const method = method_codec_1.methodCodec.decode(halfDecoded.methods.slice(start, end));
            methods.push(method);
            start = end;
        }
        return {
            fieldLength,
            methods
        };
    }
    encodeContract(contract) {
        const fieldLength = contract.fieldLength;
        const methods = contract.methods.map((m)=>method_codec_1.methodCodec.encode(m));
        let count = 0;
        const methodIndexes = Array.from(Array(methods.length).keys()).map((index)=>{
            count += methods[`${index}`].length;
            return count;
        });
        const halfDecoded = {
            fieldLength,
            methodIndexes: methodIndexes,
            methods: (0, utils_1.concatBytes)(methods)
        };
        return this.encode(halfDecoded);
    }
}
exports.ContractCodec = ContractCodec;
exports.contractCodec = new ContractCodec();
}}),
"[project]/node_modules/@alephium/web3/dist/src/codec/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.contract = exports.token = exports.script = exports.val = exports.unlockScript = exports.lockupScript = exports.contractOutput = exports.boolCodec = exports.Codec = exports.assetOutput = void 0;
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/array-codec.js [app-ssr] (ecmascript)"), exports);
exports.assetOutput = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/asset-output-codec.js [app-ssr] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/bigint-codec.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/bytestring-codec.js [app-ssr] (ecmascript)"), exports);
var codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "Codec", {
    enumerable: true,
    get: function() {
        return codec_1.Codec;
    }
});
Object.defineProperty(exports, "boolCodec", {
    enumerable: true,
    get: function() {
        return codec_1.boolCodec;
    }
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/compact-int-codec.js [app-ssr] (ecmascript)"), exports);
exports.contractOutput = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/contract-output-codec.js [app-ssr] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/contract-output-ref-codec.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/either-codec.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/input-codec.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/instr-codec.js [app-ssr] (ecmascript)"), exports);
exports.lockupScript = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/lockup-script-codec.js [app-ssr] (ecmascript)"));
exports.unlockScript = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/unlock-script-codec.js [app-ssr] (ecmascript)"));
exports.val = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/val.js [app-ssr] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/timestamp-codec.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/method-codec.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/option-codec.js [app-ssr] (ecmascript)"), exports);
exports.script = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/script-codec.js [app-ssr] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/signature-codec.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/int-as-4bytes-codec.js [app-ssr] (ecmascript)"), exports);
exports.token = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/token-codec.js [app-ssr] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/transaction-codec.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/unsigned-tx-codec.js [app-ssr] (ecmascript)"), exports);
exports.contract = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/contract-codec.js [app-ssr] (ecmascript)"));
}}),
"[project]/node_modules/@alephium/web3/dist/src/address/address.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.groupOfLockupScript = exports.subContractId = exports.contractIdFromTx = exports.addressFromTokenId = exports.addressFromContractId = exports.addressFromScript = exports.addressFromPublicKey = exports.publicKeyFromPrivateKey = exports.groupOfPrivateKey = exports.tokenIdFromAddress = exports.contractIdFromAddress = exports.groupOfAddress = exports.isContractAddress = exports.isAssetAddress = exports.isValidAddress = exports.validateAddress = exports.AddressType = void 0;
const elliptic_1 = __turbopack_context__.r("[project]/node_modules/elliptic/lib/elliptic.js [app-ssr] (ecmascript)");
const bn_js_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/bn.js/lib/bn.js [app-ssr] (ecmascript)"));
const constants_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/constants.js [app-ssr] (ecmascript)");
const blakejs_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/blakejs/index.js [app-ssr] (ecmascript)"));
const bs58_1 = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/bs58.js [app-ssr] (ecmascript)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const lockup_script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/lockup-script-codec.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/index.js [app-ssr] (ecmascript)");
const djb2_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/djb2.js [app-ssr] (ecmascript)"));
const error_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/error.js [app-ssr] (ecmascript)");
const ec = new elliptic_1.ec('secp256k1');
const PublicKeyHashSize = 32;
var AddressType;
(function(AddressType) {
    AddressType[AddressType["P2PKH"] = 0] = "P2PKH";
    AddressType[AddressType["P2MPKH"] = 1] = "P2MPKH";
    AddressType[AddressType["P2SH"] = 2] = "P2SH";
    AddressType[AddressType["P2C"] = 3] = "P2C";
})(AddressType = exports.AddressType || (exports.AddressType = {}));
function validateAddress(address) {
    decodeAndValidateAddress(address);
}
exports.validateAddress = validateAddress;
function isValidAddress(address) {
    try {
        validateAddress(address);
        return true;
    } catch  {
        return false;
    }
}
exports.isValidAddress = isValidAddress;
function decodeAndValidateAddress(address) {
    const decoded = (0, bs58_1.base58ToBytes)(address);
    if (decoded.length === 0) throw new Error('Address is empty');
    const addressType = decoded[0];
    if (addressType === AddressType.P2MPKH) {
        let multisig;
        try {
            multisig = lockup_script_codec_1.lockupScriptCodec.decode(decoded).value;
        } catch (error) {
            throw new error_1.TraceableError(`Invalid multisig address: ${address}`, error);
        }
        const n = multisig.publicKeyHashes.length;
        const m = multisig.m;
        if (n < m || m <= 0) {
            throw new Error(`Invalid multisig address, n: ${n}, m: ${m}`);
        }
        const encodedNSize = codec_1.i32Codec.encode(n).length;
        const encodedMSize = codec_1.i32Codec.encode(m).length;
        const size = encodedNSize + PublicKeyHashSize * n + encodedMSize + 1; // 1 for the P2MPKH prefix
        if (decoded.length === size) return decoded;
    } else if (addressType === AddressType.P2PKH || addressType === AddressType.P2SH || addressType === AddressType.P2C) {
        // [type, ...hash]
        if (decoded.length === 33) return decoded;
    }
    throw new Error(`Invalid address: ${address}`);
}
function isAssetAddress(address) {
    const addressType = decodeAndValidateAddress(address)[0];
    return addressType === AddressType.P2PKH || addressType === AddressType.P2MPKH || addressType === AddressType.P2SH;
}
exports.isAssetAddress = isAssetAddress;
function isContractAddress(address) {
    const addressType = decodeAndValidateAddress(address)[0];
    return addressType === AddressType.P2C;
}
exports.isContractAddress = isContractAddress;
function groupOfAddress(address) {
    const decoded = decodeAndValidateAddress(address);
    const addressType = decoded[0];
    const addressBody = decoded.slice(1);
    if (addressType == AddressType.P2PKH) {
        return groupOfP2pkhAddress(addressBody);
    } else if (addressType == AddressType.P2MPKH) {
        return groupOfP2mpkhAddress(addressBody);
    } else if (addressType == AddressType.P2SH) {
        return groupOfP2shAddress(addressBody);
    } else {
        // Contract Address
        const id = contractIdFromAddress(address);
        return id[`${id.length - 1}`];
    }
}
exports.groupOfAddress = groupOfAddress;
// Pay to public key hash address
function groupOfP2pkhAddress(address) {
    return groupFromBytesForAssetAddress(address);
}
// Pay to multiple public key hash address
function groupOfP2mpkhAddress(address) {
    return groupFromBytesForAssetAddress(address.slice(1, 33));
}
// Pay to script hash address
function groupOfP2shAddress(address) {
    return groupFromBytesForAssetAddress(address);
}
function contractIdFromAddress(address) {
    return idFromAddress(address);
}
exports.contractIdFromAddress = contractIdFromAddress;
function tokenIdFromAddress(address) {
    return idFromAddress(address);
}
exports.tokenIdFromAddress = tokenIdFromAddress;
function idFromAddress(address) {
    const decoded = (0, bs58_1.base58ToBytes)(address);
    if (decoded.length == 0) throw new Error('Address string is empty');
    const addressType = decoded[0];
    const addressBody = decoded.slice(1);
    if (addressType == AddressType.P2C) {
        return addressBody;
    } else {
        throw new Error(`Invalid contract address type: ${addressType}`);
    }
}
function groupOfPrivateKey(privateKey, keyType) {
    return groupOfAddress(addressFromPublicKey(publicKeyFromPrivateKey(privateKey, keyType), keyType));
}
exports.groupOfPrivateKey = groupOfPrivateKey;
function publicKeyFromPrivateKey(privateKey, _keyType) {
    const keyType = _keyType ?? 'default';
    if (keyType === 'default') {
        const key = ec.keyFromPrivate(privateKey);
        return key.getPublic(true, 'hex');
    } else {
        return ec.g.mul(new bn_js_1.default(privateKey, 16)).encode('hex', true).slice(2);
    }
}
exports.publicKeyFromPrivateKey = publicKeyFromPrivateKey;
function addressFromPublicKey(publicKey, _keyType) {
    const keyType = _keyType ?? 'default';
    if (keyType === 'default') {
        const hash = blakejs_1.default.blake2b((0, utils_1.hexToBinUnsafe)(publicKey), undefined, 32);
        const bytes = new Uint8Array([
            AddressType.P2PKH,
            ...hash
        ]);
        return bs58_1.default.encode(bytes);
    } else {
        const lockupScript = (0, utils_1.hexToBinUnsafe)(`0101000000000458144020${publicKey}8685`);
        return addressFromScript(lockupScript);
    }
}
exports.addressFromPublicKey = addressFromPublicKey;
function addressFromScript(script) {
    const scriptHash = blakejs_1.default.blake2b(script, undefined, 32);
    return bs58_1.default.encode(new Uint8Array([
        AddressType.P2SH,
        ...scriptHash
    ]));
}
exports.addressFromScript = addressFromScript;
function addressFromContractId(contractId) {
    const hash = (0, utils_1.hexToBinUnsafe)(contractId);
    const bytes = new Uint8Array([
        AddressType.P2C,
        ...hash
    ]);
    return bs58_1.default.encode(bytes);
}
exports.addressFromContractId = addressFromContractId;
function addressFromTokenId(tokenId) {
    const contractId = tokenId; // contract ID is the same as token ID
    return addressFromContractId(contractId);
}
exports.addressFromTokenId = addressFromTokenId;
function contractIdFromTx(txId, outputIndex) {
    const txIdBin = (0, utils_1.hexToBinUnsafe)(txId);
    const data = new Uint8Array([
        ...txIdBin,
        outputIndex
    ]);
    const hash = blakejs_1.default.blake2b(data, undefined, 32);
    return (0, utils_1.binToHex)(hash);
}
exports.contractIdFromTx = contractIdFromTx;
function subContractId(parentContractId, pathInHex, group) {
    if (group < 0 || group >= constants_1.TOTAL_NUMBER_OF_GROUPS) {
        throw new Error(`Invalid group ${group}`);
    }
    if (!(0, utils_1.isHexString)(parentContractId)) {
        throw new Error(`Invalid parent contract ID: ${parentContractId}, expected hex string`);
    }
    if (!(0, utils_1.isHexString)(pathInHex)) {
        throw new Error(`Invalid path: ${pathInHex}, expected hex string`);
    }
    const data = (0, utils_1.concatBytes)([
        (0, utils_1.hexToBinUnsafe)(parentContractId),
        (0, utils_1.hexToBinUnsafe)(pathInHex)
    ]);
    const bytes = new Uint8Array([
        ...blakejs_1.default.blake2b(blakejs_1.default.blake2b(data, undefined, 32), undefined, 32).slice(0, -1),
        group
    ]);
    return (0, utils_1.binToHex)(bytes);
}
exports.subContractId = subContractId;
function groupOfLockupScript(lockupScript) {
    if (lockupScript.kind === 'P2PKH') {
        return groupFromBytesForAssetAddress(lockupScript.value);
    } else if (lockupScript.kind === 'P2MPKH') {
        return groupFromBytesForAssetAddress(lockupScript.value.publicKeyHashes[0]);
    } else if (lockupScript.kind === 'P2SH') {
        return groupFromBytesForAssetAddress(lockupScript.value);
    } else {
        // P2C
        const contractId = lockupScript.value;
        return contractId[`${contractId.length - 1}`];
    }
}
exports.groupOfLockupScript = groupOfLockupScript;
function groupFromBytesForAssetAddress(bytes) {
    const hint = (0, djb2_1.default)(bytes) | 1;
    const hash = (0, utils_1.xorByte)(hint);
    return hash % constants_1.TOTAL_NUMBER_OF_GROUPS;
}
}}),
"[project]/node_modules/@alephium/web3/dist/src/address/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/address/address.js [app-ssr] (ecmascript)"), exports);
}}),
"[project]/node_modules/@alephium/web3/dist/src/api/node-provider.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.tryGetCallResult = exports.NodeProvider = void 0;
const types_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/types.js [app-ssr] (ecmascript)");
const api_alephium_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/api-alephium.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const address_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/address/index.js [app-ssr] (ecmascript)");
function initializeNodeApi(baseUrl, apiKey, customFetch) {
    const nodeApi = new api_alephium_1.Api({
        baseUrl: baseUrl,
        baseApiParams: {
            secure: true
        },
        securityWorker: (accessToken)=>accessToken !== null ? {
                headers: {
                    'X-API-KEY': `${accessToken}`
                }
            } : {},
        customFetch: customFetch ?? ((...fetchParams)=>fetch(...fetchParams))
    });
    nodeApi.setSecurityData(apiKey ?? null);
    return nodeApi;
}
class NodeProvider {
    constructor(param0, apiKey, customFetch){
        this.request = (args)=>{
            return (0, types_1.request)(this, args);
        };
        // Only use this when the token follows the fungible token interface, check `guessTokenType` first
        this.fetchFungibleTokenMetaData = async (tokenId)=>{
            const address = (0, address_1.addressFromTokenId)(tokenId);
            const group = (0, address_1.groupOfAddress)(address);
            const calls = Array.from([
                0,
                1,
                2,
                3
            ], (index)=>({
                    methodIndex: index,
                    group: group,
                    address: address
                }));
            const result = await this.contracts.postContractsMulticallContract({
                calls: calls
            });
            const callResults = result.results.map((r)=>tryGetCallResult(r));
            return {
                symbol: callResults[0].returns[0].value,
                name: callResults[1].returns[0].value,
                decimals: Number(callResults[2].returns[0].value),
                totalSupply: BigInt(callResults[3].returns[0].value)
            };
        };
        // Only use this when the token follows the non-fungile token interface, check `guessTokenType` first
        this.fetchNFTMetaData = async (tokenId)=>{
            const address = (0, address_1.addressFromTokenId)(tokenId);
            const group = (0, address_1.groupOfAddress)(address);
            const calls = Array.from([
                0,
                1
            ], (index)=>({
                    methodIndex: index,
                    group: group,
                    address: address
                }));
            const result = await this.contracts.postContractsMulticallContract({
                calls: calls
            });
            const tokenUri = (0, utils_1.hexToString)(tryGetCallResult(result.results[0]).returns[0].value);
            const collectionIndexResult = result.results[1];
            if (collectionIndexResult.type === 'CallContractSucceeded') {
                const successfulCollectionIndexResult = result.results[1];
                const contractIdReturnResult = successfulCollectionIndexResult.returns[0];
                if (contractIdReturnResult === undefined) {
                    throw new Error('Deprecated NFT contract');
                }
                const collectionId = successfulCollectionIndexResult.returns[0].value;
                if (collectionId === undefined || !(0, utils_1.isHexString)(collectionId) || collectionId.length !== 64) {
                    throw new Error('Deprecated NFT contract');
                }
                const nftIndexReturnResult = successfulCollectionIndexResult.returns[1];
                if (nftIndexReturnResult === undefined) {
                    throw new Error('Deprecated NFT contract');
                }
                const nftIndex = (0, utils_1.toNonNegativeBigInt)(nftIndexReturnResult.value);
                if (nftIndex === undefined) {
                    throw new Error('Deprecated NFT contract');
                }
                // If there are more return values, it is also a deprecated NFT contract
                const thirdResult = successfulCollectionIndexResult.returns[2];
                if (thirdResult !== undefined) {
                    throw new Error('Deprecated NFT contract');
                }
                return {
                    tokenUri,
                    collectionId,
                    nftIndex
                };
            } else {
                const failedCollectionIndexResult = result.results[1];
                if (failedCollectionIndexResult.error.startsWith('VM execution error: Invalid method index')) {
                    throw new Error('Deprecated NFT contract');
                } else {
                    throw new Error(`Failed to call contract, error: ${failedCollectionIndexResult.error}`);
                }
            }
        };
        // Only use this when the contract follows the NFT collection interface, check `guessFollowsNFTCollectionStd` first
        this.fetchNFTCollectionMetaData = async (collectionId)=>{
            const address = (0, address_1.addressFromContractId)(collectionId);
            const group = (0, address_1.groupOfAddress)(address);
            const calls = Array.from([
                0,
                1
            ], (index)=>({
                    methodIndex: index,
                    group: group,
                    address: address
                }));
            const result = await this.contracts.postContractsMulticallContract({
                calls
            });
            const callResults = result.results.map((r)=>tryGetCallResult(r));
            return {
                collectionUri: (0, utils_1.hexToString)(callResults[0].returns[0].value),
                totalSupply: BigInt(callResults[1].returns[0].value)
            };
        };
        // Only use this when the contract follows the NFT collection with royalty interface, check `guessFollowsNFTCollectionWithRoyaltyStd` first
        this.fetchNFTRoyaltyAmount = async (collectionId, tokenId, salePrice)=>{
            const address = (0, address_1.addressFromContractId)(collectionId);
            const group = (0, address_1.groupOfAddress)(address);
            const apiResult = await this.contracts.postContractsCallContract({
                address: address,
                group: group,
                methodIndex: 4,
                args: [
                    {
                        type: 'ByteVec',
                        value: tokenId
                    },
                    {
                        type: 'U256',
                        value: salePrice.toString()
                    }
                ]
            });
            const result = tryGetCallResult(apiResult);
            return BigInt(result.returns[0].value);
        };
        this.guessStdInterfaceId = async (tokenId)=>{
            const address = (0, address_1.addressFromTokenId)(tokenId);
            const rawState = await this.contracts.getContractsAddressState(address);
            const lastImmField = rawState.immFields.slice(-1).pop()?.value;
            const interfaceIdPrefix = '414c5048'; // the hex of 'ALPH'
            if (typeof lastImmField === 'string' && lastImmField.startsWith(interfaceIdPrefix)) {
                return lastImmField.slice(8);
            } else {
                return undefined;
            }
        };
        this.guessFollowsNFTCollectionStd = async (contractId)=>{
            const interfaceId = await this.guessStdInterfaceId(contractId);
            return !!interfaceId && interfaceId.startsWith(types_1.StdInterfaceIds.NFTCollection);
        };
        this.guessFollowsNFTCollectionWithRoyaltyStd = async (contractId)=>{
            const interfaceId = await this.guessStdInterfaceId(contractId);
            return interfaceId === types_1.StdInterfaceIds.NFTCollectionWithRoyalty;
        };
        this.guessStdTokenType = async (tokenId)=>{
            const interfaceId = await this.guessStdInterfaceId(tokenId);
            switch(true){
                case interfaceId?.startsWith(types_1.StdInterfaceIds.FungibleToken):
                    return 'fungible';
                case interfaceId?.startsWith(types_1.StdInterfaceIds.NFT):
                    return 'non-fungible';
                default:
                    return undefined;
            }
        };
        let nodeApi;
        if (typeof param0 === 'string') {
            nodeApi = initializeNodeApi(param0, apiKey, customFetch);
        } else if (typeof param0 === 'function') {
            nodeApi = new NodeProvider('https://1.2.3.4:0');
            (0, types_1.forwardRequests)(nodeApi, param0);
        } else {
            nodeApi = param0;
        }
        this.wallets = {
            ...nodeApi.wallets
        };
        this.infos = {
            ...nodeApi.infos
        };
        this.blockflow = {
            ...nodeApi.blockflow
        };
        this.addresses = {
            ...nodeApi.addresses
        };
        this.transactions = {
            ...nodeApi.transactions
        };
        this.mempool = {
            ...nodeApi.mempool
        };
        this.contracts = {
            ...nodeApi.contracts
        };
        this.multisig = {
            ...nodeApi.multisig
        };
        this.utils = {
            ...nodeApi.utils
        };
        this.miners = {
            ...nodeApi.miners
        };
        this.events = {
            ...nodeApi.events
        };
        (0, types_1.requestWithLog)(this);
    }
    // This can prevent the proxied node provider from being modified
    static Proxy(nodeProvider) {
        return new NodeProvider(nodeProvider);
    }
    static Remote(handler) {
        return new NodeProvider(handler);
    }
}
exports.NodeProvider = NodeProvider;
function tryGetCallResult(result) {
    if (result.type === 'CallContractFailed') {
        throw new Error(`Failed to call contract, error: ${result.error}`);
    }
    return result;
}
exports.tryGetCallResult = tryGetCallResult;
}}),
"[project]/node_modules/@alephium/web3/dist/src/api/api-explorer.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* eslint-disable */ /* tslint:disable */ /*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Api = exports.HttpClient = exports.ContentType = exports.Currencies = exports.MaxSizeAddresses = exports.MaxSizeAddressesForTokens = exports.MaxSizeTokens = exports.PaginationPageDefault = exports.PaginationLimitMax = exports.PaginationLimitDefault = exports.TokenStdInterfaceId = exports.IntervalType = void 0;
/** IntervalType */ var IntervalType;
(function(IntervalType) {
    IntervalType["Daily"] = "daily";
    IntervalType["Hourly"] = "hourly";
    IntervalType["Weekly"] = "weekly";
})(IntervalType = exports.IntervalType || (exports.IntervalType = {}));
/** TokenStdInterfaceId */ var TokenStdInterfaceId;
(function(TokenStdInterfaceId) {
    TokenStdInterfaceId["Fungible"] = "fungible";
    TokenStdInterfaceId["NonFungible"] = "non-fungible";
    TokenStdInterfaceId["NonStandard"] = "non-standard";
})(TokenStdInterfaceId = exports.TokenStdInterfaceId || (exports.TokenStdInterfaceId = {}));
var PaginationLimitDefault;
(function(PaginationLimitDefault) {
    PaginationLimitDefault[PaginationLimitDefault["Value20"] = 20] = "Value20";
    PaginationLimitDefault[PaginationLimitDefault["Value10"] = 10] = "Value10";
})(PaginationLimitDefault = exports.PaginationLimitDefault || (exports.PaginationLimitDefault = {}));
var PaginationLimitMax;
(function(PaginationLimitMax) {
    PaginationLimitMax[PaginationLimitMax["Value100"] = 100] = "Value100";
    PaginationLimitMax[PaginationLimitMax["Value20"] = 20] = "Value20";
})(PaginationLimitMax = exports.PaginationLimitMax || (exports.PaginationLimitMax = {}));
var PaginationPageDefault;
(function(PaginationPageDefault) {
    PaginationPageDefault[PaginationPageDefault["Value1"] = 1] = "Value1";
})(PaginationPageDefault = exports.PaginationPageDefault || (exports.PaginationPageDefault = {}));
var MaxSizeTokens;
(function(MaxSizeTokens) {
    MaxSizeTokens[MaxSizeTokens["Value80"] = 80] = "Value80";
})(MaxSizeTokens = exports.MaxSizeTokens || (exports.MaxSizeTokens = {}));
var MaxSizeAddressesForTokens;
(function(MaxSizeAddressesForTokens) {
    MaxSizeAddressesForTokens[MaxSizeAddressesForTokens["Value80"] = 80] = "Value80";
})(MaxSizeAddressesForTokens = exports.MaxSizeAddressesForTokens || (exports.MaxSizeAddressesForTokens = {}));
var MaxSizeAddresses;
(function(MaxSizeAddresses) {
    MaxSizeAddresses[MaxSizeAddresses["Value80"] = 80] = "Value80";
})(MaxSizeAddresses = exports.MaxSizeAddresses || (exports.MaxSizeAddresses = {}));
var Currencies;
(function(Currencies) {
    Currencies["Btc"] = "btc";
    Currencies["Eth"] = "eth";
    Currencies["Usd"] = "usd";
    Currencies["Eur"] = "eur";
    Currencies["Chf"] = "chf";
    Currencies["Gbp"] = "gbp";
    Currencies["Idr"] = "idr";
    Currencies["Vnd"] = "vnd";
    Currencies["Rub"] = "rub";
    Currencies["Try"] = "try";
    Currencies["Cad"] = "cad";
    Currencies["Aud"] = "aud";
})(Currencies = exports.Currencies || (exports.Currencies = {}));
__turbopack_context__.r("[project]/node_modules/cross-fetch/dist/node-polyfill.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/utils.js [app-ssr] (ecmascript)");
var ContentType;
(function(ContentType) {
    ContentType["Json"] = "application/json";
    ContentType["FormData"] = "multipart/form-data";
    ContentType["UrlEncoded"] = "application/x-www-form-urlencoded";
    ContentType["Text"] = "text/plain";
})(ContentType = exports.ContentType || (exports.ContentType = {}));
class HttpClient {
    constructor(apiConfig = {}){
        this.baseUrl = '';
        this.securityData = null;
        this.abortControllers = new Map();
        this.customFetch = (...fetchParams)=>fetch(...fetchParams);
        this.baseApiParams = {
            credentials: 'same-origin',
            headers: {},
            redirect: 'follow',
            referrerPolicy: 'no-referrer'
        };
        this.setSecurityData = (data)=>{
            this.securityData = data;
        };
        this.contentFormatters = {
            [ContentType.Json]: (input)=>input !== null && (typeof input === 'object' || typeof input === 'string') ? JSON.stringify(input) : input,
            [ContentType.Text]: (input)=>input !== null && typeof input !== 'string' ? JSON.stringify(input) : input,
            [ContentType.FormData]: (input)=>Object.keys(input || {}).reduce((formData, key)=>{
                    const property = input[key];
                    formData.append(key, property instanceof Blob ? property : typeof property === 'object' && property !== null ? JSON.stringify(property) : `${property}`);
                    return formData;
                }, new FormData()),
            [ContentType.UrlEncoded]: (input)=>this.toQueryString(input)
        };
        this.createAbortSignal = (cancelToken)=>{
            if (this.abortControllers.has(cancelToken)) {
                const abortController = this.abortControllers.get(cancelToken);
                if (abortController) {
                    return abortController.signal;
                }
                return void 0;
            }
            const abortController = new AbortController();
            this.abortControllers.set(cancelToken, abortController);
            return abortController.signal;
        };
        this.abortRequest = (cancelToken)=>{
            const abortController = this.abortControllers.get(cancelToken);
            if (abortController) {
                abortController.abort();
                this.abortControllers.delete(cancelToken);
            }
        };
        this.request = async ({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params })=>{
            const secureParams = (typeof secure === 'boolean' ? secure : this.baseApiParams.secure) && this.securityWorker && await this.securityWorker(this.securityData) || {};
            const requestParams = this.mergeRequestParams(params, secureParams);
            const queryString = query && this.toQueryString(query);
            const payloadFormatter = this.contentFormatters[type || ContentType.Json];
            const responseFormat = format || requestParams.format;
            return this.customFetch(`${baseUrl || this.baseUrl || ''}${path}${queryString ? `?${queryString}` : ''}`, {
                ...requestParams,
                headers: {
                    ...requestParams.headers || {},
                    ...type && type !== ContentType.FormData ? {
                        'Content-Type': type
                    } : {}
                },
                signal: cancelToken ? this.createAbortSignal(cancelToken) : requestParams.signal,
                body: typeof body === 'undefined' || body === null ? null : payloadFormatter(body)
            }).then(async (response)=>{
                const r = response;
                r.data = null;
                r.error = null;
                const data = !responseFormat ? r : await response[responseFormat]().then((data)=>{
                    if (r.ok) {
                        r.data = data;
                    } else {
                        r.error = data;
                    }
                    return r;
                }).catch((e)=>{
                    r.error = e;
                    return r;
                });
                if (cancelToken) {
                    this.abortControllers.delete(cancelToken);
                }
                return data;
            });
        };
        Object.assign(this, apiConfig);
    }
    encodeQueryParam(key, value) {
        const encodedKey = encodeURIComponent(key);
        return `${encodedKey}=${encodeURIComponent(typeof value === 'number' ? value : `${value}`)}`;
    }
    addQueryParam(query, key) {
        return this.encodeQueryParam(key, query[key]);
    }
    addArrayQueryParam(query, key) {
        const value = query[key];
        return value.map((v)=>this.encodeQueryParam(key, v)).join('&');
    }
    toQueryString(rawQuery) {
        const query = rawQuery || {};
        const keys = Object.keys(query).filter((key)=>'undefined' !== typeof query[key]);
        return keys.map((key)=>Array.isArray(query[key]) ? this.addArrayQueryParam(query, key) : this.addQueryParam(query, key)).join('&');
    }
    addQueryParams(rawQuery) {
        const queryString = this.toQueryString(rawQuery);
        return queryString ? `?${queryString}` : '';
    }
    mergeRequestParams(params1, params2) {
        return {
            ...this.baseApiParams,
            ...params1,
            ...params2 || {},
            headers: {
                ...this.baseApiParams.headers || {},
                ...params1.headers || {},
                ...params2 && params2.headers || {}
            }
        };
    }
}
exports.HttpClient = HttpClient;
/**
 * @title Alephium Explorer API
 * @version 1.0
 */ class Api extends HttpClient {
    constructor(){
        super(...arguments);
        this.blocks = {
            /**
             * @description List latest blocks
             *
             * @tags Blocks
             * @name GetBlocks
             * @request GET:/blocks
             */ getBlocks: (query, params = {})=>this.request({
                    path: `/blocks`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get a block with hash
             *
             * @tags Blocks
             * @name GetBlocksBlockHash
             * @request GET:/blocks/{block_hash}
             */ getBlocksBlockHash: (blockHash, params = {})=>this.request({
                    path: `/blocks/${blockHash}`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get block's transactions
             *
             * @tags Blocks
             * @name GetBlocksBlockHashTransactions
             * @request GET:/blocks/{block_hash}/transactions
             */ getBlocksBlockHashTransactions: (blockHash, query, params = {})=>this.request({
                    path: `/blocks/${blockHash}/transactions`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.transactions = {
            /**
             * @description Get a transaction with hash
             *
             * @tags Transactions
             * @name GetTransactionsTransactionHash
             * @request GET:/transactions/{transaction_hash}
             */ getTransactionsTransactionHash: (transactionHash, params = {})=>this.request({
                    path: `/transactions/${transactionHash}`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.addresses = {
            /**
             * @description Get address information
             *
             * @tags Addresses
             * @name GetAddressesAddress
             * @request GET:/addresses/{address}
             */ getAddressesAddress: (address, params = {})=>this.request({
                    path: `/addresses/${address}`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description List transactions of a given address
             *
             * @tags Addresses
             * @name GetAddressesAddressTransactions
             * @request GET:/addresses/{address}/transactions
             */ getAddressesAddressTransactions: (address, query, params = {})=>this.request({
                    path: `/addresses/${address}/transactions`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description List transactions for given addresses
             *
             * @tags Addresses
             * @name PostAddressesTransactions
             * @request POST:/addresses/transactions
             */ postAddressesTransactions: (query, data, params = {})=>this.request({
                    path: `/addresses/transactions`,
                    method: 'POST',
                    query: query,
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description List transactions of a given address within a time-range
             *
             * @tags Addresses
             * @name GetAddressesAddressTimerangedTransactions
             * @request GET:/addresses/{address}/timeranged-transactions
             */ getAddressesAddressTimerangedTransactions: (address, query, params = {})=>this.request({
                    path: `/addresses/${address}/timeranged-transactions`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get total transactions of a given address
             *
             * @tags Addresses
             * @name GetAddressesAddressTotalTransactions
             * @request GET:/addresses/{address}/total-transactions
             */ getAddressesAddressTotalTransactions: (address, params = {})=>this.request({
                    path: `/addresses/${address}/total-transactions`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get latest transaction information of a given address
             *
             * @tags Addresses
             * @name GetAddressesAddressLatestTransaction
             * @request GET:/addresses/{address}/latest-transaction
             */ getAddressesAddressLatestTransaction: (address, params = {})=>this.request({
                    path: `/addresses/${address}/latest-transaction`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description List mempool transactions of a given address
             *
             * @tags Addresses
             * @name GetAddressesAddressMempoolTransactions
             * @request GET:/addresses/{address}/mempool/transactions
             */ getAddressesAddressMempoolTransactions: (address, params = {})=>this.request({
                    path: `/addresses/${address}/mempool/transactions`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get address balance
             *
             * @tags Addresses
             * @name GetAddressesAddressBalance
             * @request GET:/addresses/{address}/balance
             */ getAddressesAddressBalance: (address, params = {})=>this.request({
                    path: `/addresses/${address}/balance`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description List address tokens
             *
             * @tags Addresses
             * @name GetAddressesAddressTokens
             * @request GET:/addresses/{address}/tokens
             * @deprecated
             */ getAddressesAddressTokens: (address, query, params = {})=>this.request({
                    path: `/addresses/${address}/tokens`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description List address tokens
             *
             * @tags Addresses
             * @name GetAddressesAddressTokensTokenIdTransactions
             * @request GET:/addresses/{address}/tokens/{token_id}/transactions
             */ getAddressesAddressTokensTokenIdTransactions: (address, tokenId, query, params = {})=>this.request({
                    path: `/addresses/${address}/tokens/${tokenId}/transactions`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get address balance of given token
             *
             * @tags Addresses
             * @name GetAddressesAddressTokensTokenIdBalance
             * @request GET:/addresses/{address}/tokens/{token_id}/balance
             */ getAddressesAddressTokensTokenIdBalance: (address, tokenId, params = {})=>this.request({
                    path: `/addresses/${address}/tokens/${tokenId}/balance`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get public key of p2pkh addresses, the address needs to have at least one input.
             *
             * @tags Addresses
             * @name GetAddressesAddressPublicKey
             * @request GET:/addresses/{address}/public-key
             */ getAddressesAddressPublicKey: (address, params = {})=>this.request({
                    path: `/addresses/${address}/public-key`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get address tokens with balance
             *
             * @tags Addresses
             * @name GetAddressesAddressTokensBalance
             * @request GET:/addresses/{address}/tokens-balance
             */ getAddressesAddressTokensBalance: (address, query, params = {})=>this.request({
                    path: `/addresses/${address}/tokens-balance`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Are the addresses used (at least 1 transaction)
             *
             * @tags Addresses, Addresses
             * @name PostAddressesUsed
             * @request POST:/addresses/used
             */ postAddressesUsed: (data, params = {})=>this.request({
                    path: `/addresses/used`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Addresses
             * @name GetAddressesAddressExportTransactionsCsv
             * @request GET:/addresses/{address}/export-transactions/csv
             */ getAddressesAddressExportTransactionsCsv: (address, query, params = {})=>this.request({
                    path: `/addresses/${address}/export-transactions/csv`,
                    method: 'GET',
                    query: query,
                    format: 'text',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Addresses
             * @name GetAddressesAddressAmountHistoryDeprecated
             * @request GET:/addresses/{address}/amount-history-DEPRECATED
             * @deprecated
             */ getAddressesAddressAmountHistoryDeprecated: (address, query, params = {})=>this.request({
                    path: `/addresses/${address}/amount-history-DEPRECATED`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Addresses
             * @name GetAddressesAddressAmountHistory
             * @request GET:/addresses/{address}/amount-history
             */ getAddressesAddressAmountHistory: (address, query, params = {})=>this.request({
                    path: `/addresses/${address}/amount-history`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.infos = {
            /**
             * @description Get explorer informations
             *
             * @tags Infos
             * @name GetInfos
             * @request GET:/infos
             */ getInfos: (params = {})=>this.request({
                    path: `/infos`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description List latest height for each chain
             *
             * @tags Infos
             * @name GetInfosHeights
             * @request GET:/infos/heights
             */ getInfosHeights: (params = {})=>this.request({
                    path: `/infos/heights`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get token supply list
             *
             * @tags Infos
             * @name GetInfosSupply
             * @request GET:/infos/supply
             */ getInfosSupply: (query, params = {})=>this.request({
                    path: `/infos/supply`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get the ALPH total supply
             *
             * @tags Infos
             * @name GetInfosSupplyTotalAlph
             * @request GET:/infos/supply/total-alph
             */ getInfosSupplyTotalAlph: (params = {})=>this.request({
                    path: `/infos/supply/total-alph`,
                    method: 'GET',
                    format: 'text',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get the ALPH circulating supply
             *
             * @tags Infos
             * @name GetInfosSupplyCirculatingAlph
             * @request GET:/infos/supply/circulating-alph
             */ getInfosSupplyCirculatingAlph: (params = {})=>this.request({
                    path: `/infos/supply/circulating-alph`,
                    method: 'GET',
                    format: 'text',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get the ALPH reserved supply
             *
             * @tags Infos
             * @name GetInfosSupplyReservedAlph
             * @request GET:/infos/supply/reserved-alph
             */ getInfosSupplyReservedAlph: (params = {})=>this.request({
                    path: `/infos/supply/reserved-alph`,
                    method: 'GET',
                    format: 'text',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get the ALPH locked supply
             *
             * @tags Infos
             * @name GetInfosSupplyLockedAlph
             * @request GET:/infos/supply/locked-alph
             */ getInfosSupplyLockedAlph: (params = {})=>this.request({
                    path: `/infos/supply/locked-alph`,
                    method: 'GET',
                    format: 'text',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get the total number of transactions
             *
             * @tags Infos
             * @name GetInfosTotalTransactions
             * @request GET:/infos/total-transactions
             */ getInfosTotalTransactions: (params = {})=>this.request({
                    path: `/infos/total-transactions`,
                    method: 'GET',
                    format: 'text',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get the average block time for each chain
             *
             * @tags Infos
             * @name GetInfosAverageBlockTimes
             * @request GET:/infos/average-block-times
             */ getInfosAverageBlockTimes: (params = {})=>this.request({
                    path: `/infos/average-block-times`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.mempool = {
            /**
             * @description list mempool transactions
             *
             * @tags Mempool
             * @name GetMempoolTransactions
             * @request GET:/mempool/transactions
             */ getMempoolTransactions: (query, params = {})=>this.request({
                    path: `/mempool/transactions`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.tokens = {
            /**
             * @description List token information
             *
             * @tags Tokens
             * @name GetTokens
             * @request GET:/tokens
             */ getTokens: (query, params = {})=>this.request({
                    path: `/tokens`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description List given tokens information
             *
             * @tags Tokens
             * @name PostTokens
             * @request POST:/tokens
             */ postTokens: (data, params = {})=>this.request({
                    path: `/tokens`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description List token transactions
             *
             * @tags Tokens
             * @name GetTokensTokenIdTransactions
             * @request GET:/tokens/{token_id}/transactions
             */ getTokensTokenIdTransactions: (tokenId, query, params = {})=>this.request({
                    path: `/tokens/${tokenId}/transactions`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description List token addresses
             *
             * @tags Tokens
             * @name GetTokensTokenIdAddresses
             * @request GET:/tokens/{token_id}/addresses
             */ getTokensTokenIdAddresses: (tokenId, query, params = {})=>this.request({
                    path: `/tokens/${tokenId}/addresses`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Return metadata for the given fungible tokens, if metadata doesn't exist or token isn't a fungible, it won't be in the output list
             *
             * @tags Tokens
             * @name PostTokensFungibleMetadata
             * @request POST:/tokens/fungible-metadata
             */ postTokensFungibleMetadata: (data, params = {})=>this.request({
                    path: `/tokens/fungible-metadata`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Return metadata for the given nft tokens, if metadata doesn't exist or token isn't a nft, it won't be in the output list
             *
             * @tags Tokens
             * @name PostTokensNftMetadata
             * @request POST:/tokens/nft-metadata
             */ postTokensNftMetadata: (data, params = {})=>this.request({
                    path: `/tokens/nft-metadata`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Return metadata for the given nft collection addresses, if metadata doesn't exist or address isn't a nft collection, it won't be in the output list
             *
             * @tags Tokens
             * @name PostTokensNftCollectionMetadata
             * @request POST:/tokens/nft-collection-metadata
             */ postTokensNftCollectionMetadata: (data, params = {})=>this.request({
                    path: `/tokens/nft-collection-metadata`,
                    method: 'POST',
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get a sorted list of top addresses by ALPH balance. Updates once per day.
             *
             * @tags Tokens
             * @name GetTokensHoldersAlph
             * @request GET:/tokens/holders/alph
             */ getTokensHoldersAlph: (query, params = {})=>this.request({
                    path: `/tokens/holders/alph`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get a sorted list of top addresses by {token_id} balance. Updates once per day.
             *
             * @tags Tokens
             * @name GetTokensHoldersTokenTokenId
             * @request GET:/tokens/holders/token/{token_id}
             */ getTokensHoldersTokenTokenId: (tokenId, query, params = {})=>this.request({
                    path: `/tokens/holders/token/${tokenId}`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.charts = {
            /**
             * @description `interval-type` query param: hourly, daily
             *
             * @tags Charts
             * @name GetChartsHashrates
             * @summary Get hashrate chart in H/s
             * @request GET:/charts/hashrates
             */ getChartsHashrates: (query, params = {})=>this.request({
                    path: `/charts/hashrates`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description `interval-type` query param: hourly, daily
             *
             * @tags Charts
             * @name GetChartsTransactionsCount
             * @summary Get transaction count history
             * @request GET:/charts/transactions-count
             */ getChartsTransactionsCount: (query, params = {})=>this.request({
                    path: `/charts/transactions-count`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description `interval-type` query param: hourly, daily
             *
             * @tags Charts
             * @name GetChartsTransactionsCountPerChain
             * @summary Get transaction count history per chain
             * @request GET:/charts/transactions-count-per-chain
             */ getChartsTransactionsCountPerChain: (query, params = {})=>this.request({
                    path: `/charts/transactions-count-per-chain`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.contractEvents = {
            /**
             * @description Get contract events by transaction id
             *
             * @tags Contract events
             * @name GetContractEventsTransactionIdTransactionId
             * @request GET:/contract-events/transaction-id/{transaction_id}
             */ getContractEventsTransactionIdTransactionId: (transactionId, params = {})=>this.request({
                    path: `/contract-events/transaction-id/${transactionId}`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get contract events by contract address
             *
             * @tags Contract events
             * @name GetContractEventsContractAddressContractAddress
             * @request GET:/contract-events/contract-address/{contract_address}
             */ getContractEventsContractAddressContractAddress: (contractAddress, query, params = {})=>this.request({
                    path: `/contract-events/contract-address/${contractAddress}`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get contract events by contract and input addresses
             *
             * @tags Contract events
             * @name GetContractEventsContractAddressContractAddressInputAddressInputAddress
             * @request GET:/contract-events/contract-address/{contract_address}/input-address/{input_address}
             */ getContractEventsContractAddressContractAddressInputAddressInputAddress: (contractAddress, inputAddress, query, params = {})=>this.request({
                    path: `/contract-events/contract-address/${contractAddress}/input-address/${inputAddress}`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.contracts = {
            /**
             * @description Get contract liveness
             *
             * @tags Contracts
             * @name GetContractsContractAddressCurrentLiveness
             * @request GET:/contracts/{contract_address}/current-liveness
             */ getContractsContractAddressCurrentLiveness: (contractAddress, params = {})=>this.request({
                    path: `/contracts/${contractAddress}/current-liveness`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get contract parent address if exist
             *
             * @tags Contracts
             * @name GetContractsContractAddressParent
             * @request GET:/contracts/{contract_address}/parent
             */ getContractsContractAddressParent: (contractAddress, params = {})=>this.request({
                    path: `/contracts/${contractAddress}/parent`,
                    method: 'GET',
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Get sub contract addresses
             *
             * @tags Contracts
             * @name GetContractsContractAddressSubContracts
             * @request GET:/contracts/{contract_address}/sub-contracts
             */ getContractsContractAddressSubContracts: (contractAddress, query, params = {})=>this.request({
                    path: `/contracts/${contractAddress}/sub-contracts`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.market = {
            /**
             * No description
             *
             * @tags Market
             * @name PostMarketPrices
             * @request POST:/market/prices
             */ postMarketPrices: (query, data, params = {})=>this.request({
                    path: `/market/prices`,
                    method: 'POST',
                    query: query,
                    body: data,
                    type: ContentType.Json,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * No description
             *
             * @tags Market
             * @name GetMarketPricesSymbolCharts
             * @request GET:/market/prices/{symbol}/charts
             */ getMarketPricesSymbolCharts: (symbol, query, params = {})=>this.request({
                    path: `/market/prices/${symbol}/charts`,
                    method: 'GET',
                    query: query,
                    format: 'json',
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
        this.utils = {
            /**
             * @description Perform a sanity check
             *
             * @tags Utils
             * @name PutUtilsSanityCheck
             * @request PUT:/utils/sanity-check
             */ putUtilsSanityCheck: (params = {})=>this.request({
                    path: `/utils/sanity-check`,
                    method: 'PUT',
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Update global log level, accepted: TRACE, DEBUG, INFO, WARN, ERROR
             *
             * @tags Utils
             * @name PutUtilsUpdateGlobalLoglevel
             * @request PUT:/utils/update-global-loglevel
             */ putUtilsUpdateGlobalLoglevel: (data, params = {})=>this.request({
                    path: `/utils/update-global-loglevel`,
                    method: 'PUT',
                    body: data,
                    ...params
                }).then(utils_1.convertHttpResponse),
            /**
             * @description Update logback values
             *
             * @tags Utils
             * @name PutUtilsUpdateLogConfig
             * @request PUT:/utils/update-log-config
             */ putUtilsUpdateLogConfig: (data, params = {})=>this.request({
                    path: `/utils/update-log-config`,
                    method: 'PUT',
                    body: data,
                    type: ContentType.Json,
                    ...params
                }).then(utils_1.convertHttpResponse)
        };
    }
}
exports.Api = Api;
}}),
"[project]/node_modules/@alephium/web3/dist/src/api/explorer-provider.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ExplorerProvider = void 0;
const types_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/types.js [app-ssr] (ecmascript)");
const api_explorer_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/api-explorer.js [app-ssr] (ecmascript)");
function initializeExplorerApi(baseUrl, apiKey, customFetch) {
    const explorerApi = new api_explorer_1.Api({
        baseUrl: baseUrl,
        baseApiParams: {
            secure: true
        },
        securityWorker: (accessToken)=>accessToken !== null ? {
                headers: {
                    'X-API-KEY': `${accessToken}`
                }
            } : {},
        customFetch: customFetch ?? ((...fetchParams)=>fetch(...fetchParams))
    });
    explorerApi.setSecurityData(apiKey ?? null);
    return explorerApi;
}
class ExplorerProvider {
    constructor(param0, apiKey, customFetch){
        this.request = (args)=>{
            return (0, types_1.request)(this, args);
        };
        let explorerApi;
        if (typeof param0 === 'string') {
            explorerApi = initializeExplorerApi(param0, apiKey, customFetch);
        } else if (typeof param0 === 'function') {
            explorerApi = new ExplorerProvider('https://1.2.3.4:0');
            (0, types_1.forwardRequests)(explorerApi, param0);
        } else {
            explorerApi = param0;
        }
        this.blocks = {
            ...explorerApi.blocks
        };
        this.transactions = {
            ...explorerApi.transactions
        };
        this.addresses = {
            ...explorerApi.addresses
        };
        this.infos = {
            ...explorerApi.infos
        };
        this.mempool = {
            ...explorerApi.mempool
        };
        this.tokens = {
            ...explorerApi.tokens
        };
        this.charts = {
            ...explorerApi.charts
        };
        this.utils = {
            ...explorerApi.utils
        };
        this.contracts = {
            ...explorerApi.contracts
        };
        this.market = {
            ...explorerApi.market
        };
        this.contractEvents = {
            ...explorerApi.contractEvents
        };
    }
    // This can prevent the proxied explorer provider from being modified
    static Proxy(explorerProvider) {
        return new ExplorerProvider(explorerProvider);
    }
    static Remote(handler) {
        return new ExplorerProvider(handler);
    }
}
exports.ExplorerProvider = ExplorerProvider;
}}),
"[project]/node_modules/@alephium/web3/dist/src/api/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.explorer = exports.node = void 0;
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/node-provider.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/explorer-provider.js [app-ssr] (ecmascript)"), exports);
exports.node = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/api-alephium.js [app-ssr] (ecmascript)"));
exports.explorer = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/api-explorer.js [app-ssr] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/types.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/utils.js [app-ssr] (ecmascript)"), exports);
}}),
"[project]/node_modules/@alephium/web3/dist/src/contract/ralph.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.buildDebugBytecode = exports.encodeContractField = exports.buildContractByteCode = exports.encodeContractFields = exports.buildScriptByteCode = exports.flattenFields = exports.typeLength = exports.encodeMapKey = exports.decodePrimitive = exports.tryDecodeMapDebugLog = exports.calcFieldSize = exports.encodeMapPrefix = exports.parseMapType = exports.splitFields = exports.encodeScriptField = exports.encodeScriptFieldAsString = exports.encodePrimitiveValues = exports.addressVal = exports.byteVecVal = exports.u256Val = exports.i256Val = exports.boolVal = exports.encodeVmAddress = exports.encodeVmByteVec = exports.encodeVmU256 = exports.encodeVmI256 = exports.encodeVmBool = exports.VmValType = exports.encodeAddress = exports.encodeByteVec = void 0;
const api_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/index.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/index.js [app-ssr] (ecmascript)");
const codec_2 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/codec.js [app-ssr] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/error.js [app-ssr] (ecmascript)");
function encodeByteVec(hex) {
    if (!(0, utils_1.isHexString)(hex)) {
        throw Error(`Given value ${hex} is not a valid hex string`);
    }
    const bytes = (0, utils_1.hexToBinUnsafe)(hex);
    return codec_1.byteStringCodec.encode(bytes);
}
exports.encodeByteVec = encodeByteVec;
function encodeAddress(address) {
    return utils_1.bs58.decode(address);
}
exports.encodeAddress = encodeAddress;
var VmValType;
(function(VmValType) {
    VmValType[VmValType["Bool"] = 0] = "Bool";
    VmValType[VmValType["I256"] = 1] = "I256";
    VmValType[VmValType["U256"] = 2] = "U256";
    VmValType[VmValType["ByteVec"] = 3] = "ByteVec";
    VmValType[VmValType["Address"] = 4] = "Address";
})(VmValType = exports.VmValType || (exports.VmValType = {}));
function encodeVmBool(bool) {
    return new Uint8Array([
        VmValType.Bool,
        ...codec_2.boolCodec.encode(bool)
    ]);
}
exports.encodeVmBool = encodeVmBool;
function encodeVmI256(i256) {
    return new Uint8Array([
        VmValType.I256,
        ...codec_1.i256Codec.encode(i256)
    ]);
}
exports.encodeVmI256 = encodeVmI256;
function encodeVmU256(u256) {
    return new Uint8Array([
        VmValType.U256,
        ...codec_1.u256Codec.encode(u256)
    ]);
}
exports.encodeVmU256 = encodeVmU256;
function encodeVmByteVec(bytes) {
    return new Uint8Array([
        VmValType.ByteVec,
        ...encodeByteVec(bytes)
    ]);
}
exports.encodeVmByteVec = encodeVmByteVec;
function encodeVmAddress(address) {
    return new Uint8Array([
        VmValType.Address,
        ...encodeAddress(address)
    ]);
}
exports.encodeVmAddress = encodeVmAddress;
function boolVal(value) {
    return {
        type: 'Bool',
        value
    };
}
exports.boolVal = boolVal;
function i256Val(value) {
    return {
        type: 'I256',
        value: BigInt(value)
    };
}
exports.i256Val = i256Val;
function u256Val(value) {
    return {
        type: 'U256',
        value: BigInt(value)
    };
}
exports.u256Val = u256Val;
function byteVecVal(value) {
    return {
        type: 'ByteVec',
        value
    };
}
exports.byteVecVal = byteVecVal;
function addressVal(value) {
    return {
        type: 'Address',
        value
    };
}
exports.addressVal = addressVal;
function encodePrimitiveValues(values) {
    return encodeFields(values.map(({ type, value })=>({
            name: `${value}`,
            type,
            value
        })));
}
exports.encodePrimitiveValues = encodePrimitiveValues;
function invalidScriptField(tpe, value) {
    return Error(`Invalid script field ${value} for type ${tpe}`);
}
function encodeScriptFieldI256(value) {
    return codec_1.instrCodec.encode((0, codec_1.toI256)(value));
}
function encodeScriptFieldU256(value) {
    return codec_1.instrCodec.encode((0, codec_1.toU256)(value));
}
function encodeScriptFieldAsString(tpe, value) {
    return (0, utils_1.binToHex)(encodeScriptField(tpe, value));
}
exports.encodeScriptFieldAsString = encodeScriptFieldAsString;
function encodeScriptField(tpe, value) {
    switch(tpe){
        case 'Bool':
            const byte = (0, api_1.toApiBoolean)(value) ? codec_1.ConstTrue.code : codec_1.ConstFalse.code;
            return new Uint8Array([
                byte
            ]);
        case 'I256':
            const i256 = (0, api_1.toApiNumber256)(value);
            return encodeScriptFieldI256(BigInt(i256));
        case 'U256':
            const u256 = (0, api_1.toApiNumber256)(value);
            return encodeScriptFieldU256(BigInt(u256));
        case 'Address':
            const address = (0, api_1.toApiAddress)(value);
            return new Uint8Array([
                codec_1.AddressConstCode,
                ...encodeAddress(address)
            ]);
        default:
            const hexStr = (0, api_1.toApiByteVec)(value);
            return new Uint8Array([
                codec_1.BytesConstCode,
                ...encodeByteVec(hexStr)
            ]);
    }
    throw invalidScriptField(tpe, value);
}
exports.encodeScriptField = encodeScriptField;
function splitFields(fieldsSig) {
    return fieldsSig.types.reduce(([mapFields, fieldsExceptMaps], type, index)=>{
        const fieldSig = type.startsWith('Map[') ? mapFields : fieldsExceptMaps;
        fieldSig.names.push(fieldsSig.names[`${index}`]);
        fieldSig.types.push(type);
        fieldSig.isMutable.push(fieldsSig.isMutable[`${index}`]);
        return [
            mapFields,
            fieldsExceptMaps
        ];
    }, [
        {
            names: [],
            types: [],
            isMutable: []
        },
        {
            names: [],
            types: [],
            isMutable: []
        }
    ]);
}
exports.splitFields = splitFields;
function parseMapType(type) {
    if (!type.startsWith('Map[')) {
        throw new Error(`Expected map type, got ${type}`);
    }
    const keyStartIndex = type.indexOf('[');
    const keyEndIndex = type.indexOf(',');
    return [
        type.slice(keyStartIndex + 1, keyEndIndex),
        type.slice(keyEndIndex + 1, type.length - 1)
    ];
}
exports.parseMapType = parseMapType;
function encodeMapPrefix(mapIndex) {
    const str = `__map__${mapIndex}__`;
    const bytes = new Uint8Array(str.length);
    for(let i = 0; i < str.length; i += 1){
        bytes[i] = str.charCodeAt(i);
    }
    return bytes;
}
exports.encodeMapPrefix = encodeMapPrefix;
function fromAscii(str) {
    let result = '';
    for(let i = 0; i < str.length; i += 2){
        const ascii = parseInt(str.slice(i, i + 2), 16);
        result += String.fromCharCode(ascii);
    }
    return result;
}
function calcFieldSize(type, isMutable, structs) {
    const struct = structs.find((s)=>s.name === type);
    if (struct !== undefined) {
        return struct.fieldTypes.reduce((acc, fieldType, index)=>{
            const isFieldMutable = isMutable && struct.isMutable[`${index}`];
            const subFieldSize = calcFieldSize(fieldType, isFieldMutable, structs);
            return {
                immFields: acc.immFields + subFieldSize.immFields,
                mutFields: acc.mutFields + subFieldSize.mutFields
            };
        }, {
            immFields: 0,
            mutFields: 0
        });
    }
    if (type.startsWith('[')) {
        const [baseType, size] = (0, api_1.decodeArrayType)(type);
        const base = calcFieldSize(baseType, isMutable, structs);
        return {
            immFields: base.immFields * size,
            mutFields: base.mutFields * size
        };
    }
    return isMutable ? {
        immFields: 0,
        mutFields: 1
    } : {
        immFields: 1,
        mutFields: 0
    };
}
exports.calcFieldSize = calcFieldSize;
function tryDecodeMapDebugLog(message) {
    if (!message.startsWith('insert at map path: ') && !message.startsWith('remove at map path: ')) {
        return undefined;
    }
    const parts = message.split(':');
    if (parts.length !== 2) return undefined;
    const pathString = parts[1].slice(1);
    if (!(0, utils_1.isHexString)(pathString)) return undefined;
    const prefix = '5f5f6d61705f5f'; // __map__
    const remain = pathString.slice(prefix.length);
    const suffix = '5f5f'; // __
    const suffixIndex = remain.indexOf(suffix);
    if (suffixIndex === -1) return undefined;
    const encodedMapIndex = remain.slice(0, suffixIndex);
    const mapIndex = parseInt(fromAscii(encodedMapIndex));
    const encodedKey = (0, utils_1.hexToBinUnsafe)(remain.slice(suffixIndex + suffix.length));
    const isInsert = message.startsWith('insert');
    return {
        path: pathString,
        mapIndex,
        encodedKey,
        isInsert
    };
}
exports.tryDecodeMapDebugLog = tryDecodeMapDebugLog;
function decodePrimitive(value, type) {
    switch(type){
        case 'Bool':
            return codec_2.boolCodec.decode(value);
        case 'I256':
            return codec_1.i256Codec.decode(value);
        case 'U256':
            return codec_1.u256Codec.decode(value);
        case 'ByteVec':
            return (0, utils_1.binToHex)(value);
        case 'Address':
            return utils_1.bs58.encode(value);
        default:
            throw Error(`Expected primitive type, got ${type}`);
    }
}
exports.decodePrimitive = decodePrimitive;
function encodeMapKey(value, type) {
    switch(type){
        case 'Bool':
            const byte = (0, api_1.toApiBoolean)(value) ? 1 : 0;
            return new Uint8Array([
                byte
            ]);
        case 'I256':
            const i256 = (0, api_1.toApiNumber256)(value);
            return codec_1.i256Codec.encode(BigInt(i256));
        case 'U256':
            const u256 = (0, api_1.toApiNumber256)(value);
            return codec_1.u256Codec.encode(BigInt(u256));
        case 'ByteVec':
            const hexStr = (0, api_1.toApiByteVec)(value);
            return (0, utils_1.hexToBinUnsafe)(hexStr);
        case 'Address':
            const address = (0, api_1.toApiAddress)(value);
            return encodeAddress(address);
        default:
            throw Error(`Expected primitive type, got ${type}`);
    }
}
exports.encodeMapKey = encodeMapKey;
function typeLength(typ, structs) {
    if (api_1.PrimitiveTypes.includes(typ)) {
        return 1;
    }
    if (typ.startsWith('[')) {
        const [baseType, size] = (0, api_1.decodeArrayType)(typ);
        return size * typeLength(baseType, structs);
    }
    const struct = structs.find((s)=>s.name === typ);
    if (struct !== undefined) {
        return struct.fieldTypes.reduce((acc, fieldType)=>acc + typeLength(fieldType, structs), 0);
    }
    return 1;
}
exports.typeLength = typeLength;
function flattenFields(fields, names, types, isMutable, structs) {
    return names.flatMap((name, index)=>{
        if (!(name in fields)) {
            throw new Error(`The value of field ${name} is not provided`);
        }
        return flattenField(isMutable[`${index}`], name, types[`${index}`], fields[`${name}`], structs);
    });
}
exports.flattenFields = flattenFields;
function flattenField(isMutable, name, type, value, structs) {
    if (Array.isArray(value) && type.startsWith('[')) {
        const [baseType, size] = (0, api_1.decodeArrayType)(type);
        if (value.length !== size) {
            throw Error(`Invalid array length, expected ${size}, got ${value.length}`);
        }
        return value.flatMap((item, index)=>{
            return flattenField(isMutable, `${name}[${index}]`, baseType, item, structs);
        });
    }
    const struct = structs.find((s)=>s.name === type);
    if (struct !== undefined) {
        if (typeof value !== 'object') {
            throw Error(`Expected an object, but got ${typeof value}`);
        }
        return struct.fieldNames.flatMap((fieldName, index)=>{
            if (!(fieldName in value)) {
                throw new Error(`The value of field ${fieldName} is not provided`);
            }
            const isFieldMutable = struct.isMutable[`${index}`];
            const fieldType = struct.fieldTypes[`${index}`];
            const fieldValue = value[`${fieldName}`];
            return flattenField(isMutable && isFieldMutable, `${name}.${fieldName}`, fieldType, fieldValue, structs);
        });
    }
    const primitiveType = checkPrimitiveValue(name, type, value);
    return [
        {
            name,
            type: primitiveType,
            value,
            isMutable
        }
    ];
}
function checkPrimitiveValue(name, ralphType, value) {
    const tsType = typeof value;
    if (ralphType === 'Bool' && tsType === 'boolean') {
        return ralphType;
    }
    if ((ralphType === 'U256' || ralphType === 'I256') && (tsType === 'string' || tsType === 'number' || tsType === 'bigint')) {
        return ralphType;
    }
    if ((ralphType === 'Address' || ralphType === 'ByteVec') && tsType === 'string') {
        return ralphType;
    }
    if (!ralphType.startsWith('[') && tsType === 'string') {
        // contract type
        return 'ByteVec';
    }
    throw Error(`Invalid value ${value} for ${name}, expected a value of type ${ralphType}`);
}
const scriptFieldRegex = /\{([0-9]*)\}/g;
function buildScriptByteCode(bytecodeTemplate, fields, fieldsSig, structs) {
    const allFields = flattenFields(fields, fieldsSig.names, fieldsSig.types, fieldsSig.isMutable, structs);
    return bytecodeTemplate.replace(scriptFieldRegex, (_, fieldIndex)=>{
        const field = allFields[`${fieldIndex}`];
        return _encodeField(field.name, ()=>encodeScriptFieldAsString(field.type, field.value));
    });
}
exports.buildScriptByteCode = buildScriptByteCode;
function _encodeField(fieldName, encodeFunc) {
    try {
        return encodeFunc();
    } catch (error) {
        throw new error_1.TraceableError(`Failed to encode the field ${fieldName}`, error);
    }
}
function encodeFields(fields) {
    const prefix = codec_1.i32Codec.encode(fields.length);
    return fields.reduce((acc, field)=>{
        const encoded = _encodeField(field.name, ()=>encodeContractField(field.type, field.value));
        const bytes = new Uint8Array(acc.byteLength + encoded.byteLength);
        bytes.set(acc, 0);
        bytes.set(encoded, acc.byteLength);
        return bytes;
    }, prefix);
}
function encodeContractFields(fields, fieldsSig, structs) {
    const allFields = flattenFields(fields, fieldsSig.names, fieldsSig.types, fieldsSig.isMutable, structs);
    return {
        encodedImmFields: encodeFields(allFields.filter((f)=>!f.isMutable)),
        encodedMutFields: encodeFields(allFields.filter((f)=>f.isMutable))
    };
}
exports.encodeContractFields = encodeContractFields;
function buildContractByteCode(bytecode, fields, fieldsSig, structs) {
    const { encodedImmFields, encodedMutFields } = encodeContractFields(fields, fieldsSig, structs);
    return bytecode + (0, utils_1.binToHex)(encodedImmFields) + (0, utils_1.binToHex)(encodedMutFields);
}
exports.buildContractByteCode = buildContractByteCode;
function encodeContractField(tpe, value) {
    switch(tpe){
        case 'Bool':
            return encodeVmBool((0, api_1.toApiBoolean)(value));
        case 'I256':
            return encodeVmI256(BigInt((0, api_1.toApiNumber256)(value)));
        case 'U256':
            return encodeVmU256(BigInt((0, api_1.toApiNumber256)(value)));
        case 'ByteVec':
            return encodeVmByteVec((0, api_1.toApiByteVec)(value));
        case 'Address':
            return encodeVmAddress((0, api_1.toApiAddress)(value));
        default:
            throw Error(`Expected primitive type, got ${tpe}`);
    }
}
exports.encodeContractField = encodeContractField;
function buildDebugBytecode(bytecode, bytecodePatch) {
    if (bytecodePatch === '') {
        return bytecode;
    }
    const pattern = /[=+-][0-9a-f]*/g;
    let result = '';
    let index = 0;
    for (const parts of bytecodePatch.matchAll(pattern)){
        const part = parts[0];
        const diffType = part[0];
        if (diffType === '=') {
            const length = parseInt(part.substring(1));
            result = result + bytecode.slice(index, index + length);
            index = index + length;
        } else if (diffType === '+') {
            result = result + part.substring(1);
        } else {
            const length = parseInt(part.substring(1));
            index = index + length;
        }
    }
    return result;
}
exports.buildDebugBytecode = buildDebugBytecode; // export function buildContractByteCode(
 //   compiled: node.TemplateContractByteCode,
 //   templateVariables: TemplateVariables
 // ): string {
 //   const methodsBuilt = compiled.methodsByteCode.map((template) => buildByteCode(template, templateVariables))
 //   let count = 0
 //   const methodIndexes = methodsBuilt.map((hex) => {
 //     count += hex.length / 2
 //     return count
 //   })
 //   return (
 //     binToHex(encodeI256(BigInt(compiled.filedLength))) +
 //     binToHex(encodeI256(BigInt(methodIndexes.length))) +
 //     methodIndexes.map((index) => binToHex(encodeI256(BigInt(index)))).join('') +
 //     methodsBuilt.join('')
 //   )
 // }
}}),
"[project]/node_modules/@alephium/web3/dist/src/global.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getCurrentExplorerProvider = exports.setCurrentExplorerProvider = exports.getCurrentNodeProvider = exports.setCurrentNodeProvider = void 0;
const api_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/index.js [app-ssr] (ecmascript)");
let _currentNodeProvider = undefined;
function setCurrentNodeProvider(provider, apiKey, customFetch) {
    if (typeof provider == 'string') {
        _currentNodeProvider = new api_1.NodeProvider(provider, apiKey, customFetch);
    } else {
        _currentNodeProvider = provider;
    }
}
exports.setCurrentNodeProvider = setCurrentNodeProvider;
function getCurrentNodeProvider() {
    if (typeof _currentNodeProvider === 'undefined') {
        throw Error('No node provider is set.');
    }
    return _currentNodeProvider;
}
exports.getCurrentNodeProvider = getCurrentNodeProvider;
let _currentExplorerProvider = undefined;
function setCurrentExplorerProvider(provider, apiKey, customFetch) {
    if (typeof provider == 'string') {
        _currentExplorerProvider = new api_1.ExplorerProvider(provider, apiKey, customFetch);
    } else {
        _currentExplorerProvider = provider;
    }
}
exports.setCurrentExplorerProvider = setCurrentExplorerProvider;
// Different from `NodeProvider`, this may return `undefined`
// as ExplorerProvider is not necessary for all applications
function getCurrentExplorerProvider() {
    return _currentExplorerProvider;
}
exports.getCurrentExplorerProvider = getCurrentExplorerProvider;
}}),
"[project]/node_modules/@alephium/web3/dist/src/contract/events.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.subscribeToEvents = exports.EventSubscription = void 0;
const web3 = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/global.js [app-ssr] (ecmascript)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
class EventSubscription extends utils_1.Subscription {
    constructor(options, contractAddress, fromCount){
        super(options);
        this.contractAddress = contractAddress;
        this.fromCount = typeof fromCount === 'undefined' ? 0 : fromCount;
        this.onEventCountChanged = options.onEventCountChanged;
    }
    currentEventCount() {
        return this.fromCount;
    }
    async getEvents(start) {
        try {
            return await web3.getCurrentNodeProvider().events.getEventsContractContractaddress(this.contractAddress, {
                start
            });
        } catch (error) {
            if (error instanceof Error && error.message.includes(`Contract events of ${this.contractAddress} not found`)) {
                return {
                    events: [],
                    nextStart: start
                };
            }
            throw error;
        }
    }
    async polling() {
        try {
            const events = await this.getEvents(this.fromCount);
            if (this.fromCount === events.nextStart) {
                return;
            }
            const promises = events.events.map((event)=>this.messageCallback(event));
            await Promise.all(promises);
            this.fromCount = events.nextStart;
            if (this.onEventCountChanged !== undefined) {
                await this.onEventCountChanged(this.fromCount);
            }
            await this.polling();
        } catch (err) {
            await this.errorCallback(err, this);
        }
    }
}
exports.EventSubscription = EventSubscription;
function subscribeToEvents(options, contractAddress, fromCount) {
    const subscription = new EventSubscription(options, contractAddress, fromCount);
    subscription.subscribe();
    return subscription;
}
exports.subscribeToEvents = subscribeToEvents;
}}),
"[project]/node_modules/@alephium/web3/dist/src/contract/contract.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getContractCodeByCodeHash = exports.getTokenIdFromUnsignedTx = exports.getContractIdFromUnsignedTx = exports.getContractEventsCurrentCount = exports.multicallMethods = exports.signExecuteMethod = exports.callMethod = exports.subscribeContractEvents = exports.subscribeContractEvent = exports.decodeEvent = exports.subscribeContractDestroyedEvent = exports.subscribeContractCreatedEvent = exports.fetchContractState = exports.ContractInstance = exports.getMapItem = exports.RalphMap = exports.printDebugMessagesFromTx = exports.getDebugMessagesFromTx = exports.testMethod = exports.extractMapsFromApiResult = exports.addStdIdToFields = exports.subscribeEventsFromContract = exports.decodeContractDestroyedEvent = exports.decodeContractCreatedEvent = exports.DestroyContractEventAddresses = exports.CreateContractEventAddresses = exports.ExecutableScript = exports.ContractFactory = exports.randomTxId = exports.fromApiEventFields = exports.fromApiArray = exports.getDefaultValue = exports.fromApiFields = exports.Script = exports.Contract = exports.Artifact = exports.Struct = exports.DEFAULT_COMPILER_OPTIONS = exports.DEFAULT_NODE_COMPILER_OPTIONS = exports.StdIdFieldName = void 0;
const fs_1 = __turbopack_context__.r("[externals]/fs [external] (fs, cjs)");
const api_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/index.js [app-ssr] (ecmascript)");
const ralph = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/contract/ralph.js [app-ssr] (ecmascript)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const address_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/address/index.js [app-ssr] (ecmascript)");
const global_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/global.js [app-ssr] (ecmascript)");
const events_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/contract/events.js [app-ssr] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/constants.js [app-ssr] (ecmascript)");
const blake = __importStar(__turbopack_context__.r("[project]/node_modules/blakejs/index.js [app-ssr] (ecmascript)"));
const debug_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/debug.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/index.js [app-ssr] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/error.js [app-ssr] (ecmascript)");
const crypto = new utils_1.WebCrypto();
exports.StdIdFieldName = '__stdInterfaceId';
exports.DEFAULT_NODE_COMPILER_OPTIONS = {
    ignoreUnusedConstantsWarnings: false,
    ignoreUnusedVariablesWarnings: false,
    ignoreUnusedFieldsWarnings: false,
    ignoreUnusedPrivateFunctionsWarnings: false,
    ignoreUpdateFieldsCheckWarnings: false,
    ignoreCheckExternalCallerWarnings: false,
    ignoreUnusedFunctionReturnWarnings: false,
    skipAbstractContractCheck: false
};
exports.DEFAULT_COMPILER_OPTIONS = {
    errorOnWarnings: true,
    ...exports.DEFAULT_NODE_COMPILER_OPTIONS
};
class Struct {
    constructor(name, fieldNames, fieldTypes, isMutable){
        this.name = name;
        this.fieldNames = fieldNames;
        this.fieldTypes = fieldTypes;
        this.isMutable = isMutable;
    }
    static fromJson(json) {
        if (json.name === null || json.fieldNames === null || json.fieldTypes === null || json.isMutable === null) {
            throw Error('The JSON for struct is incomplete');
        }
        return new Struct(json.name, json.fieldNames, json.fieldTypes, json.isMutable);
    }
    static fromStructSig(sig) {
        return new Struct(sig.name, sig.fieldNames, sig.fieldTypes, sig.isMutable);
    }
    toJson() {
        return {
            name: this.name,
            fieldNames: this.fieldNames,
            fieldTypes: this.fieldTypes,
            isMutable: this.isMutable
        };
    }
}
exports.Struct = Struct;
class Artifact {
    constructor(version, name, functions){
        this.version = version;
        this.name = name;
        this.functions = functions;
    }
    async isDevnet(signer) {
        if (!signer.nodeProvider) {
            return false;
        }
        const chainParams = await signer.nodeProvider.infos.getInfosChainParams();
        return (0, utils_1.isDevnet)(chainParams.networkId);
    }
}
exports.Artifact = Artifact;
function fromFunctionSig(sig) {
    return {
        name: sig.name,
        paramNames: sig.paramNames,
        paramTypes: sig.paramTypes,
        paramIsMutable: sig.paramIsMutable,
        returnTypes: sig.returnTypes
    };
}
class Contract extends Artifact {
    constructor(version, name, bytecode, bytecodeDebugPatch, codeHash, codeHashDebug, fieldsSig, eventsSig, functions, constants, enums, structs, mapsSig, stdInterfaceId){
        super(version, name, functions);
        this.bytecode = bytecode;
        this.bytecodeDebugPatch = bytecodeDebugPatch;
        this.codeHash = codeHash;
        this.fieldsSig = fieldsSig;
        this.eventsSig = eventsSig;
        this.constants = constants;
        this.enums = enums;
        this.structs = structs;
        this.mapsSig = mapsSig;
        this.stdInterfaceId = stdInterfaceId;
        this.bytecodeDebug = ralph.buildDebugBytecode(this.bytecode, this.bytecodeDebugPatch);
        this.codeHashDebug = codeHashDebug;
        this.decodedContract = codec_1.contract.contractCodec.decodeContract((0, utils_1.hexToBinUnsafe)(this.bytecode));
        this.bytecodeForTesting = undefined;
        this.decodedTestingContract = undefined;
        this.codeHashForTesting = undefined;
    }
    isInlineFunc(index) {
        if (index >= this.functions.length) {
            throw new Error(`Invalid function index ${index}, function size: ${this.functions.length}`);
        }
        const inlineFuncFromIndex = this.decodedContract.methods.length;
        return index >= inlineFuncFromIndex;
    }
    getByteCodeForTesting() {
        if (this.bytecodeForTesting !== undefined) return this.bytecodeForTesting;
        const hasInlineFunction = this.functions.length > this.decodedContract.methods.length;
        if (!hasInlineFunction && this.publicFunctions().length == this.functions.length) {
            this.bytecodeForTesting = this.bytecodeDebug;
            this.codeHashForTesting = this.codeHashDebug;
            return this.bytecodeForTesting;
        }
        const decodedDebugContract = codec_1.contract.contractCodec.decodeContract((0, utils_1.hexToBinUnsafe)(this.bytecodeDebug));
        const methods = decodedDebugContract.methods.map((method)=>({
                ...method,
                isPublic: true
            }));
        const bytecodeForTesting = codec_1.contract.contractCodec.encodeContract({
            fieldLength: decodedDebugContract.fieldLength,
            methods: methods
        });
        const codeHashForTesting = blake.blake2b(bytecodeForTesting, undefined, 32);
        this.bytecodeForTesting = (0, utils_1.binToHex)(bytecodeForTesting);
        this.codeHashForTesting = (0, utils_1.binToHex)(codeHashForTesting);
        return this.bytecodeForTesting;
    }
    getDecodedTestingContract() {
        if (this.decodedTestingContract !== undefined) return this.decodedTestingContract;
        const bytecodeForTesting = (0, utils_1.hexToBinUnsafe)(this.getByteCodeForTesting());
        this.decodedTestingContract = codec_1.contract.contractCodec.decodeContract(bytecodeForTesting);
        return this.decodedTestingContract;
    }
    hasCodeHash(hash) {
        return this.codeHash === hash || this.codeHashDebug === hash || this.codeHashForTesting === hash;
    }
    getDecodedMethod(methodIndex) {
        return this.decodedContract.methods[`${methodIndex}`];
    }
    publicFunctions() {
        return this.functions.filter((_, index)=>this.getDecodedMethod(index).isPublic);
    }
    usingPreapprovedAssetsFunctions() {
        return this.functions.filter((_, index)=>this.getDecodedMethod(index).usePreapprovedAssets);
    }
    usingAssetsInContractFunctions() {
        return this.functions.filter((_, index)=>this.getDecodedMethod(index).useContractAssets);
    }
    isMethodUsePreapprovedAssets(isDevnet, methodIndex) {
        if (!isDevnet || !this.isInlineFunc(methodIndex)) return this.getDecodedMethod(methodIndex).usePreapprovedAssets;
        const contract = this.getDecodedTestingContract();
        return contract.methods[`${methodIndex}`].usePreapprovedAssets;
    }
    // TODO: safely parse json
    static fromJson(artifact, bytecodeDebugPatch = '', codeHashDebug = '', structs = []) {
        if (artifact.version == null || artifact.name == null || artifact.bytecode == null || artifact.codeHash == null || artifact.fieldsSig == null || artifact.eventsSig == null || artifact.constants == null || artifact.enums == null || artifact.functions == null) {
            throw Error('The artifact JSON for contract is incomplete');
        }
        const contract = new Contract(artifact.version, artifact.name, artifact.bytecode, bytecodeDebugPatch, artifact.codeHash, codeHashDebug ? codeHashDebug : artifact.codeHash, artifact.fieldsSig, artifact.eventsSig, artifact.functions, artifact.constants, artifact.enums, structs, artifact.mapsSig === null ? undefined : artifact.mapsSig, artifact.stdInterfaceId === null ? undefined : artifact.stdInterfaceId);
        return contract;
    }
    static fromCompileResult(result, structs = []) {
        return new Contract(result.version, result.name, result.bytecode, result.bytecodeDebugPatch, result.codeHash, result.codeHashDebug, result.fields, result.events, result.functions.map(fromFunctionSig), result.constants, result.enums, structs, result.maps, result.stdInterfaceId);
    }
    // support both 'code.ral' and 'code.ral.json'
    static async fromArtifactFile(path, bytecodeDebugPatch, codeHashDebug, structs = []) {
        const content = await fs_1.promises.readFile(path);
        const artifact = JSON.parse(content.toString());
        return Contract.fromJson(artifact, bytecodeDebugPatch, codeHashDebug, structs);
    }
    toString() {
        const object = {
            version: this.version,
            name: this.name,
            bytecode: this.bytecode,
            codeHash: this.codeHash,
            fieldsSig: this.fieldsSig,
            eventsSig: this.eventsSig,
            functions: this.functions,
            constants: this.constants,
            enums: this.enums
        };
        if (this.mapsSig !== undefined) {
            object.mapsSig = this.mapsSig;
        }
        if (this.stdInterfaceId !== undefined) {
            object.stdInterfaceId = this.stdInterfaceId;
        }
        return JSON.stringify(object, null, 2);
    }
    getInitialFieldsWithDefaultValues() {
        const fields = this.stdInterfaceId === undefined ? this.fieldsSig : {
            names: this.fieldsSig.names.slice(0, -1),
            types: this.fieldsSig.types.slice(0, -1),
            isMutable: this.fieldsSig.isMutable.slice(0, -1)
        };
        return getDefaultValue(fields, this.structs);
    }
    toState(fields, asset, address) {
        const addressDef = typeof address !== 'undefined' ? address : Contract.randomAddress();
        return {
            address: addressDef,
            contractId: (0, utils_1.binToHex)((0, address_1.contractIdFromAddress)(addressDef)),
            bytecode: this.bytecode,
            codeHash: this.codeHash,
            fields: fields,
            fieldsSig: this.fieldsSig,
            asset: asset
        };
    }
    // no need to be cryptographically strong random
    static randomAddress() {
        const bytes = new Uint8Array(33);
        crypto.getRandomValues(bytes);
        bytes[0] = 3;
        return utils_1.bs58.encode(bytes);
    }
    printDebugMessages(funcName, messages) {
        if ((0, debug_1.isContractDebugMessageEnabled)() && messages.length != 0) {
            console.log(`Testing ${this.name}.${funcName}:`);
            messages.forEach((m)=>printDebugMessage(m));
        }
    }
    toApiFields(fields) {
        if (typeof fields === 'undefined') {
            return [];
        } else {
            return toApiFields(fields, this.fieldsSig, this.structs);
        }
    }
    toApiArgs(funcName, args) {
        if (args) {
            const func = this.functions.find((func)=>func.name == funcName);
            if (func == null) {
                throw new Error(`Invalid function name: ${funcName}`);
            }
            return toApiArgs(args, func, this.structs);
        } else {
            return [];
        }
    }
    getMethodIndex(funcName) {
        return this.functions.findIndex((func)=>func.name === funcName);
    }
    toApiContractStates(states) {
        return typeof states != 'undefined' ? states.map((state)=>toApiContractState(state, this.structs)) : undefined;
    }
    toApiTestContractParams(funcName, params) {
        const allFields = params.initialFields === undefined ? [] : ralph.flattenFields(params.initialFields, this.fieldsSig.names, this.fieldsSig.types, this.fieldsSig.isMutable, this.structs);
        const immFields = allFields.filter((f)=>!f.isMutable).map((f)=>(0, api_1.toApiVal)(f.value, f.type));
        const mutFields = allFields.filter((f)=>f.isMutable).map((f)=>(0, api_1.toApiVal)(f.value, f.type));
        const methodIndex = this.getMethodIndex(funcName);
        return {
            group: params.group,
            blockHash: params.blockHash,
            blockTimeStamp: params.blockTimeStamp,
            txId: params.txId,
            address: params.address,
            callerContractAddress: params.callerAddress,
            bytecode: this.isInlineFunc(methodIndex) ? this.getByteCodeForTesting() : this.bytecodeDebug,
            initialImmFields: immFields,
            initialMutFields: mutFields,
            initialAsset: typeof params.initialAsset !== 'undefined' ? toApiAsset(params.initialAsset) : undefined,
            methodIndex,
            args: this.toApiArgs(funcName, params.testArgs),
            existingContracts: this.toApiContractStates(params.existingContracts),
            inputAssets: toApiInputAssets(params.inputAssets)
        };
    }
    fromApiContractState(state) {
        return {
            address: state.address,
            contractId: (0, utils_1.binToHex)((0, address_1.contractIdFromAddress)(state.address)),
            bytecode: state.bytecode,
            initialStateHash: state.initialStateHash,
            codeHash: state.codeHash,
            fields: fromApiFields(state.immFields, state.mutFields, this.fieldsSig, this.structs),
            fieldsSig: this.fieldsSig,
            asset: fromApiAsset(state.asset)
        };
    }
    static fromApiContractState(state, getContractByCodeHash) {
        const contract = getContractByCodeHash(state.codeHash);
        return contract.fromApiContractState(state);
    }
    static fromApiEvent(event, codeHash, txId, getContractByCodeHash) {
        let fields;
        let name;
        if (event.eventIndex == Contract.ContractCreatedEventIndex) {
            fields = toContractCreatedEventFields(fromApiEventFields(event.fields, Contract.ContractCreatedEvent, true));
            name = Contract.ContractCreatedEvent.name;
        } else if (event.eventIndex == Contract.ContractDestroyedEventIndex) {
            fields = fromApiEventFields(event.fields, Contract.ContractDestroyedEvent, true);
            name = Contract.ContractDestroyedEvent.name;
        } else {
            const contract = getContractByCodeHash(codeHash);
            const eventSig = contract.eventsSig[event.eventIndex];
            fields = fromApiEventFields(event.fields, eventSig);
            name = eventSig.name;
        }
        return {
            txId: txId,
            blockHash: event.blockHash,
            contractAddress: event.contractAddress,
            name: name,
            eventIndex: event.eventIndex,
            fields: fields
        };
    }
    fromApiTestContractResult(methodName, result, txId, getContractByCodeHash) {
        const methodIndex = this.functions.findIndex((sig)=>sig.name === methodName);
        const returnTypes = this.functions[`${methodIndex}`].returnTypes;
        const rawReturn = fromApiArray(result.returns, returnTypes, this.structs);
        const returns = rawReturn.length === 0 ? null : rawReturn.length === 1 ? rawReturn[0] : rawReturn;
        const addressToCodeHash = new Map();
        addressToCodeHash.set(result.address, result.codeHash);
        result.contracts.forEach((contract)=>addressToCodeHash.set(contract.address, contract.codeHash));
        return {
            contractId: (0, utils_1.binToHex)((0, address_1.contractIdFromAddress)(result.address)),
            contractAddress: result.address,
            returns: returns,
            gasUsed: result.gasUsed,
            contracts: result.contracts.map((contract)=>Contract.fromApiContractState(contract, getContractByCodeHash)),
            txOutputs: result.txOutputs.map(fromApiOutput),
            events: Contract.fromApiEvents(result.events, addressToCodeHash, txId, getContractByCodeHash),
            debugMessages: result.debugMessages
        };
    }
    async txParamsForDeployment(signer, params) {
        const isDevnet = await this.isDevnet(signer);
        const initialFields = params.initialFields ?? {};
        const bytecode = this.buildByteCodeToDeploy(addStdIdToFields(this, initialFields), isDevnet, params.exposePrivateFunctions ?? false);
        const selectedAccount = await signer.getSelectedAccount();
        const signerParams = {
            signerAddress: selectedAccount.address,
            signerKeyType: selectedAccount.keyType,
            bytecode: bytecode,
            initialAttoAlphAmount: params?.initialAttoAlphAmount,
            issueTokenAmount: params?.issueTokenAmount,
            issueTokenTo: params?.issueTokenTo,
            initialTokenAmounts: params?.initialTokenAmounts,
            gasAmount: params?.gasAmount,
            gasPrice: params?.gasPrice
        };
        return signerParams;
    }
    buildByteCodeToDeploy(initialFields, isDevnet, exposePrivateFunctions = false) {
        if (exposePrivateFunctions && !isDevnet) {
            throw new Error('Cannot expose private functions in non-devnet environment');
        }
        try {
            const bytecode = exposePrivateFunctions && isDevnet ? this.getByteCodeForTesting() : isDevnet ? this.bytecodeDebug : this.bytecode;
            return ralph.buildContractByteCode(bytecode, initialFields, this.fieldsSig, this.structs);
        } catch (error) {
            throw new error_1.TraceableError(`Failed to build bytecode for contract ${this.name}`, error);
        }
    }
    static fromApiEvents(events, addressToCodeHash, txId, getContractByCodeHash) {
        return events.map((event)=>{
            const contractAddress = event.contractAddress;
            const codeHash = addressToCodeHash.get(contractAddress);
            if (typeof codeHash !== 'undefined' || event.eventIndex < 0) {
                return Contract.fromApiEvent(event, codeHash, txId, getContractByCodeHash);
            } else {
                throw Error(`Cannot find codeHash for the contract address: ${contractAddress}`);
            }
        });
    }
    toApiCallContract(params, groupIndex, contractAddress, methodIndex) {
        const functionSig = this.functions[`${methodIndex}`];
        const args = toApiArgs(params.args ?? {}, functionSig, this.structs);
        return {
            ...params,
            group: groupIndex,
            address: contractAddress,
            methodIndex: methodIndex,
            args: args,
            inputAssets: toApiInputAssets(params.inputAssets)
        };
    }
    fromApiCallContractResult(result, txId, methodIndex, getContractByCodeHash) {
        const returnTypes = this.functions[`${methodIndex}`].returnTypes;
        const callResult = (0, api_1.tryGetCallResult)(result);
        return fromCallResult(callResult, txId, returnTypes, this.structs, getContractByCodeHash);
    }
}
exports.Contract = Contract;
Contract.ContractCreatedEventIndex = -1;
Contract.ContractCreatedEvent = {
    name: 'ContractCreated',
    fieldNames: [
        'address',
        'parentAddress',
        'stdInterfaceId'
    ],
    fieldTypes: [
        'Address',
        'Address',
        'ByteVec'
    ]
};
Contract.ContractDestroyedEventIndex = -2;
Contract.ContractDestroyedEvent = {
    name: 'ContractDestroyed',
    fieldNames: [
        'address'
    ],
    fieldTypes: [
        'Address'
    ]
};
Contract.DebugEventIndex = -3;
function fromCallResult(callResult, txId, returnTypes, structs, getContractByCodeHash) {
    const rawReturn = fromApiArray(callResult.returns, returnTypes, structs);
    const returns = rawReturn.length === 0 ? null : rawReturn.length === 1 ? rawReturn[0] : rawReturn;
    const addressToCodeHash = new Map();
    callResult.contracts.forEach((contract)=>addressToCodeHash.set(contract.address, contract.codeHash));
    return {
        returns: returns,
        gasUsed: callResult.gasUsed,
        contracts: callResult.contracts.map((state)=>Contract.fromApiContractState(state, getContractByCodeHash)),
        txInputs: callResult.txInputs,
        txOutputs: callResult.txOutputs.map((output)=>fromApiOutput(output)),
        events: Contract.fromApiEvents(callResult.events, addressToCodeHash, txId, getContractByCodeHash),
        debugMessages: callResult.debugMessages
    };
}
class Script extends Artifact {
    constructor(version, name, bytecodeTemplate, bytecodeDebugPatch, fieldsSig, functions, structs){
        super(version, name, functions);
        this.bytecodeTemplate = bytecodeTemplate;
        this.bytecodeDebugPatch = bytecodeDebugPatch;
        this.fieldsSig = fieldsSig;
        this.structs = structs;
    }
    static fromCompileResult(result, structs = []) {
        return new Script(result.version, result.name, result.bytecodeTemplate, result.bytecodeDebugPatch, result.fields, result.functions.map(fromFunctionSig), structs);
    }
    // TODO: safely parse json
    static fromJson(artifact, bytecodeDebugPatch = '', structs = []) {
        if (artifact.version == null || artifact.name == null || artifact.bytecodeTemplate == null || artifact.fieldsSig == null || artifact.functions == null) {
            throw Error('The artifact JSON for script is incomplete');
        }
        return new Script(artifact.version, artifact.name, artifact.bytecodeTemplate, bytecodeDebugPatch, artifact.fieldsSig, artifact.functions, structs);
    }
    static async fromArtifactFile(path, bytecodeDebugPatch, structs = []) {
        const content = await fs_1.promises.readFile(path);
        const artifact = JSON.parse(content.toString());
        return this.fromJson(artifact, bytecodeDebugPatch, structs);
    }
    toString() {
        const object = {
            version: this.version,
            name: this.name,
            bytecodeTemplate: this.bytecodeTemplate,
            fieldsSig: this.fieldsSig,
            functions: this.functions
        };
        return JSON.stringify(object, null, 2);
    }
    async txParamsForExecution(signer, params) {
        const selectedAccount = await signer.getSelectedAccount();
        const signerParams = {
            signerAddress: selectedAccount.address,
            signerKeyType: selectedAccount.keyType,
            bytecode: this.buildByteCodeToDeploy(params.initialFields ?? {}),
            attoAlphAmount: params.attoAlphAmount,
            tokens: params.tokens,
            gasAmount: params.gasAmount,
            gasPrice: params.gasPrice
        };
        return signerParams;
    }
    buildByteCodeToDeploy(initialFields) {
        try {
            return ralph.buildScriptByteCode(this.bytecodeTemplate, initialFields, this.fieldsSig, this.structs);
        } catch (error) {
            throw new error_1.TraceableError(`Failed to build bytecode for script ${this.name}`, error);
        }
    }
}
exports.Script = Script;
function fromApiFields(immFields, mutFields, fieldsSig, structs) {
    let [immIndex, mutIndex] = [
        0,
        0
    ];
    const func = (type, isMutable)=>{
        const nodeVal = isMutable ? mutFields[mutIndex++] : immFields[immIndex++];
        return (0, api_1.fromApiPrimitiveVal)(nodeVal, type);
    };
    return fieldsSig.names.reduce((acc, name, index)=>{
        const fieldType = fieldsSig.types[`${index}`];
        const isMutable = fieldsSig.isMutable[`${index}`];
        acc[`${name}`] = buildVal(isMutable, fieldType, structs, func);
        return acc;
    }, {});
}
exports.fromApiFields = fromApiFields;
function buildVal(isMutable, type, structs, func) {
    if (type.startsWith('[')) {
        const [baseType, size] = (0, api_1.decodeArrayType)(type);
        return Array.from(Array(size).keys()).map(()=>buildVal(isMutable, baseType, structs, func));
    }
    const struct = structs.find((s)=>s.name === type);
    if (struct !== undefined) {
        return struct.fieldNames.reduce((acc, name, index)=>{
            const fieldType = struct.fieldTypes[`${index}`];
            const isFieldMutable = isMutable && struct.isMutable[`${index}`];
            acc[`${name}`] = buildVal(isFieldMutable, fieldType, structs, func);
            return acc;
        }, {});
    }
    const primitiveType = api_1.PrimitiveTypes.includes(type) ? type : 'ByteVec'; // contract type
    return func(primitiveType, isMutable);
}
function getDefaultValue(fieldsSig, structs) {
    return fieldsSig.names.reduce((acc, name, index)=>{
        const type = fieldsSig.types[`${index}`];
        acc[`${name}`] = buildVal(false, type, structs, api_1.getDefaultPrimitiveValue);
        return acc;
    }, {});
}
exports.getDefaultValue = getDefaultValue;
function fromApiVal(iter, type, structs, systemEvent = false) {
    const func = (primitiveType)=>{
        const currentValue = iter.next();
        if (currentValue.done) throw Error('Not enough vals');
        return (0, api_1.fromApiPrimitiveVal)(currentValue.value, primitiveType, systemEvent);
    };
    return buildVal(false, type, structs, func);
}
function fromApiArray(values, types, structs) {
    const iter = values.values();
    return types.map((type)=>fromApiVal(iter, type, structs));
}
exports.fromApiArray = fromApiArray;
function fromApiEventFields(vals, eventSig, systemEvent = false) {
    const iter = vals.values();
    return eventSig.fieldNames.reduce((acc, name, index)=>{
        const type = eventSig.fieldTypes[`${index}`];
        // currently event does not support struct type
        acc[`${name}`] = fromApiVal(iter, type, [], systemEvent);
        return acc;
    }, {});
}
exports.fromApiEventFields = fromApiEventFields;
function toApiAsset(asset) {
    return {
        attoAlphAmount: (0, api_1.toApiNumber256)(asset.alphAmount),
        tokens: typeof asset.tokens !== 'undefined' ? asset.tokens.map(api_1.toApiToken) : []
    };
}
function fromApiAsset(asset) {
    return {
        alphAmount: (0, api_1.fromApiNumber256)(asset.attoAlphAmount),
        tokens: (0, api_1.fromApiTokens)(asset.tokens)
    };
}
function toApiContractState(state, structs) {
    const stateFields = state.fields ?? {};
    const fieldsSig = state.fieldsSig;
    const allFields = ralph.flattenFields(stateFields, fieldsSig.names, fieldsSig.types, fieldsSig.isMutable, structs);
    const immFields = allFields.filter((f)=>!f.isMutable).map((f)=>(0, api_1.toApiVal)(f.value, f.type));
    const mutFields = allFields.filter((f)=>f.isMutable).map((f)=>(0, api_1.toApiVal)(f.value, f.type));
    return {
        address: state.address,
        bytecode: state.bytecode,
        codeHash: state.codeHash,
        initialStateHash: state.initialStateHash,
        immFields,
        mutFields,
        asset: toApiAsset(state.asset)
    };
}
function toApiFields(fields, fieldsSig, structs) {
    return ralph.flattenFields(fields, fieldsSig.names, fieldsSig.types, fieldsSig.isMutable, structs).map((f)=>(0, api_1.toApiVal)(f.value, f.type));
}
function toApiArgs(args, funcSig, structs) {
    return ralph.flattenFields(args, funcSig.paramNames, funcSig.paramTypes, funcSig.paramIsMutable, structs).map((f)=>(0, api_1.toApiVal)(f.value, f.type));
}
function toApiInputAsset(inputAsset) {
    return {
        address: inputAsset.address,
        asset: toApiAsset(inputAsset.asset)
    };
}
function toApiInputAssets(inputAssets) {
    return typeof inputAssets !== 'undefined' ? inputAssets.map(toApiInputAsset) : undefined;
}
function fromApiOutput(output) {
    if (output.type === 'AssetOutput') {
        const asset = output;
        return {
            type: 'AssetOutput',
            address: asset.address,
            alphAmount: (0, api_1.fromApiNumber256)(asset.attoAlphAmount),
            tokens: (0, api_1.fromApiTokens)(asset.tokens),
            lockTime: asset.lockTime,
            message: asset.message
        };
    } else if (output.type === 'ContractOutput') {
        const asset = output;
        return {
            type: 'ContractOutput',
            address: asset.address,
            alphAmount: (0, api_1.fromApiNumber256)(asset.attoAlphAmount),
            tokens: (0, api_1.fromApiTokens)(asset.tokens)
        };
    } else {
        throw new Error(`Unknown output type: ${output}`);
    }
}
function randomTxId() {
    const bytes = new Uint8Array(32);
    crypto.getRandomValues(bytes);
    return (0, utils_1.binToHex)(bytes);
}
exports.randomTxId = randomTxId;
utils_1.assertType;
class ContractFactory {
    constructor(contract){
        this.contract = contract;
    }
    async deploy(signer, deployParams) {
        const signerParams = await this.contract.txParamsForDeployment(signer, {
            ...deployParams,
            initialFields: addStdIdToFields(this.contract, deployParams.initialFields)
        });
        const result = await signer.signAndSubmitDeployContractTx(signerParams);
        return {
            ...result,
            contractInstance: this.at(result.contractAddress)
        };
    }
    async deployTemplate(signer) {
        return this.deploy(signer, {
            initialFields: this.contract.getInitialFieldsWithDefaultValues()
        });
    }
    // This is used for testing contract functions
    stateForTest_(initFields, asset, address, maps) {
        const newAsset = {
            alphAmount: asset?.alphAmount ?? constants_1.MINIMAL_CONTRACT_DEPOSIT,
            tokens: asset?.tokens
        };
        const state = this.contract.toState(addStdIdToFields(this.contract, initFields), newAsset, address);
        return {
            ...state,
            bytecode: this.contract.bytecodeDebug,
            codeHash: this.contract.codeHash,
            maps: maps
        };
    }
}
exports.ContractFactory = ContractFactory;
class ExecutableScript {
    constructor(script, getContractByCodeHash){
        this.script = script;
        this.getContractByCodeHash = getContractByCodeHash;
    }
    async execute(signer, params) {
        const signerParams = await this.script.txParamsForExecution(signer, params);
        return await signer.signAndSubmitExecuteScriptTx(signerParams);
    }
    async call(params) {
        const mainFunc = this.script.functions.find((f)=>f.name === 'main');
        if (mainFunc === undefined) {
            throw new Error(`There is no main function in script ${this.script.name}`);
        }
        const bytecode = this.script.buildByteCodeToDeploy(params.initialFields);
        const txId = params.txId ?? randomTxId();
        const provider = (0, global_1.getCurrentNodeProvider)();
        const callResult = await provider.contracts.postContractsCallTxScript({
            ...params,
            group: params.groupIndex ?? 0,
            bytecode: bytecode,
            inputAssets: toApiInputAssets(params.inputAssets)
        });
        const returnTypes = mainFunc.returnTypes;
        const result = fromCallResult(callResult, txId, returnTypes, this.script.structs, this.getContractByCodeHash);
        return result;
    }
}
exports.ExecutableScript = ExecutableScript;
function specialContractAddress(eventIndex, groupIndex) {
    const bytes = new Uint8Array(32).fill(0);
    bytes[30] = eventIndex;
    bytes[31] = groupIndex;
    return (0, address_1.addressFromContractId)((0, utils_1.binToHex)(bytes));
}
exports.CreateContractEventAddresses = Array.from(Array(constants_1.TOTAL_NUMBER_OF_GROUPS).keys()).map((groupIndex)=>specialContractAddress(Contract.ContractCreatedEventIndex, groupIndex));
exports.DestroyContractEventAddresses = Array.from(Array(constants_1.TOTAL_NUMBER_OF_GROUPS).keys()).map((groupIndex)=>specialContractAddress(Contract.ContractDestroyedEventIndex, groupIndex));
function decodeSystemEvent(event, eventSig, eventIndex) {
    if (event.eventIndex !== eventIndex) {
        throw new Error(`Invalid event index: ${event.eventIndex}, expected: ${eventIndex}`);
    }
    return fromApiEventFields(event.fields, eventSig, true);
}
function toContractCreatedEventFields(fields) {
    const parentAddress = fields['parentAddress'];
    const stdInterfaceId = fields['stdInterfaceId'];
    return {
        address: fields['address'],
        parentAddress: parentAddress === '' ? undefined : parentAddress,
        stdInterfaceIdGuessed: stdInterfaceId === '' ? undefined : stdInterfaceId
    };
}
function decodeContractCreatedEvent(event) {
    const fields = decodeSystemEvent(event, Contract.ContractCreatedEvent, Contract.ContractCreatedEventIndex);
    return {
        blockHash: event.blockHash,
        txId: event.txId,
        eventIndex: event.eventIndex,
        name: Contract.ContractCreatedEvent.name,
        fields: toContractCreatedEventFields(fields)
    };
}
exports.decodeContractCreatedEvent = decodeContractCreatedEvent;
function decodeContractDestroyedEvent(event) {
    const fields = decodeSystemEvent(event, Contract.ContractDestroyedEvent, Contract.ContractDestroyedEventIndex);
    return {
        blockHash: event.blockHash,
        txId: event.txId,
        eventIndex: event.eventIndex,
        name: Contract.ContractDestroyedEvent.name,
        fields: {
            address: fields['address']
        }
    };
}
exports.decodeContractDestroyedEvent = decodeContractDestroyedEvent;
function subscribeEventsFromContract(options, address, eventIndex, decodeFunc, fromCount) {
    const messageCallback = (event)=>{
        if (event.eventIndex !== eventIndex) {
            return Promise.resolve();
        }
        return options.messageCallback(decodeFunc(event));
    };
    const errorCallback = (err, subscription)=>{
        return options.errorCallback(err, subscription);
    };
    const opt = {
        pollingInterval: options.pollingInterval,
        messageCallback: messageCallback,
        errorCallback: errorCallback,
        onEventCountChanged: options.onEventCountChanged
    };
    return (0, events_1.subscribeToEvents)(opt, address, fromCount);
}
exports.subscribeEventsFromContract = subscribeEventsFromContract;
function addStdIdToFields(contract, fields) {
    const stdInterfaceIdPrefix = '414c5048'; // the hex of 'ALPH'
    return contract.stdInterfaceId === undefined ? fields : {
        ...fields,
        __stdInterfaceId: stdInterfaceIdPrefix + contract.stdInterfaceId
    };
}
exports.addStdIdToFields = addStdIdToFields;
function calcWrapperContractId(parentContractId, mapIndex, key, keyType, group) {
    const prefix = ralph.encodeMapPrefix(mapIndex);
    const encodedKey = ralph.encodeMapKey(key, keyType);
    const path = (0, utils_1.binToHex)(prefix) + (0, utils_1.binToHex)(encodedKey);
    return (0, address_1.subContractId)(parentContractId, path, group);
}
function genCodeForType(type, structs) {
    const { immFields, mutFields } = ralph.calcFieldSize(type, true, structs);
    const loadImmFieldByIndex = {
        isPublic: true,
        usePreapprovedAssets: false,
        useContractAssets: false,
        usePayToContractOnly: false,
        argsLength: 1,
        localsLength: 1,
        returnLength: 1,
        instrs: [
            (0, codec_1.LoadLocal)(0),
            codec_1.LoadImmFieldByIndex
        ]
    };
    const loadMutFieldByIndex = {
        ...loadImmFieldByIndex,
        instrs: [
            (0, codec_1.LoadLocal)(0),
            codec_1.LoadMutFieldByIndex
        ]
    };
    const parentContractIdIndex = immFields;
    const storeMutFieldByIndex = {
        ...loadImmFieldByIndex,
        argsLength: 2,
        localsLength: 2,
        returnLength: 0,
        instrs: [
            codec_1.CallerContractId,
            (0, codec_1.LoadImmField)(parentContractIdIndex),
            codec_1.ByteVecEq,
            codec_1.Assert,
            (0, codec_1.LoadLocal)(0),
            (0, codec_1.LoadLocal)(1),
            codec_1.StoreMutFieldByIndex
        ]
    };
    const destroy = {
        isPublic: true,
        usePreapprovedAssets: false,
        useContractAssets: true,
        usePayToContractOnly: false,
        argsLength: 1,
        localsLength: 1,
        returnLength: 0,
        instrs: [
            codec_1.CallerContractId,
            (0, codec_1.LoadImmField)(parentContractIdIndex),
            codec_1.ByteVecEq,
            codec_1.Assert,
            (0, codec_1.LoadLocal)(0),
            codec_1.DestroySelf
        ]
    };
    const c = {
        fieldLength: immFields + mutFields + 1,
        methods: [
            loadImmFieldByIndex,
            loadMutFieldByIndex,
            storeMutFieldByIndex,
            destroy
        ]
    };
    const bytecode = codec_1.contract.contractCodec.encodeContract(c);
    const codeHash = blake.blake2b(bytecode, undefined, 32);
    return {
        bytecode: (0, utils_1.binToHex)(bytecode),
        codeHash: (0, utils_1.binToHex)(codeHash)
    };
}
function getContractFieldsSig(mapValueType) {
    return {
        names: [
            'value',
            'parentContractId'
        ],
        types: [
            mapValueType,
            'ByteVec'
        ],
        isMutable: [
            true,
            false
        ]
    };
}
function mapToExistingContracts(contract, parentContractId, group, map, mapIndex, type) {
    const [keyType, valueType] = ralph.parseMapType(type);
    const generatedContract = genCodeForType(valueType, contract.structs);
    return Array.from(map.entries()).map(([key, value])=>{
        const fields = {
            value,
            parentContractId
        };
        const contractId = calcWrapperContractId(parentContractId, mapIndex, key, keyType, group);
        return {
            ...generatedContract,
            address: (0, address_1.addressFromContractId)(contractId),
            contractId: contractId,
            fieldsSig: getContractFieldsSig(valueType),
            fields,
            asset: {
                alphAmount: constants_1.ONE_ALPH
            }
        };
    });
}
function mapsToExistingContracts(contract, parentContractId, group, initialMaps) {
    const mapsSig = contract.mapsSig;
    if (mapsSig === undefined) return [];
    const contractStates = [];
    Object.keys(initialMaps).forEach((name)=>{
        const index = mapsSig.names.findIndex((n)=>n === name);
        if (index === -1) throw new Error(`Map var ${name} does not exist in contract ${contract.name}`);
        const mapType = mapsSig.types[`${index}`];
        const states = mapToExistingContracts(contract, parentContractId, group, initialMaps[`${name}`], index, mapType);
        contractStates.push(...states);
    });
    return contractStates;
}
function hasMap(state) {
    return state.maps !== undefined;
}
function getTestExistingContracts(selfContract, selfContractId, group, params, getContractByCodeHash) {
    const selfMaps = params.initialMaps ?? {};
    const selfMapEntries = mapsToExistingContracts(selfContract, selfContractId, group, selfMaps);
    const existingContracts = params.existingContracts ?? [];
    const existingMapEntries = existingContracts.flatMap((contractState)=>{
        return hasMap(contractState) ? mapsToExistingContracts(getContractByCodeHash(contractState.codeHash), contractState.contractId, group, contractState.maps ?? {}) : [];
    });
    return existingContracts.concat(selfMapEntries, existingMapEntries);
}
function getNewCreatedContractExceptMaps(result, getContractByCodeHash) {
    const isMapContract = (codeHash)=>{
        try {
            getContractByCodeHash(codeHash);
            return false;
        } catch (error) {
            if (error instanceof Error && error.message.includes('Unknown code with code hash')) {
                // the contract does not exist, because it is a map item contract
                return true;
            }
            throw error;
        }
    };
    const states = [];
    result.events.forEach((event)=>{
        if (event.eventIndex === Contract.ContractCreatedEventIndex) {
            const contractAddress = event.fields[0].value;
            const contractState = result.contracts.find((c)=>c.address === contractAddress);
            if (contractState !== undefined && !isMapContract(contractState.codeHash)) {
                states.push(contractState);
            }
        }
    });
    return states;
}
function extractMapsFromApiResult(selfAddress, params, group, apiResult, getContractByCodeHash) {
    const selfMaps = params.initialMaps ?? {};
    const existingContracts = params.existingContracts ?? [];
    const updatedExistingContracts = apiResult.contracts.filter((c)=>c.address === selfAddress || existingContracts.find((s)=>s.address === c.address) !== undefined);
    const newCreateContracts = getNewCreatedContractExceptMaps(apiResult, getContractByCodeHash);
    const allMaps = [];
    updatedExistingContracts.concat(newCreateContracts).forEach((state)=>{
        const artifact = getContractByCodeHash(state.codeHash);
        if (artifact.mapsSig !== undefined) {
            const originMaps = state.address === selfAddress ? selfMaps : existingContracts.find((s)=>s.address === state.address)?.maps;
            const maps = existingContractsToMaps(artifact, state.address, group, apiResult, originMaps ?? {});
            allMaps.push({
                address: state.address,
                maps
            });
        }
    });
    return allMaps;
}
exports.extractMapsFromApiResult = extractMapsFromApiResult;
async function testMethod(factory, methodName, params, getContractByCodeHash) {
    const txId = params?.txId ?? randomTxId();
    const selfContract = factory.contract;
    const selfAddress = params.address ?? (0, address_1.addressFromContractId)((0, utils_1.binToHex)(crypto.getRandomValues(new Uint8Array(32))));
    const selfContractId = (0, utils_1.binToHex)((0, address_1.contractIdFromAddress)(selfAddress));
    const group = params.group ?? 0;
    const existingContracts = getTestExistingContracts(selfContract, selfContractId, group, params, getContractByCodeHash);
    const apiParams = selfContract.toApiTestContractParams(methodName, {
        ...params,
        address: selfAddress,
        txId: txId,
        initialFields: addStdIdToFields(selfContract, params.initialFields ?? {}),
        testArgs: params.testArgs === undefined ? {} : params.testArgs,
        existingContracts
    });
    const apiResult = await (0, global_1.getCurrentNodeProvider)().contracts.postContractsTestContract(apiParams);
    const allMaps = extractMapsFromApiResult(selfAddress, params, group, apiResult, getContractByCodeHash);
    const testResult = selfContract.fromApiTestContractResult(methodName, apiResult, txId, getContractByCodeHash);
    testResult.contracts.forEach((c)=>{
        const maps = allMaps.find((v)=>v.address === c.address)?.maps;
        if (maps !== undefined) c['maps'] = maps;
    });
    selfContract.printDebugMessages(methodName, testResult.debugMessages);
    return {
        ...testResult,
        maps: allMaps.find((v)=>v.address === selfAddress)?.maps
    };
}
exports.testMethod = testMethod;
function printDebugMessage(m) {
    console.log(`> Contract @ ${m.contractAddress} - ${m.message}`);
}
async function getDebugMessagesFromTx(txId, provider) {
    if ((0, utils_1.isHexString)(txId) && txId.length === 64) {
        const nodeProvider = provider ?? (0, global_1.getCurrentNodeProvider)();
        const events = await nodeProvider.events.getEventsTxIdTxid(txId);
        return events.events.filter((e)=>e.eventIndex === Contract.DebugEventIndex).map((e)=>{
            if (e.fields.length === 1 && e.fields[0].type === 'ByteVec') {
                return {
                    contractAddress: e.contractAddress,
                    message: (0, utils_1.hexToString)(e.fields[0].value)
                };
            } else {
                throw new Error(`Invalid debug log: ${JSON.stringify(e.fields)}`);
            }
        });
    } else {
        throw new Error(`Invalid tx id: ${txId}`);
    }
}
exports.getDebugMessagesFromTx = getDebugMessagesFromTx;
async function printDebugMessagesFromTx(txId, provider) {
    const messages = await getDebugMessagesFromTx(txId, provider);
    if (messages.length > 0) {
        messages.forEach((m)=>printDebugMessage(m));
    }
}
exports.printDebugMessagesFromTx = printDebugMessagesFromTx;
class RalphMap {
    constructor(parentContract, parentContractId, mapName){
        this.parentContract = parentContract;
        this.parentContractId = parentContractId;
        this.mapName = mapName;
        this.groupIndex = (0, address_1.groupOfAddress)((0, address_1.addressFromContractId)(parentContractId));
    }
    async get(key) {
        return getMapItem(this.parentContract, this.parentContractId, this.groupIndex, this.mapName, key);
    }
    async contains(key) {
        return this.get(key).then((v)=>v !== undefined);
    }
    toJSON() {
        return {
            parentContractId: this.parentContractId,
            mapName: this.mapName,
            groupIndex: this.groupIndex
        };
    }
}
exports.RalphMap = RalphMap;
async function getMapItem(parentContract, parentContractId, groupIndex, mapName, key) {
    const index = parentContract.mapsSig?.names.findIndex((name)=>name === mapName);
    const mapType = index === undefined ? undefined : parentContract.mapsSig?.types[`${index}`];
    if (mapType === undefined) {
        throw new Error(`Map ${mapName} does not exist in contract ${parentContract.name}`);
    }
    const [keyType, valueType] = ralph.parseMapType(mapType);
    const mapItemContractId = calcWrapperContractId(parentContractId, index, key, keyType, groupIndex);
    const mapItemAddress = (0, address_1.addressFromContractId)(mapItemContractId);
    try {
        const state = await (0, global_1.getCurrentNodeProvider)().contracts.getContractsAddressState(mapItemAddress);
        const fieldsSig = getContractFieldsSig(valueType);
        const fields = fromApiFields(state.immFields, state.mutFields, fieldsSig, parentContract.structs);
        return fields['value'];
    } catch (error) {
        if (error instanceof Error && error.message.includes('KeyNotFound')) {
            // the map item contract does not exist
            return undefined;
        }
        throw new error_1.TraceableError(`Failed to get value from map ${mapName}, key: ${key}, parent contract id: ${parentContractId}`, error);
    }
}
exports.getMapItem = getMapItem;
function buildMapInfo(contract, fields) {
    const mapsSig = contract.mapsSig;
    if (mapsSig === undefined) return [];
    return mapsSig.names.map((name, index)=>{
        const mapType = mapsSig.types[`${index}`];
        const value = fields[`${name}`] ?? new Map();
        const [keyType, valueType] = ralph.parseMapType(mapType);
        return {
            name,
            value,
            keyType,
            valueType,
            index
        };
    });
}
function extractFromEventLog(contract, result, allMaps, address, group) {
    const parentContractId = (0, utils_1.binToHex)((0, address_1.contractIdFromAddress)(address));
    const newInserted = [];
    result.debugMessages.forEach((message)=>{
        if (message.contractAddress !== address) return;
        const decoded = ralph.tryDecodeMapDebugLog(message.message);
        if (decoded === undefined) return;
        const map = allMaps[`${decoded.mapIndex}`];
        const decodedKey = ralph.decodePrimitive(decoded.encodedKey, map.keyType);
        const contractId = (0, address_1.subContractId)(parentContractId, decoded.path, group);
        if (!decoded.isInsert) {
            map.value.delete(decodedKey);
            return;
        }
        const state = result.contracts.find((s)=>s.address === (0, address_1.addressFromContractId)(contractId));
        if (state === undefined) {
            throw new Error(`Cannot find contract state for map value, map field: ${map.name}, value type: ${map.valueType}`);
        }
        newInserted.push(state.address);
        const fieldsSig = getContractFieldsSig(map.valueType);
        const fields = fromApiFields(state.immFields, state.mutFields, fieldsSig, contract.structs);
        map.value.set(decodedKey, fields['value']);
    });
    return newInserted;
}
function updateMaps(contract, result, allMaps, address, group) {
    const parentContractId = (0, utils_1.binToHex)((0, address_1.contractIdFromAddress)(address));
    const updated = [];
    allMaps.forEach((map)=>{
        Array.from(map.value.keys()).forEach((key)=>{
            const contractId = calcWrapperContractId(parentContractId, map.index, key, map.keyType, group);
            const updatedState = result.contracts.find((s)=>s.address === (0, address_1.addressFromContractId)(contractId));
            if (updatedState === undefined) return;
            updated.push(updatedState.address);
            const fieldsSig = getContractFieldsSig(map.valueType);
            const fields = fromApiFields(updatedState.immFields, updatedState.mutFields, fieldsSig, contract.structs);
            map.value.set(key, fields['value']);
        });
    });
    return updated;
}
function existingContractsToMaps(contract, address, group, result, maps) {
    const allMaps = buildMapInfo(contract, maps);
    const updated = updateMaps(contract, result, allMaps, address, group);
    const newInserted = extractFromEventLog(contract, result, allMaps, address, group);
    const mapEntries = updated.concat(newInserted);
    const remainContracts = result.contracts.filter((c)=>mapEntries.find((addr)=>c.address === addr) === undefined);
    result.contracts = remainContracts;
    return allMaps.reduce((acc, map)=>{
        acc[`${map.name}`] = map.value;
        return acc;
    }, {});
}
class ContractInstance {
    constructor(address){
        this.address = address;
        this.contractId = (0, utils_1.binToHex)((0, address_1.contractIdFromAddress)(address));
        this.groupIndex = (0, address_1.groupOfAddress)(address);
    }
}
exports.ContractInstance = ContractInstance;
async function fetchContractState(contract, instance) {
    const contractState = await (0, global_1.getCurrentNodeProvider)().contracts.getContractsAddressState(instance.address);
    const state = contract.contract.fromApiContractState(contractState);
    return {
        ...state,
        fields: state.fields
    };
}
exports.fetchContractState = fetchContractState;
function checkGroupIndex(groupIndex) {
    if (groupIndex < 0 || groupIndex >= constants_1.TOTAL_NUMBER_OF_GROUPS) {
        throw new Error(`Invalid group index ${groupIndex}, expected a value within the range [0, ${constants_1.TOTAL_NUMBER_OF_GROUPS})`);
    }
}
function subscribeContractCreatedEvent(options, fromGroup, fromCount) {
    checkGroupIndex(fromGroup);
    const contractAddress = exports.CreateContractEventAddresses[`${fromGroup}`];
    return subscribeEventsFromContract(options, contractAddress, Contract.ContractCreatedEventIndex, (event)=>{
        return {
            ...decodeContractCreatedEvent(event),
            contractAddress: contractAddress
        };
    }, fromCount);
}
exports.subscribeContractCreatedEvent = subscribeContractCreatedEvent;
function subscribeContractDestroyedEvent(options, fromGroup, fromCount) {
    checkGroupIndex(fromGroup);
    const contractAddress = exports.DestroyContractEventAddresses[`${fromGroup}`];
    return subscribeEventsFromContract(options, contractAddress, Contract.ContractDestroyedEventIndex, (event)=>{
        return {
            ...decodeContractDestroyedEvent(event),
            contractAddress: contractAddress
        };
    }, fromCount);
}
exports.subscribeContractDestroyedEvent = subscribeContractDestroyedEvent;
function decodeEvent(contract, instance, event, targetEventIndex) {
    if (event.eventIndex !== targetEventIndex && !(targetEventIndex >= 0 && targetEventIndex < contract.eventsSig.length)) {
        throw new Error('Invalid event index: ' + event.eventIndex + ', expected: ' + targetEventIndex);
    }
    const eventSig = contract.eventsSig[`${targetEventIndex}`];
    const fields = fromApiEventFields(event.fields, eventSig);
    return {
        contractAddress: instance.address,
        blockHash: event.blockHash,
        txId: event.txId,
        eventIndex: event.eventIndex,
        name: eventSig.name,
        fields: fields
    };
}
exports.decodeEvent = decodeEvent;
function subscribeContractEvent(contract, instance, options, eventName, fromCount) {
    const eventIndex = contract.eventsSig.findIndex((sig)=>sig.name === eventName);
    return subscribeEventsFromContract(options, instance.address, eventIndex, (event)=>decodeEvent(contract, instance, event, eventIndex), fromCount);
}
exports.subscribeContractEvent = subscribeContractEvent;
function subscribeContractEvents(contract, instance, options, fromCount) {
    const messageCallback = (event)=>{
        return options.messageCallback({
            ...decodeEvent(contract, instance, event, event.eventIndex),
            contractAddress: instance.address
        });
    };
    const errorCallback = (err, subscription)=>{
        return options.errorCallback(err, subscription);
    };
    const opt = {
        pollingInterval: options.pollingInterval,
        messageCallback: messageCallback,
        errorCallback: errorCallback,
        onEventCountChanged: options.onEventCountChanged
    };
    return (0, events_1.subscribeToEvents)(opt, instance.address, fromCount);
}
exports.subscribeContractEvents = subscribeContractEvents;
async function callMethod(contract, instance, methodName, params, getContractByCodeHash) {
    const methodIndex = contract.contract.getMethodIndex(methodName);
    const txId = params?.txId ?? randomTxId();
    const callParams = contract.contract.toApiCallContract({
        ...params,
        txId: txId,
        args: params.args === undefined ? {} : params.args
    }, instance.groupIndex, instance.address, methodIndex);
    const result = await (0, global_1.getCurrentNodeProvider)().contracts.postContractsCallContract(callParams);
    const callResult = contract.contract.fromApiCallContractResult(result, txId, methodIndex, getContractByCodeHash);
    contract.contract.printDebugMessages(methodName, callResult.debugMessages);
    return callResult;
}
exports.callMethod = callMethod;
async function signExecuteMethod(contract, instance, methodName, params) {
    const methodIndex = contract.contract.getMethodIndex(methodName);
    const functionSig = contract.contract.functions[methodIndex];
    const isDevnet = await contract.contract.isDevnet(params.signer);
    const methodUsePreapprovedAssets = contract.contract.isMethodUsePreapprovedAssets(isDevnet, methodIndex);
    const bytecodeTemplate = getBytecodeTemplate(methodIndex, methodUsePreapprovedAssets, functionSig, contract.contract.structs, params.attoAlphAmount, params.tokens);
    const fieldsSig = toFieldsSig(contract.contract.name, functionSig);
    const bytecode = ralph.buildScriptByteCode(bytecodeTemplate, {
        __contract__: instance.contractId,
        ...params.args
    }, fieldsSig, contract.contract.structs);
    const signer = params.signer;
    const selectedAccount = await signer.getSelectedAccount();
    const signerParams = {
        signerAddress: selectedAccount.address,
        signerKeyType: selectedAccount.keyType,
        bytecode: bytecode,
        attoAlphAmount: params.attoAlphAmount,
        tokens: params.tokens,
        gasAmount: params.gasAmount,
        gasPrice: params.gasPrice
    };
    const result = await signer.signAndSubmitExecuteScriptTx(signerParams);
    if ((0, debug_1.isContractDebugMessageEnabled)() && isDevnet) {
        await printDebugMessagesFromTx(result.txId, signer.nodeProvider);
    }
    return result;
}
exports.signExecuteMethod = signExecuteMethod;
function getBytecodeTemplate(methodIndex, methodUsePreapprovedAssets, functionSig, structs, attoAlphAmount, tokens) {
    // For the default TxScript main function
    const numberOfMethods = '01';
    const isPublic = '01';
    const scriptUseApprovedAssets = attoAlphAmount !== undefined || tokens !== undefined;
    const modifier = scriptUseApprovedAssets ? '03' : '00';
    const argsLength = '00';
    const returnsLength = '00';
    if (methodUsePreapprovedAssets && !scriptUseApprovedAssets) {
        throw new Error('The contract call requires preapproved assets but none are provided');
    }
    const [templateVarStoreLocalInstrs, templateVarsLength] = getTemplateVarStoreLocalInstrs(functionSig, structs);
    const approveAlphInstrs = getApproveAlphInstrs(methodUsePreapprovedAssets ? attoAlphAmount : undefined);
    const approveTokensInstrs = getApproveTokensInstrs(methodUsePreapprovedAssets ? tokens : undefined);
    const callerInstrs = getCallAddressInstrs(approveAlphInstrs.length / 2 + approveTokensInstrs.length / 3);
    // First template var is the contract
    const functionArgsNum = encodeU256Const(BigInt(templateVarsLength - 1));
    const localsLength = encodeI32(templateVarStoreLocalInstrs.length / 2);
    const templateVarLoadLocalInstrs = getTemplateVarLoadLocalInstrs(functionSig, structs);
    const functionReturnTypesLength = functionSig.returnTypes.reduce((acc, returnType)=>acc + ralph.typeLength(returnType, structs), 0);
    const functionReturnPopInstrs = encodeInstr(codec_1.Pop).repeat(functionReturnTypesLength);
    const functionReturnNum = encodeU256Const(BigInt(functionReturnTypesLength));
    const contractTemplateVar = '{0}'; // always the 1st argument
    const externalCallInstr = encodeInstr((0, codec_1.CallExternal)(methodIndex));
    const numberOfInstrs = encodeI32(callerInstrs.length + approveAlphInstrs.length + approveTokensInstrs.length + templateVarStoreLocalInstrs.length + templateVarLoadLocalInstrs.length + functionReturnTypesLength + 4 // functionArgsNum, functionReturnNum, contractTemplate, externalCallInstr
    );
    return numberOfMethods + isPublic + modifier + argsLength + localsLength + returnsLength + numberOfInstrs + callerInstrs.join('') + approveAlphInstrs.join('') + approveTokensInstrs.join('') + templateVarStoreLocalInstrs.join('') + templateVarLoadLocalInstrs.join('') + functionArgsNum + functionReturnNum + contractTemplateVar + externalCallInstr + functionReturnPopInstrs;
}
function getApproveAlphInstrs(attoAlphAmount) {
    const approveAlphInstrs = [];
    if (attoAlphAmount) {
        const approvedAttoAlphAmount = encodeU256Const(BigInt(attoAlphAmount));
        approveAlphInstrs.push(approvedAttoAlphAmount);
        approveAlphInstrs.push(encodeInstr(codec_1.ApproveAlph));
    }
    return approveAlphInstrs;
}
function getApproveTokensInstrs(tokens) {
    const approveTokensInstrs = [];
    if (tokens) {
        tokens.forEach((token)=>{
            const tokenIdBin = (0, utils_1.hexToBinUnsafe)(token.id);
            approveTokensInstrs.push(encodeInstr((0, codec_1.BytesConst)(tokenIdBin)));
            approveTokensInstrs.push(encodeU256Const(BigInt(token.amount)));
            approveTokensInstrs.push(encodeInstr(codec_1.ApproveToken));
        });
    }
    return approveTokensInstrs;
}
function getCallAddressInstrs(approveAssetsNum) {
    const callerInstrs = [];
    if (approveAssetsNum > 0) {
        callerInstrs.push(encodeInstr(codec_1.CallerAddress));
        const dup = encodeInstr(codec_1.Dup);
        if (approveAssetsNum > 1) {
            callerInstrs.push(...new Array(approveAssetsNum - 1).fill(dup));
        }
    }
    return callerInstrs;
}
function getTemplateVarStoreLocalInstrs(functionSig, structs) {
    let templateVarIndex = 1; // Start from 1 since first one is always the contract id
    let localsLength = 0;
    const templateVarStoreInstrs = [];
    functionSig.paramTypes.forEach((paramType)=>{
        const fieldsLength = ralph.typeLength(paramType, structs);
        if (fieldsLength > 1) {
            for(let i = 0; i < fieldsLength; i++){
                templateVarStoreInstrs.push(`{${templateVarIndex + i}}`);
            }
            for(let i = 0; i < fieldsLength; i++){
                templateVarStoreInstrs.push(encodeStoreLocalInstr(localsLength + (fieldsLength - i - 1)));
            }
            localsLength = localsLength + fieldsLength;
        }
        templateVarIndex = templateVarIndex + fieldsLength;
    });
    return [
        templateVarStoreInstrs,
        templateVarIndex
    ];
}
function getTemplateVarLoadLocalInstrs(functionSig, structs) {
    let templateVarIndex = 1;
    let loadIndex = 0;
    const templateVarLoadInstrs = [];
    functionSig.paramTypes.forEach((paramType)=>{
        const fieldsLength = ralph.typeLength(paramType, structs);
        if (fieldsLength === 1) {
            templateVarLoadInstrs.push(`{${templateVarIndex}}`);
        }
        if (fieldsLength > 1) {
            for(let i = 0; i < fieldsLength; i++){
                templateVarLoadInstrs.push(encodeLoadLocalInstr(loadIndex + i));
            }
            loadIndex = loadIndex + fieldsLength;
        }
        templateVarIndex = templateVarIndex + fieldsLength;
    });
    return templateVarLoadInstrs;
}
function encodeStoreLocalInstr(index) {
    if (index < 0 || index > 0xff) {
        throw new Error(`StoreLocal index ${index} must be between 0 and 255 inclusive`);
    }
    return encodeInstr((0, codec_1.StoreLocal)(index));
}
function encodeLoadLocalInstr(index) {
    if (index < 0 || index > 0xff) {
        throw new Error(`LoadLocal index ${index} must be between 0 and 255 inclusive`);
    }
    return encodeInstr((0, codec_1.LoadLocal)(index));
}
function encodeI32(value) {
    return (0, utils_1.binToHex)(codec_1.i32Codec.encode(value));
}
function encodeU256Const(value) {
    if (value < 0) {
        throw new Error(`value ${value} must be non-negative`);
    }
    if (value < 6) {
        return (BigInt(0x0c) + value).toString(16).padStart(2, '0');
    } else {
        return encodeInstr((0, codec_1.U256Const)(value));
    }
}
function encodeInstr(instr) {
    return (0, utils_1.binToHex)(codec_1.instrCodec.encode(instr));
}
function toFieldsSig(contractName, functionSig) {
    return {
        names: [
            '__contract__'
        ].concat(functionSig.paramNames),
        types: [
            contractName
        ].concat(functionSig.paramTypes),
        isMutable: [
            false
        ].concat(functionSig.paramIsMutable)
    };
}
async function multicallMethods(contract, instance, _callss, getContractByCodeHash) {
    const callss = Array.isArray(_callss) ? _callss : [
        _callss
    ];
    const callEntries = callss.map((calls)=>Object.entries(calls));
    const callsParams = callEntries.map((entries)=>{
        return entries.map((entry)=>{
            const [methodName, params] = entry;
            const methodIndex = contract.contract.getMethodIndex(methodName);
            const txId = params?.txId ?? randomTxId();
            return contract.contract.toApiCallContract({
                ...params,
                txId: txId,
                args: params.args === undefined ? {} : params.args
            }, instance.groupIndex, instance.address, methodIndex);
        });
    });
    const result = await (0, global_1.getCurrentNodeProvider)().contracts.postContractsMulticallContract({
        calls: callsParams.flat()
    });
    let callResultIndex = 0;
    const results = callsParams.map((calls, index0)=>{
        const callsResult = {};
        const entries = callEntries[`${index0}`];
        calls.forEach((call, index1)=>{
            const methodIndex = call.methodIndex;
            const callResult = result.results[`${callResultIndex}`];
            const methodName = entries[`${index1}`][`0`];
            callsResult[`${methodName}`] = contract.contract.fromApiCallContractResult(callResult, call.txId, methodIndex, getContractByCodeHash);
            callResultIndex += 1;
        });
        return callsResult;
    });
    return Array.isArray(_callss) ? results : results[0];
}
exports.multicallMethods = multicallMethods;
async function getContractEventsCurrentCount(contractAddress) {
    return (0, global_1.getCurrentNodeProvider)().events.getEventsContractContractaddressCurrentCount(contractAddress).catch((error)=>{
        if (error instanceof Error && error.message.includes(`${contractAddress} not found`)) {
            return 0;
        }
        throw new error_1.TraceableError(`Failed to get the event count for the contract ${contractAddress}`, error);
    });
}
exports.getContractEventsCurrentCount = getContractEventsCurrentCount;
// This function only works in the simple case where a single non-subcontract is created in the tx
const getContractIdFromUnsignedTx = async (nodeProvider, unsignedTx)=>{
    const result = await nodeProvider.transactions.postTransactionsDecodeUnsignedTx({
        unsignedTx
    });
    const outputIndex = result.unsignedTx.fixedOutputs.length;
    const hex = result.unsignedTx.txId + outputIndex.toString(16).padStart(8, '0');
    const hashHex = (0, utils_1.binToHex)(blake.blake2b((0, utils_1.hexToBinUnsafe)(hex), undefined, 32));
    return hashHex.slice(0, 62) + result.fromGroup.toString(16).padStart(2, '0');
};
exports.getContractIdFromUnsignedTx = getContractIdFromUnsignedTx;
// This function only works in the simple case where a single non-subcontract is created in the tx
exports.getTokenIdFromUnsignedTx = exports.getContractIdFromUnsignedTx;
async function getContractCodeByCodeHash(nodeProvider, codeHash) {
    if ((0, utils_1.isHexString)(codeHash) && codeHash.length === 64) {
        try {
            return await nodeProvider.contracts.getContractsCodehashCode(codeHash);
        } catch (error) {
            if (error instanceof Error && error.message.includes('not found')) {
                return undefined;
            }
            throw new error_1.TraceableError(`Failed to get contract by code hash ${codeHash}`, error);
        }
    }
    throw new Error(`Invalid code hash: ${codeHash}`);
}
exports.getContractCodeByCodeHash = getContractCodeByCodeHash;
}}),
"[project]/node_modules/@alephium/web3/dist/src/contract/script-simulator.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.ScriptSimulator = void 0;
const address_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/address/index.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/index.js [app-ssr] (ecmascript)");
const lockup_script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/lockup-script-codec.js [app-ssr] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/constants.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
class ScriptSimulator {
    // This function without errors is recommended for now as the simulator does not support all instructions
    static extractContractCalls(unsignedTx) {
        try {
            return this.extractContractCallsWithErrors(unsignedTx);
        } catch (e) {
            console.debug('Error extracting contract calls from script', e);
            return [];
        }
    }
    static extractContractCallsWithErrors(unsignedTx) {
        const unsignedTxBytes = (0, utils_1.hexToBinUnsafe)(unsignedTx);
        const decodedUnsignedTx = codec_1.unsignedTxCodec.decode(unsignedTxBytes);
        const scriptOpt = decodedUnsignedTx.statefulScript;
        switch(scriptOpt.kind){
            case 'Some':
                {
                    return this.extractContractCallsFromScript(scriptOpt.value);
                }
            case 'None':
                {
                    return [];
                }
        }
    }
    static extractContractCallsFromScript(script) {
        const methods = script.methods;
        if (methods.length === 0) {
            return [];
        }
        const mainMethod = methods[0];
        return this.extractContractCallsFromMainMethod(mainMethod);
    }
    static extractContractCallsFromMainMethod(mainMethod) {
        const operandStack = new Stack();
        const localVariables = new LocalVariables();
        const contractCalls = [];
        const callerAddress = {
            kind: 'Address',
            value: {
                kind: 'P2PKH',
                value: random32Bytes()
            }
        };
        const approved = new ApprovedAccumulator();
        for (const instr of mainMethod.instrs){
            switch(instr.name){
                case 'ConstTrue':
                    operandStack.push({
                        kind: 'Bool',
                        value: true
                    });
                    break;
                case 'ConstFalse':
                    operandStack.push({
                        kind: 'Bool',
                        value: false
                    });
                    break;
                case 'I256Const0':
                    operandStack.push({
                        kind: 'I256',
                        value: 0n
                    });
                    break;
                case 'I256Const1':
                    operandStack.push({
                        kind: 'I256',
                        value: 1n
                    });
                    break;
                case 'I256Const2':
                    operandStack.push({
                        kind: 'I256',
                        value: 2n
                    });
                    break;
                case 'I256Const3':
                    operandStack.push({
                        kind: 'I256',
                        value: 3n
                    });
                    break;
                case 'I256Const4':
                    operandStack.push({
                        kind: 'I256',
                        value: 4n
                    });
                    break;
                case 'I256Const5':
                    operandStack.push({
                        kind: 'I256',
                        value: 5n
                    });
                    break;
                case 'I256ConstN1':
                    operandStack.push({
                        kind: 'I256',
                        value: -1n
                    });
                    break;
                case 'I256Const':
                    operandStack.push({
                        kind: 'I256',
                        value: instr.value
                    });
                    break;
                case 'U256Const0':
                    operandStack.push({
                        kind: 'U256',
                        value: 0n
                    });
                    break;
                case 'U256Const1':
                    operandStack.push({
                        kind: 'U256',
                        value: 1n
                    });
                    break;
                case 'U256Const2':
                    operandStack.push({
                        kind: 'U256',
                        value: 2n
                    });
                    break;
                case 'U256Const3':
                    operandStack.push({
                        kind: 'U256',
                        value: 3n
                    });
                    break;
                case 'U256Const4':
                    operandStack.push({
                        kind: 'U256',
                        value: 4n
                    });
                    break;
                case 'U256Const5':
                    operandStack.push({
                        kind: 'U256',
                        value: 5n
                    });
                    break;
                case 'U256Const':
                    operandStack.push({
                        kind: 'U256',
                        value: instr.value
                    });
                    break;
                case 'BytesConst':
                    operandStack.push({
                        kind: 'ByteVec',
                        value: instr.value
                    });
                    break;
                case 'AddressConst':
                    operandStack.push({
                        kind: 'Address',
                        value: instr.value
                    });
                    break;
                case 'LoadLocal':
                    operandStack.push(localVariables.get(instr.index));
                    break;
                case 'StoreLocal':
                    localVariables.set(instr.index, operandStack.pop());
                    break;
                case 'Pop':
                    operandStack.pop();
                    break;
                case 'Dup':
                    const val = operandStack.pop();
                    operandStack.push(val);
                    operandStack.push(val);
                    break;
                case 'Swap':
                    const val1 = operandStack.pop();
                    const val2 = operandStack.pop();
                    operandStack.push(val1);
                    operandStack.push(val2);
                    break;
                case 'BoolNot':
                    const bool = operandStack.popBool();
                    const result = unaryOp(bool, (x)=>!x);
                    operandStack.push(result);
                case 'BoolAnd':
                    {
                        const bool1 = operandStack.popBool();
                        const bool2 = operandStack.popBool();
                        binaryOp(bool1, bool2, (x, y)=>x && y, operandStack.push);
                        break;
                    }
                case 'BoolOr':
                    {
                        const bool1 = operandStack.popBool();
                        const bool2 = operandStack.popBool();
                        binaryOp(bool1, bool2, (x, y)=>x || y, operandStack.push);
                        break;
                    }
                case 'BoolEq':
                    {
                        const bool1 = operandStack.popBool();
                        const bool2 = operandStack.popBool();
                        binaryOp(bool1, bool2, (x, y)=>x === y, operandStack.push);
                        break;
                    }
                case 'BoolNeq':
                    {
                        const bool1 = operandStack.popBool();
                        const bool2 = operandStack.popBool();
                        binaryOp(bool1, bool2, (x, y)=>x !== y, operandStack.push);
                        break;
                    }
                case 'BoolToByteVec':
                    {
                        const bool = operandStack.popBool();
                        if (bool.kind === 'Symbol-Bool') {
                            operandStack.push(bool);
                        } else {
                            operandStack.push({
                                kind: 'ByteVec',
                                value: codec_1.boolCodec.encode(bool.value)
                            });
                        }
                        break;
                    }
                case 'I256Add':
                    {
                        // unsafe
                        const i256_2 = operandStack.popI256();
                        const i256_1 = operandStack.popI256();
                        binaryOp(i256_1, i256_2, (x, y)=>x + y, operandStack.push);
                        break;
                    }
                case 'I256Sub':
                    {
                        // unsafe
                        const i256_2 = operandStack.popI256();
                        const i256_1 = operandStack.popI256();
                        binaryOp(i256_1, i256_2, (x, y)=>x - y, operandStack.push);
                        break;
                    }
                case 'I256Mul':
                    {
                        // unsafe
                        const i256_2 = operandStack.popI256();
                        const i256_1 = operandStack.popI256();
                        binaryOp(i256_1, i256_2, (x, y)=>x * y, operandStack.push);
                        break;
                    }
                case 'I256Div':
                    {
                        // unsafe
                        const i256_2 = operandStack.popI256();
                        const i256_1 = operandStack.popI256();
                        binaryOp(i256_1, i256_2, (x, y)=>x / y, operandStack.push);
                        break;
                    }
                case 'I256Eq':
                    {
                        // unsafe
                        const i256_2 = operandStack.popI256();
                        const i256_1 = operandStack.popI256();
                        comparisonOp(i256_1, i256_2, (x, y)=>x === y, operandStack.push);
                        break;
                    }
                case 'I256Neq':
                    {
                        // unsafe
                        const i256_2 = operandStack.popI256();
                        const i256_1 = operandStack.popI256();
                        comparisonOp(i256_1, i256_2, (x, y)=>x !== y, operandStack.push);
                        break;
                    }
                case 'I256Lt':
                    {
                        // unsafe
                        const i256_2 = operandStack.popI256();
                        const i256_1 = operandStack.popI256();
                        comparisonOp(i256_1, i256_2, (x, y)=>x < y, operandStack.push);
                        break;
                    }
                case 'I256Le':
                    {
                        // unsafe
                        const i256_2 = operandStack.popI256();
                        const i256_1 = operandStack.popI256();
                        comparisonOp(i256_1, i256_2, (x, y)=>x <= y, operandStack.push);
                        break;
                    }
                case 'I256Gt':
                    {
                        // unsafe
                        const i256_2 = operandStack.popI256();
                        const i256_1 = operandStack.popI256();
                        comparisonOp(i256_1, i256_2, (x, y)=>x > y, operandStack.push);
                        break;
                    }
                case 'I256Ge':
                    {
                        // unsafe
                        const i256_2 = operandStack.popI256();
                        const i256_1 = operandStack.popI256();
                        comparisonOp(i256_1, i256_2, (x, y)=>x >= y, operandStack.push);
                        break;
                    }
                case 'U256Add':
                    {
                        // unsafe
                        const u256_2 = operandStack.popU256();
                        const u256_1 = operandStack.popU256();
                        binaryOp(u256_1, u256_2, (x, y)=>x + y, operandStack.push);
                        break;
                    }
                case 'U256Sub':
                    {
                        // unsafe
                        const u256_2 = operandStack.popU256();
                        const u256_1 = operandStack.popU256();
                        binaryOp(u256_1, u256_2, (x, y)=>x - y, operandStack.push);
                        break;
                    }
                case 'U256Mul':
                    {
                        // unsafe
                        const u256_2 = operandStack.popU256();
                        const u256_1 = operandStack.popU256();
                        binaryOp(u256_1, u256_2, (x, y)=>x * y, operandStack.push);
                        break;
                    }
                case 'U256Div':
                    {
                        // unsafe
                        const u256_2 = operandStack.popU256();
                        const u256_1 = operandStack.popU256();
                        binaryOp(u256_1, u256_2, (x, y)=>x / y, operandStack.push);
                        break;
                    }
                case 'U256Eq':
                    {
                        // unsafe
                        const u256_2 = operandStack.popU256();
                        const u256_1 = operandStack.popU256();
                        comparisonOp(u256_1, u256_2, (x, y)=>x === y, operandStack.push);
                        break;
                    }
                case 'U256Neq':
                    {
                        // unsafe
                        const u256_2 = operandStack.popU256();
                        const u256_1 = operandStack.popU256();
                        comparisonOp(u256_1, u256_2, (x, y)=>x !== y, operandStack.push);
                        break;
                    }
                case 'U256Lt':
                    {
                        // unsafe
                        const u256_2 = operandStack.popU256();
                        const u256_1 = operandStack.popU256();
                        comparisonOp(u256_1, u256_2, (x, y)=>x < y, operandStack.push);
                        break;
                    }
                case 'U256Le':
                    {
                        // unsafe
                        const u256_2 = operandStack.popU256();
                        const u256_1 = operandStack.popU256();
                        comparisonOp(u256_1, u256_2, (x, y)=>x <= y, operandStack.push);
                        break;
                    }
                case 'U256Gt':
                    {
                        // unsafe
                        const u256_2 = operandStack.popU256();
                        const u256_1 = operandStack.popU256();
                        comparisonOp(u256_1, u256_2, (x, y)=>x > y, operandStack.push);
                        break;
                    }
                case 'U256Ge':
                    {
                        // unsafe
                        const u256_2 = operandStack.popU256();
                        const u256_1 = operandStack.popU256();
                        comparisonOp(u256_1, u256_2, (x, y)=>x >= y, operandStack.push);
                        break;
                    }
                case 'ByteVecEq':
                    {
                        const byteVec1 = operandStack.popByteVec();
                        const byteVec2 = operandStack.popByteVec();
                        comparisonOp(byteVec1, byteVec2, (x, y)=>arrayEquals(x, y), operandStack.push);
                        break;
                    }
                case 'ByteVecNeq':
                    {
                        const byteVec1 = operandStack.popByteVec();
                        const byteVec2 = operandStack.popByteVec();
                        comparisonOp(byteVec1, byteVec2, (x, y)=>!arrayEquals(x, y), operandStack.push);
                        break;
                    }
                case 'ByteVecSize':
                    {
                        const byteVec = operandStack.popByteVec();
                        if (byteVec.kind === 'Symbol-ByteVec') {
                            operandStack.push({
                                kind: 'Symbol-U256',
                                value: undefined
                            });
                        } else {
                            operandStack.push({
                                kind: 'U256',
                                value: BigInt(byteVec.value.length)
                            });
                        }
                        break;
                    }
                case 'ByteVecConcat':
                    {
                        const byteVec2 = operandStack.popByteVec();
                        const byteVec1 = operandStack.popByteVec();
                        binaryOp(byteVec1, byteVec2, (x, y)=>new Uint8Array([
                                ...x,
                                ...y
                            ]), operandStack.push);
                        break;
                    }
                case 'ByteVecSlice':
                    {
                        const end = operandStack.popU256();
                        const start = operandStack.popU256();
                        const byteVec = operandStack.popByteVec();
                        if (byteVec.kind === 'Symbol-ByteVec' || start.kind === 'Symbol-U256' || end.kind === 'Symbol-U256') {
                            operandStack.push({
                                kind: 'Symbol-ByteVec',
                                value: undefined
                            });
                        } else {
                            operandStack.push({
                                kind: 'ByteVec',
                                value: byteVec.value.slice(Number(start.value), Number(end.value))
                            });
                        }
                        break;
                    }
                case 'AddressEq':
                    {
                        const address1 = operandStack.popAddress();
                        const address2 = operandStack.popAddress();
                        comparisonOp(address1, address2, (x, y)=>arrayEquals(lockup_script_codec_1.lockupScriptCodec.encode(x), lockup_script_codec_1.lockupScriptCodec.encode(y)), operandStack.push);
                        break;
                    }
                case 'AddressNeq':
                    {
                        const address1 = operandStack.popAddress();
                        const address2 = operandStack.popAddress();
                        comparisonOp(address1, address2, (x, y)=>!arrayEquals(lockup_script_codec_1.lockupScriptCodec.encode(x), lockup_script_codec_1.lockupScriptCodec.encode(y)), operandStack.push);
                        break;
                    }
                case 'AddressToByteVec':
                    {
                        const address = operandStack.popAddress();
                        if (address.kind === 'Symbol-Address') {
                            operandStack.push({
                                kind: 'Symbol-ByteVec',
                                value: undefined
                            });
                        } else {
                            operandStack.push({
                                kind: 'ByteVec',
                                value: lockup_script_codec_1.lockupScriptCodec.encode(address.value)
                            });
                        }
                        break;
                    }
                case 'Assert':
                    {
                        const bool = operandStack.popBool();
                        if (!bool) {
                            throw new Error('Assertion failed');
                        }
                        break;
                    }
                case 'Blake2b':
                case 'Sha256':
                case 'Sha3':
                case 'Keccak256':
                    {
                        dummyImplementation(instr.name);
                        operandStack.popByteVec();
                        operandStack.push({
                            kind: 'ByteVec',
                            value: new Uint8Array(32)
                        });
                        break;
                    }
                case 'ByteVecToAddress':
                    {
                        const byteVec = operandStack.popByteVec();
                        if (byteVec.kind === 'Symbol-ByteVec') {
                            operandStack.push({
                                kind: 'Symbol-Address',
                                value: undefined
                            });
                        } else {
                            operandStack.push({
                                kind: 'Address',
                                value: lockup_script_codec_1.lockupScriptCodec.decode(byteVec.value)
                            });
                        }
                        break;
                    }
                case 'Zeros':
                    {
                        const size = operandStack.popU256();
                        if (size.kind === 'Symbol-U256') {
                            operandStack.push({
                                kind: 'Symbol-ByteVec',
                                value: undefined
                            });
                        } else {
                            if (size.value > 4096) {
                                throw new Error('Zeros size is too large');
                            }
                            operandStack.push({
                                kind: 'ByteVec',
                                value: new Uint8Array(Number(size.value))
                            });
                        }
                        break;
                    }
                case 'U256To1Byte':
                case 'U256To2Byte':
                case 'U256To4Byte':
                case 'U256To8Byte':
                case 'U256To16Byte':
                case 'U256To32Byte':
                    {
                        dummyImplementation(instr.name);
                        operandStack.popU256();
                        operandStack.push({
                            kind: 'Symbol-ByteVec',
                            value: undefined
                        });
                        break;
                    }
                case 'U256From1Byte':
                case 'U256From2Byte':
                case 'U256From4Byte':
                case 'U256From8Byte':
                case 'U256From16Byte':
                case 'U256From32Byte':
                    {
                        dummyImplementation(instr.name);
                        operandStack.popByteVec();
                        operandStack.push({
                            kind: 'Symbol-U256',
                            value: undefined
                        });
                        break;
                    }
                case 'CallExternal':
                case 'CallExternalBySelector':
                    {
                        const contractId = operandStack.popByteVec();
                        const returnLength = operandStack.popU256(); // method return length
                        operandStack.popU256(); // method args length
                        if (contractId.kind !== 'Symbol-ByteVec') {
                            contractCalls.push({
                                contractAddress: (0, address_1.addressFromContractId)((0, utils_1.binToHex)(contractId.value)),
                                approvedAttoAlphAmount: approved.getApprovedAttoAlph(),
                                approvedTokens: approved.getApprovedTokens()
                            });
                        }
                        approved.reset();
                        if (returnLength.kind !== 'Symbol-U256') {
                            for(let i = 0; i < returnLength.value; i++){
                                operandStack.push({
                                    kind: 'Symbol-Any',
                                    value: undefined
                                });
                            }
                        }
                        break;
                    }
                case 'ContractIdToAddress':
                    {
                        const contractId = operandStack.popByteVec();
                        if (contractId.kind === 'Symbol-ByteVec') {
                            operandStack.push({
                                kind: 'Symbol-Address',
                                value: undefined
                            });
                        } else {
                            operandStack.push({
                                kind: 'Address',
                                value: {
                                    kind: 'P2C',
                                    value: contractId.value
                                }
                            });
                        }
                        break;
                    }
                case 'LoadLocalByIndex':
                    {
                        const index = operandStack.popU256();
                        if (index.kind === 'Symbol-U256') {
                            throw new Error('LoadLocalByIndex index is a symbol');
                        } else {
                            operandStack.push(localVariables.get(Number(index.value)));
                        }
                        break;
                    }
                case 'StoreLocalByIndex':
                    {
                        const index = operandStack.popU256();
                        if (index.kind === 'Symbol-U256') {
                            throw new Error('StoreLocalByIndex index is a symbol');
                        } else {
                            localVariables.set(Number(index.value), operandStack.pop());
                        }
                        break;
                    }
                case 'CallerAddress':
                    {
                        operandStack.push(callerAddress);
                        break;
                    }
                case 'ApproveAlph':
                    {
                        const amount = operandStack.popU256(); // amount
                        const spender = operandStack.popAddress(); // spender
                        if (spender.kind.startsWith('Symbol')) {
                            approved.setUnknown(); // The spender might be the caller
                        } else if (spender === callerAddress) {
                            approved.addApprovedAttoAlph(amount);
                        }
                        break;
                    }
                case 'ApproveToken':
                    {
                        const amount = operandStack.popU256(); // amount
                        const tokenId = operandStack.popByteVec(); // token
                        const spender = operandStack.popAddress(); // spender
                        if (spender.kind.startsWith('Symbol')) {
                            approved.setUnknown(); // The spender might be the caller
                        } else if (spender === callerAddress) {
                            approved.addApprovedToken(tokenId, amount);
                        }
                        break;
                    }
                case 'CreateContractAndTransferToken':
                    {
                        operandStack.popAddress(); // token owner
                    }
                case 'CreateContractWithToken':
                    {
                        operandStack.popU256(); // token amount
                    }
                case 'CreateContract':
                    {
                        operandStack.popByteVec(); // mutable fields
                        operandStack.popByteVec(); // immutable fields
                        operandStack.popByteVec(); // contract code
                        operandStack.push({
                            kind: 'Symbol-ByteVec',
                            value: undefined
                        }); // new contract id
                        break;
                    }
                case 'TransferAlph':
                    {
                        operandStack.popU256(); // amount
                        operandStack.popAddress(); // recipient
                        operandStack.popAddress(); // sender
                        break;
                    }
                case 'TransferToken':
                    {
                        operandStack.popU256(); // amount
                        operandStack.popByteVec(); // token
                        operandStack.popAddress(); // recipient
                        operandStack.popAddress(); // sender
                        break;
                    }
                default:
                    unimplemented(instr.name);
                    break;
            }
        }
        return contractCalls;
    }
}
exports.ScriptSimulator = ScriptSimulator;
function unaryOp(x, op) {
    if (x.kind.startsWith('Symbol')) {
        return x;
    } else {
        return {
            kind: x.kind,
            value: op(x.value)
        };
    }
}
function binaryOp(x, y, op, push) {
    const result = x.kind.startsWith('Symbol') ? x : y.kind.startsWith('Symbol') ? y : {
        kind: x.kind,
        value: op(x.value, y.value)
    };
    push(result);
}
function comparisonOp(x, y, op, push) {
    const result = x.kind.startsWith('Symbol') || y.kind.startsWith('Symbol') ? {
        kind: 'Symbol-Bool',
        value: undefined
    } : {
        kind: 'Bool',
        value: op(x.value, y.value)
    };
    push(result);
}
// implement arrayEquals
function arrayEquals(x, y) {
    return x.length === y.length && x.every((value, index)=>value === y[`${index}`]);
}
// generate 32 bytes array with random numbers
function random32Bytes() {
    const result = new Uint8Array(32);
    for(let i = 0; i < 32; i++){
        result[`${i}`] = Math.floor(Math.random() * 256);
    }
    return result;
}
class Stack {
    constructor(){
        this.stack = [];
        this.push = (val)=>{
            this.stack.push(val);
        };
    // TODO
    }
    pop() {
        const result = this.stack.pop();
        if (result === undefined) {
            throw new Error('Stack is empty');
        }
        return result;
    }
    size() {
        return this.stack.length;
    }
    checkedResult(result, expected) {
        if (result.kind.startsWith('Symbol')) {
            if (result.kind !== `Symbol-${expected}`) {
                throw new Error(`Expected a ${expected} value on the stack`);
            }
            return result;
        }
        if (result.kind !== expected) {
            throw new Error(`Expected a ${expected} value on the stack`);
        }
        return result;
    }
    popBool() {
        const result = this.pop();
        return this.checkedResult(result, 'Bool');
    }
    popI256() {
        const result = this.pop();
        return this.checkedResult(result, 'I256');
    }
    popU256() {
        const result = this.pop();
        return this.checkedResult(result, 'U256');
    }
    popByteVec() {
        const result = this.pop();
        return this.checkedResult(result, 'ByteVec');
    }
    popAddress() {
        const result = this.pop();
        return this.checkedResult(result, 'Address');
    }
}
class LocalVariables {
    constructor(){
        this.locals = [];
    // TODO
    }
    get(index) {
        const result = this.locals[`${index}`];
        if (result === undefined) {
            throw new Error(`Local variable at index ${index} is not set`);
        }
        return result;
    }
    set(index, val) {
        this.locals[`${index}`] = val;
    }
    checkedResult(result, index, expected) {
        if (result.kind.startsWith('Symbol')) {
            if (result.kind !== `Symbol-${expected}`) {
                throw new Error(`Local variable at index ${index} is not a ${expected}`);
            }
            return result;
        }
        if (result.kind !== expected) {
            throw new Error(`Local variable at index ${index} is not a ${expected}`);
        }
        return result;
    }
    getBool(index) {
        const result = this.get(index);
        return this.checkedResult(result, index, 'Bool');
    }
    getI256(index) {
        const result = this.get(index);
        return this.checkedResult(result, index, 'I256');
    }
    getU256(index) {
        const result = this.get(index);
        return this.checkedResult(result, index, 'U256');
    }
    getByteVec(index) {
        const result = this.get(index);
        return this.checkedResult(result, index, 'ByteVec');
    }
    getAddress(index) {
        const result = this.get(index);
        return this.checkedResult(result, index, 'Address');
    }
}
function unimplemented(instrName) {
    throw new Error(`Unimplemented instruction: ${instrName}`);
}
function dummyImplementation(instrName) {
    console.debug(`Dummy implementation for instruction: ${instrName}`);
}
class ApprovedAccumulator {
    constructor(){
        this.approvedTokens = [];
        this.reset();
    }
    reset() {
        this.approvedTokens = [
            {
                id: constants_1.ALPH_TOKEN_ID,
                amount: 0n
            }
        ];
    }
    setUnknown() {
        this.approvedTokens = 'unknown';
    }
    getApprovedAttoAlph() {
        if (this.approvedTokens === 'unknown') {
            return 'unknown';
        }
        const approvedAttoAlph = this.approvedTokens[0].amount;
        return approvedAttoAlph === 'unknown' ? 'unknown' : approvedAttoAlph === 0n ? undefined : approvedAttoAlph;
    }
    getApprovedTokens() {
        if (this.approvedTokens === 'unknown') {
            return 'unknown';
        }
        const allTokens = this.approvedTokens.slice(1);
        return allTokens.length === 0 ? undefined : allTokens;
    }
    addApprovedAttoAlph(amount) {
        this.addApprovedToken({
            kind: 'ByteVec',
            value: (0, utils_1.hexToBinUnsafe)(constants_1.ALPH_TOKEN_ID)
        }, amount);
    }
    addApprovedToken(tokenId, amount) {
        if (this.approvedTokens === 'unknown') {
            return;
        }
        if (tokenId.kind === 'Symbol-ByteVec') {
            this.approvedTokens = 'unknown';
            return;
        }
        const tokenIndex = this.approvedTokens.findIndex((token)=>arrayEquals((0, utils_1.hexToBinUnsafe)(token.id), tokenId.value));
        if (tokenIndex === -1) {
            this.approvedTokens.push({
                id: (0, utils_1.binToHex)(tokenId.value),
                amount: amount.kind === 'Symbol-U256' ? 'unknown' : amount.value
            });
        } else {
            const approved = this.approvedTokens[`${tokenIndex}`];
            if (approved.amount === 'unknown') {
                return;
            }
            if (amount.kind === 'Symbol-U256') {
                approved.amount = 'unknown';
            } else {
                approved.amount += amount.value;
            }
        }
    }
}
}}),
"[project]/node_modules/@alephium/web3/dist/src/contract/deployment.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
}}),
"[project]/node_modules/@alephium/web3/dist/src/contract/dapp-tx-builder.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.genArgs = exports.DappTransactionBuilder = void 0;
const address_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/address/index.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/index.js [app-ssr] (ecmascript)");
const lockup_script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/lockup-script-codec.js [app-ssr] (ecmascript)");
const script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/script-codec.js [app-ssr] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/constants.js [app-ssr] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/error.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
class DappTransactionBuilder {
    constructor(callerAddress){
        this.callerAddress = callerAddress;
        try {
            this.callerLockupScript = lockup_script_codec_1.lockupScriptCodec.decode((0, utils_1.base58ToBytes)(this.callerAddress));
            if (this.callerLockupScript.kind !== 'P2PKH' && this.callerLockupScript.kind !== 'P2SH') {
                throw new Error(`Expected a P2PKH address or P2SH address`);
            }
        } catch (error) {
            throw new error_1.TraceableError(`Invalid caller address: ${callerAddress}`, error);
        }
        this.approvedAssets = new Map();
        this.instrs = [];
    }
    callContract(params) {
        if (!(0, utils_1.isBase58)(params.contractAddress)) {
            throw new Error(`Invalid contract address: ${params.contractAddress}, expected a base58 string`);
        }
        if (!(0, address_1.isContractAddress)(params.contractAddress)) {
            throw new Error(`Invalid contract address: ${params.contractAddress}, expected a P2C address`);
        }
        if (params.methodIndex < 0) {
            throw new Error(`Invalid method index: ${params.methodIndex}`);
        }
        const allTokens = (params.tokens ?? []).concat([
            {
                id: constants_1.ALPH_TOKEN_ID,
                amount: params.attoAlphAmount ?? 0n
            }
        ]);
        const instrs = [
            ...genApproveAssets(this.callerLockupScript, this.approveTokens(allTokens)),
            ...genContractCall(params.contractAddress, params.methodIndex, params.args, params.retLength ?? 0)
        ];
        this.instrs.push(...instrs);
        return this;
    }
    getResult() {
        const method = {
            isPublic: true,
            usePreapprovedAssets: this.approvedAssets.size > 0,
            useContractAssets: false,
            usePayToContractOnly: false,
            argsLength: 0,
            localsLength: 0,
            returnLength: 0,
            instrs: this.instrs
        };
        const script = {
            methods: [
                method
            ]
        };
        const bytecode = script_codec_1.scriptCodec.encode(script);
        const tokens = Array.from(this.approvedAssets.entries()).map(([id, amount])=>({
                id,
                amount
            }));
        this.approvedAssets.clear();
        this.instrs = [];
        return {
            signerAddress: this.callerAddress,
            signerKeyType: this.callerLockupScript.kind === 'P2PKH' ? 'default' : 'bip340-schnorr',
            bytecode: (0, utils_1.binToHex)(bytecode),
            attoAlphAmount: tokens.find((t)=>t.id === constants_1.ALPH_TOKEN_ID)?.amount,
            tokens: tokens.filter((t)=>t.id !== constants_1.ALPH_TOKEN_ID)
        };
    }
    addTokenToMap(tokenId, amount, map) {
        const current = map.get(tokenId);
        if (current !== undefined) {
            map.set(tokenId, current + amount);
        } else if (amount > 0n) {
            map.set(tokenId, amount);
        }
    }
    approveTokens(tokens) {
        const tokenAmounts = new Map();
        tokens.forEach((token)=>{
            if (!((0, utils_1.isHexString)(token.id) && token.id.length === 64)) {
                throw new Error(`Invalid token id: ${token.id}`);
            }
            if (token.amount < 0n) {
                throw new Error(`Invalid token amount: ${token.amount}`);
            }
            this.addTokenToMap(token.id, token.amount, tokenAmounts);
            this.addTokenToMap(token.id, token.amount, this.approvedAssets);
        });
        return Array.from(tokenAmounts.entries()).map(([id, amount])=>({
                id,
                amount
            }));
    }
}
exports.DappTransactionBuilder = DappTransactionBuilder;
function genApproveAssets(callerLockupScript, tokens) {
    if (tokens.length === 0) {
        return [];
    }
    const approveInstrs = tokens.flatMap((token)=>{
        if (token.id === constants_1.ALPH_TOKEN_ID) {
            return [
                (0, codec_1.U256Const)(token.amount),
                codec_1.ApproveAlph
            ];
        } else {
            const tokenId = (0, codec_1.BytesConst)((0, utils_1.hexToBinUnsafe)(token.id));
            return [
                tokenId,
                (0, codec_1.U256Const)(token.amount),
                codec_1.ApproveToken
            ];
        }
    });
    return [
        (0, codec_1.AddressConst)(callerLockupScript),
        ...Array.from(Array(tokens.length - 1).keys()).map(()=>codec_1.Dup),
        ...approveInstrs
    ];
}
function bigintToNumeric(value) {
    return value >= 0 ? (0, codec_1.toU256)(value) : (0, codec_1.toI256)(value);
}
function strToNumeric(str) {
    const regex = /^-?\d+[ui]?$/;
    if (regex.test(str)) {
        if (str.endsWith('i')) return (0, codec_1.toI256)(BigInt(str.slice(0, str.length - 1)));
        if (str.endsWith('u')) return (0, codec_1.toU256)(BigInt(str.slice(0, str.length - 1)));
        return bigintToNumeric(BigInt(str));
    }
    throw new Error(`Invalid number: ${str}`);
}
function toAddressOpt(str) {
    if (!(0, utils_1.isBase58)(str)) return undefined;
    try {
        return lockup_script_codec_1.lockupScriptCodec.decode((0, utils_1.base58ToBytes)(str));
    } catch (_) {
        return undefined;
    }
}
function genArgs(args) {
    return args.flatMap((arg)=>{
        if (typeof arg === 'boolean') return arg ? [
            codec_1.ConstTrue
        ] : [
            codec_1.ConstFalse
        ];
        if (typeof arg === 'bigint') return bigintToNumeric(arg);
        if (typeof arg === 'string') {
            if ((0, utils_1.isHexString)(arg)) return [
                (0, codec_1.BytesConst)((0, utils_1.hexToBinUnsafe)(arg))
            ];
            const addressOpt = toAddressOpt(arg);
            if (addressOpt !== undefined) return (0, codec_1.AddressConst)(addressOpt);
            return strToNumeric(arg);
        }
        if (Array.isArray(arg)) return genArgs(arg);
        if (arg instanceof Map) throw new Error(`Map cannot be used as a function argument`);
        if (typeof arg === 'object') return genArgs(Object.values(arg));
        throw new Error(`Unknown argument type: ${typeof arg}, arg: ${arg}`);
    });
}
exports.genArgs = genArgs;
function genContractCall(contractAddress, methodIndex, args, retLength) {
    const argInstrs = genArgs(args);
    return [
        ...argInstrs,
        (0, codec_1.toU256)(BigInt(argInstrs.length)),
        (0, codec_1.toU256)(BigInt(retLength)),
        (0, codec_1.BytesConst)((0, address_1.contractIdFromAddress)(contractAddress)),
        (0, codec_1.CallExternal)(methodIndex),
        ...Array.from(Array(retLength).keys()).map(()=>codec_1.Pop)
    ];
}
}}),
"[project]/node_modules/@alephium/web3/dist/src/contract/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.DappTransactionBuilder = void 0;
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/contract/ralph.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/contract/contract.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/contract/events.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/contract/script-simulator.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/contract/deployment.js [app-ssr] (ecmascript)"), exports);
var dapp_tx_builder_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/contract/dapp-tx-builder.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "DappTransactionBuilder", {
    enumerable: true,
    get: function() {
        return dapp_tx_builder_1.DappTransactionBuilder;
    }
});
}}),
"[project]/node_modules/@alephium/web3/dist/src/transaction/status.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.subscribeToTxStatus = exports.TxStatusSubscription = void 0;
const web3 = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/global.js [app-ssr] (ecmascript)"));
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
class TxStatusSubscription extends utils_1.Subscription {
    constructor(options, txId, fromGroup, toGroup, confirmations){
        super(options);
        this.txId = txId;
        this.fromGroup = fromGroup;
        this.toGroup = toGroup;
        this.confirmations = confirmations ?? 1;
    }
    async polling() {
        try {
            const txStatus = await web3.getCurrentNodeProvider().transactions.getTransactionsStatus({
                txId: this.txId,
                fromGroup: this.fromGroup,
                toGroup: this.toGroup
            });
            await this.messageCallback(txStatus);
            if (txStatus.type === 'Confirmed' && txStatus.chainConfirmations >= this.confirmations) {
                this.unsubscribe();
            }
        } catch (err) {
            await this.errorCallback(err, this);
        }
    }
}
exports.TxStatusSubscription = TxStatusSubscription;
function subscribeToTxStatus(options, txId, fromGroup, toGroup, confirmations) {
    const subscription = new TxStatusSubscription(options, txId, fromGroup, toGroup, confirmations);
    subscription.subscribe();
    return subscription;
}
exports.subscribeToTxStatus = subscribeToTxStatus;
}}),
"[project]/node_modules/@alephium/web3/dist/src/transaction/sign-verify.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.transactionVerifySignature = exports.transactionSign = void 0;
const utils = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)"));
function transactionSign(txId, privateKey, keyType) {
    return utils.sign(txId, privateKey, keyType);
}
exports.transactionSign = transactionSign;
function transactionVerifySignature(txId, publicKey, signature, keyType) {
    return utils.verifySignature(txId, publicKey, signature, keyType);
}
exports.transactionVerifySignature = transactionVerifySignature;
}}),
"[project]/node_modules/@alephium/web3/dist/src/transaction/utils.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.groupIndexOfTransaction = exports.waitForTxConfirmation = void 0;
const address_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/address/index.js [app-ssr] (ecmascript)");
const constants_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/constants.js [app-ssr] (ecmascript)");
const global_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/global.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
function isConfirmed(txStatus) {
    return txStatus.type === 'Confirmed';
}
async function waitForTxConfirmation(txId, confirmations, requestInterval) {
    const provider = (0, global_1.getCurrentNodeProvider)();
    const status = await provider.transactions.getTransactionsStatus({
        txId: txId
    });
    if (isConfirmed(status) && status.chainConfirmations >= confirmations) {
        return status;
    }
    await new Promise((r)=>setTimeout(r, requestInterval));
    return waitForTxConfirmation(txId, confirmations, requestInterval);
}
exports.waitForTxConfirmation = waitForTxConfirmation;
function groupIndexOfTransaction(unsignedTx) {
    if (unsignedTx.inputs.length === 0) throw new Error('Empty inputs for unsignedTx');
    const fromGroup = groupFromHint(unsignedTx.inputs[0].hint);
    let toGroup = fromGroup;
    for (const output of unsignedTx.fixedOutputs){
        const outputGroup = (0, address_1.groupOfLockupScript)(output.lockupScript);
        if (outputGroup !== fromGroup) {
            toGroup = outputGroup;
            break;
        }
    }
    return [
        fromGroup,
        toGroup
    ];
}
exports.groupIndexOfTransaction = groupIndexOfTransaction;
function groupFromHint(hint) {
    const hash = (0, utils_1.xorByte)(hint);
    return hash % constants_1.TOTAL_NUMBER_OF_GROUPS;
}
}}),
"[project]/node_modules/@alephium/web3/dist/src/transaction/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/transaction/status.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/transaction/sign-verify.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/transaction/utils.js [app-ssr] (ecmascript)"), exports);
}}),
"[project]/node_modules/@alephium/web3/dist/src/signer/tx-builder.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.TransactionBuilder = void 0;
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const api_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/index.js [app-ssr] (ecmascript)");
const address_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/address/index.js [app-ssr] (ecmascript)");
const signer_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/signer/signer.js [app-ssr] (ecmascript)");
const codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/index.js [app-ssr] (ecmascript)");
const transaction_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/transaction/index.js [app-ssr] (ecmascript)");
const hash_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/hash.js [app-ssr] (ecmascript)");
class TransactionBuilder {
    static from(param0, param1, customFetch) {
        const nodeProvider = typeof param0 === 'string' ? new api_1.NodeProvider(param0, param1, customFetch) : param0;
        return new class extends TransactionBuilder {
            get nodeProvider() {
                return nodeProvider;
            }
        }();
    }
    static validatePublicKey(params, publicKey, keyType) {
        const address = (0, address_1.addressFromPublicKey)(publicKey, keyType);
        if (address !== params.signerAddress) {
            throw new Error('Unmatched public key');
        }
    }
    async buildTransferTx(params, publicKey) {
        const data = this.buildTransferTxParams(params, publicKey);
        const response = await this.nodeProvider.transactions.postTransactionsBuild(data);
        return this.convertTransferTxResult(response);
    }
    async buildDeployContractTx(params, publicKey) {
        const data = this.buildDeployContractTxParams(params, publicKey);
        const response = await this.nodeProvider.contracts.postContractsUnsignedTxDeployContract(data);
        return this.convertDeployContractTxResult(response);
    }
    async buildExecuteScriptTx(params, publicKey) {
        const data = this.buildExecuteScriptTxParams(params, publicKey);
        const response = await this.nodeProvider.contracts.postContractsUnsignedTxExecuteScript(data);
        return this.convertExecuteScriptTxResult(response);
    }
    async buildChainedTx(params, publicKeys) {
        if (params.length !== publicKeys.length) {
            throw new Error('The number of build chained transaction parameters must match the number of public keys provided');
        }
        const data = params.map((param, index)=>{
            const paramType = param.type;
            switch(paramType){
                case 'Transfer':
                    {
                        const value = this.buildTransferTxParams(param, publicKeys[index]);
                        return {
                            type: paramType,
                            value
                        };
                    }
                case 'DeployContract':
                    {
                        const value = this.buildDeployContractTxParams(param, publicKeys[index]);
                        return {
                            type: paramType,
                            value
                        };
                    }
                case 'ExecuteScript':
                    {
                        const value = this.buildExecuteScriptTxParams(param, publicKeys[index]);
                        return {
                            type: paramType,
                            value
                        };
                    }
                default:
                    throw new Error(`Unsupported transaction type: ${paramType}`);
            }
        });
        const buildChainedTxsResponse = await this.nodeProvider.transactions.postTransactionsBuildChained(data);
        const results = buildChainedTxsResponse.map((buildResult)=>{
            const buildResultType = buildResult.type;
            switch(buildResultType){
                case 'Transfer':
                    {
                        const buildTransferTxResult = buildResult.value;
                        return {
                            ...this.convertTransferTxResult(buildTransferTxResult),
                            type: buildResultType
                        };
                    }
                case 'DeployContract':
                    {
                        const buildDeployContractTxResult = buildResult.value;
                        return {
                            ...this.convertDeployContractTxResult(buildDeployContractTxResult),
                            type: buildResultType
                        };
                    }
                case 'ExecuteScript':
                    {
                        const buildExecuteScriptTxResult = buildResult.value;
                        return {
                            ...this.convertExecuteScriptTxResult(buildExecuteScriptTxResult),
                            type: buildResultType
                        };
                    }
                default:
                    throw new Error(`Unexpected transaction type: ${buildResultType} for ${buildResult.value.txId}`);
            }
        });
        return results;
    }
    static buildUnsignedTx(params) {
        const unsignedTxBin = (0, utils_1.hexToBinUnsafe)(params.unsignedTx);
        const decoded = codec_1.unsignedTxCodec.decode(unsignedTxBin);
        const txId = (0, utils_1.binToHex)((0, hash_1.blakeHash)(unsignedTxBin));
        const [fromGroup, toGroup] = (0, transaction_1.groupIndexOfTransaction)(decoded);
        return {
            fromGroup: fromGroup,
            toGroup: toGroup,
            unsignedTx: params.unsignedTx,
            txId: txId,
            gasAmount: decoded.gasAmount,
            gasPrice: decoded.gasPrice
        };
    }
    buildTransferTxParams(params, publicKey) {
        TransactionBuilder.validatePublicKey(params, publicKey, params.signerKeyType);
        const { destinations, gasPrice, ...rest } = params;
        return {
            fromPublicKey: publicKey,
            fromPublicKeyType: params.signerKeyType,
            destinations: (0, signer_1.toApiDestinations)(destinations),
            gasPrice: (0, api_1.toApiNumber256Optional)(gasPrice),
            ...rest
        };
    }
    buildDeployContractTxParams(params, publicKey) {
        TransactionBuilder.validatePublicKey(params, publicKey, params.signerKeyType);
        const { initialAttoAlphAmount, initialTokenAmounts, issueTokenAmount, gasPrice, ...rest } = params;
        return {
            fromPublicKey: publicKey,
            fromPublicKeyType: params.signerKeyType,
            initialAttoAlphAmount: (0, api_1.toApiNumber256Optional)(initialAttoAlphAmount),
            initialTokenAmounts: (0, api_1.toApiTokens)(initialTokenAmounts),
            issueTokenAmount: (0, api_1.toApiNumber256Optional)(issueTokenAmount),
            gasPrice: (0, api_1.toApiNumber256Optional)(gasPrice),
            ...rest
        };
    }
    buildExecuteScriptTxParams(params, publicKey) {
        TransactionBuilder.validatePublicKey(params, publicKey, params.signerKeyType);
        const { attoAlphAmount, tokens, gasPrice, ...rest } = params;
        return {
            fromPublicKey: publicKey,
            fromPublicKeyType: params.signerKeyType,
            attoAlphAmount: (0, api_1.toApiNumber256Optional)(attoAlphAmount),
            tokens: (0, api_1.toApiTokens)(tokens),
            gasPrice: (0, api_1.toApiNumber256Optional)(gasPrice),
            ...rest
        };
    }
    convertTransferTxResult(result) {
        return {
            ...result,
            gasPrice: (0, api_1.fromApiNumber256)(result.gasPrice)
        };
    }
    convertDeployContractTxResult(result) {
        const contractId = (0, utils_1.binToHex)((0, address_1.contractIdFromAddress)(result.contractAddress));
        return {
            ...result,
            groupIndex: result.fromGroup,
            contractId,
            gasPrice: (0, api_1.fromApiNumber256)(result.gasPrice)
        };
    }
    convertExecuteScriptTxResult(result) {
        return {
            ...result,
            groupIndex: result.fromGroup,
            gasPrice: (0, api_1.fromApiNumber256)(result.gasPrice)
        };
    }
}
exports.TransactionBuilder = TransactionBuilder;
}}),
"[project]/node_modules/@alephium/web3/dist/src/signer/signer.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = this && this.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {
        "default": mod
    };
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.fromApiDestination = exports.toApiDestinations = exports.toApiDestination = exports.verifySignedMessage = exports.hashMessage = exports.extendMessage = exports.SignerProviderWithCachedAccounts = exports.SignerProviderWithMultipleAccounts = exports.SignerProviderSimple = exports.InteractiveSignerProvider = exports.SignerProvider = void 0;
const crypto_1 = __turbopack_context__.r("[externals]/crypto [external] (crypto, cjs)");
const api_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/index.js [app-ssr] (ecmascript)");
const utils = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)"));
const blakejs_1 = __importDefault(__turbopack_context__.r("[project]/node_modules/blakejs/index.js [app-ssr] (ecmascript)"));
const tx_builder_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/signer/tx-builder.js [app-ssr] (ecmascript)");
const address_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/address/index.js [app-ssr] (ecmascript)");
class SignerProvider {
    async getSelectedAccount() {
        const account = await this.unsafeGetSelectedAccount();
        SignerProvider.validateAccount(account);
        return account;
    }
    static validateAccount(account) {
        const derivedAddress = (0, address_1.addressFromPublicKey)(account.publicKey, account.keyType);
        const derivedGroup = (0, address_1.groupOfAddress)(derivedAddress);
        if (derivedAddress !== account.address || derivedGroup !== account.group) {
            throw Error(`Invalid accounot data: ${JSON.stringify(account)}`);
        }
    }
}
exports.SignerProvider = SignerProvider;
// Abstraction for interactive signer (e.g. WalletConnect instance, Extension wallet object)
class InteractiveSignerProvider extends SignerProvider {
    async enable(opt) {
        const account = await this.unsafeEnable(opt);
        SignerProvider.validateAccount(account);
        return account;
    }
}
exports.InteractiveSignerProvider = InteractiveSignerProvider;
class SignerProviderSimple extends SignerProvider {
    async submitTransaction(params) {
        const data = {
            unsignedTx: params.unsignedTx,
            signature: params.signature
        };
        return this.nodeProvider.transactions.postTransactionsSubmit(data);
    }
    async signAndSubmitTransferTx(params) {
        const signResult = await this.signTransferTx(params);
        await this.submitTransaction(signResult);
        return signResult;
    }
    async signAndSubmitDeployContractTx(params) {
        const signResult = await this.signDeployContractTx(params);
        await this.submitTransaction(signResult);
        return signResult;
    }
    async signAndSubmitExecuteScriptTx(params) {
        const signResult = await this.signExecuteScriptTx(params);
        await this.submitTransaction(signResult);
        return signResult;
    }
    async signAndSubmitUnsignedTx(params) {
        const signResult = await this.signUnsignedTx(params);
        await this.submitTransaction(signResult);
        return signResult;
    }
    async signAndSubmitChainedTx(params) {
        const signResults = await this.signChainedTx(params);
        for (const r of signResults){
            await this.submitTransaction(r);
        }
        return signResults;
    }
    async signTransferTx(params) {
        const response = await this.buildTransferTx(params);
        const signature = await this.signRaw(params.signerAddress, response.txId);
        return {
            signature,
            ...response
        };
    }
    async buildTransferTx(params) {
        return tx_builder_1.TransactionBuilder.from(this.nodeProvider).buildTransferTx(params, await this.getPublicKey(params.signerAddress));
    }
    async signDeployContractTx(params) {
        const response = await this.buildDeployContractTx(params);
        const signature = await this.signRaw(params.signerAddress, response.txId);
        return {
            signature,
            ...response
        };
    }
    async buildDeployContractTx(params) {
        return tx_builder_1.TransactionBuilder.from(this.nodeProvider).buildDeployContractTx(params, await this.getPublicKey(params.signerAddress));
    }
    async signExecuteScriptTx(params) {
        const response = await this.buildExecuteScriptTx(params);
        const signature = await this.signRaw(params.signerAddress, response.txId);
        return {
            signature,
            ...response
        };
    }
    async buildExecuteScriptTx(params) {
        return tx_builder_1.TransactionBuilder.from(this.nodeProvider).buildExecuteScriptTx(params, await this.getPublicKey(params.signerAddress));
    }
    async signChainedTx(params) {
        const response = await this.buildChainedTx(params);
        const signatures = await Promise.all(response.map((r, i)=>this.signRaw(params[`${i}`].signerAddress, r.txId)));
        return response.map((r, i)=>({
                ...r,
                signature: signatures[`${i}`]
            }));
    }
    async buildChainedTx(params) {
        return tx_builder_1.TransactionBuilder.from(this.nodeProvider).buildChainedTx(params, await Promise.all(params.map((p)=>this.getPublicKey(p.signerAddress))));
    }
    // in general, wallet should show the decoded information to user for confirmation
    // please overwrite this function for real wallet
    async signUnsignedTx(params) {
        const response = tx_builder_1.TransactionBuilder.buildUnsignedTx(params);
        const signature = await this.signRaw(params.signerAddress, response.txId);
        return {
            signature,
            ...response
        };
    }
    async signMessage(params) {
        const messageHash = hashMessage(params.message, params.messageHasher);
        const signature = await this.signRaw(params.signerAddress, messageHash);
        return {
            signature: signature
        };
    }
}
exports.SignerProviderSimple = SignerProviderSimple;
class SignerProviderWithMultipleAccounts extends SignerProviderSimple {
    async getAccount(signerAddress) {
        const accounts = await this.getAccounts();
        const account = accounts.find((a)=>a.address === signerAddress);
        if (typeof account === 'undefined') {
            throw new Error('Unmatched signerAddress');
        } else {
            return account;
        }
    }
    async getPublicKey(signerAddress) {
        const account = await this.getAccount(signerAddress);
        return account.publicKey;
    }
}
exports.SignerProviderWithMultipleAccounts = SignerProviderWithMultipleAccounts;
class SignerProviderWithCachedAccounts extends SignerProviderWithMultipleAccounts {
    constructor(){
        super(...arguments);
        this._selectedAccount = undefined;
        this._accounts = new Map();
    }
    unsafeGetSelectedAccount() {
        if (this._selectedAccount === undefined) {
            throw Error('No account is selected yet');
        } else {
            return Promise.resolve(this._selectedAccount);
        }
    }
    setSelectedAccount(address) {
        const accountOpt = this._accounts.get(address);
        if (accountOpt === undefined) {
            throw Error('The address is not in the accounts');
        } else {
            this._selectedAccount = accountOpt;
            return Promise.resolve();
        }
    }
    getAccounts() {
        return Promise.resolve(Array.from(this._accounts.values()));
    }
    async getAccount(address) {
        const account = this._accounts.get(address);
        if (account === undefined) {
            throw Error('The address is not in the accounts');
        }
        return Promise.resolve(account);
    }
}
exports.SignerProviderWithCachedAccounts = SignerProviderWithCachedAccounts;
function extendMessage(message) {
    return 'Alephium Signed Message: ' + message;
}
exports.extendMessage = extendMessage;
function hashMessage(message, hasher) {
    switch(hasher){
        case 'alephium':
            return utils.binToHex(blakejs_1.default.blake2b(extendMessage(message), undefined, 32));
        case 'sha256':
            const sha256 = (0, crypto_1.createHash)('sha256');
            sha256.update(new TextEncoder().encode(message));
            return utils.binToHex(sha256.digest());
        case 'blake2b':
            return utils.binToHex(blakejs_1.default.blake2b(message, undefined, 32));
        case 'identity':
            return message;
        default:
            throw Error(`Invalid message hasher: ${hasher}`);
    }
}
exports.hashMessage = hashMessage;
function verifySignedMessage(message, messageHasher, publicKey, signature, keyType) {
    const messageHash = hashMessage(message, messageHasher);
    return utils.verifySignature(messageHash, publicKey, signature, keyType);
}
exports.verifySignedMessage = verifySignedMessage;
function toApiDestination(data) {
    return {
        ...data,
        attoAlphAmount: (0, api_1.toApiNumber256)(data.attoAlphAmount),
        tokens: (0, api_1.toApiTokens)(data.tokens)
    };
}
exports.toApiDestination = toApiDestination;
function toApiDestinations(data) {
    return data.map(toApiDestination);
}
exports.toApiDestinations = toApiDestinations;
function fromApiDestination(data) {
    return {
        ...data,
        attoAlphAmount: (0, api_1.fromApiNumber256)(data.attoAlphAmount ?? '0'),
        tokens: (0, api_1.fromApiTokens)(data.tokens)
    };
}
exports.fromApiDestination = fromApiDestination;
}}),
"[project]/node_modules/@alephium/web3/dist/src/signer/types.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
utils_1.assertType;
(0, utils_1.assertType)();
(0, utils_1.assertType)();
(0, utils_1.assertType)();
(0, utils_1.assertType)();
(0, utils_1.assertType)();
(0, utils_1.assertType)();
(0, utils_1.assertType)();
utils_1.assertType;
(0, utils_1.assertType)();
}}),
"[project]/node_modules/@alephium/web3/dist/src/signer/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/signer/signer.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/signer/types.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/signer/tx-builder.js [app-ssr] (ecmascript)"), exports);
}}),
"[project]/node_modules/@alephium/web3/dist/src/token/nft.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.validateNFTBaseUri = exports.validateNFTCollectionUriMetaData = exports.validateNFTTokenUriMetaData = exports.validNFTCollectionUriMetaDataFields = exports.validNFTUriMetaDataAttributeTypes = exports.validNFTTokenUriMetaDataAttributesFields = exports.validNFTTokenUriMetaDataFields = void 0;
// JSON Schema for the NFT metadata, which is pointed to by the value
// returned from the `getTokenUri` method of the NFT contract
__turbopack_context__.r("[project]/node_modules/cross-fetch/dist/node-polyfill.js [app-ssr] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/error.js [app-ssr] (ecmascript)");
exports.validNFTTokenUriMetaDataFields = [
    'name',
    'description',
    'image',
    'attributes'
];
exports.validNFTTokenUriMetaDataAttributesFields = [
    'trait_type',
    'value'
];
exports.validNFTUriMetaDataAttributeTypes = [
    'string',
    'number',
    'boolean'
];
exports.validNFTCollectionUriMetaDataFields = [
    'name',
    'description',
    'image'
];
function validateNFTTokenUriMetaData(metadata) {
    Object.keys(metadata).forEach((key)=>{
        if (!exports.validNFTTokenUriMetaDataFields.includes(key)) {
            throw new Error(`Invalid field ${key}, only ${exports.validNFTTokenUriMetaDataFields} are allowed`);
        }
    });
    const name = validateNonEmptyString(metadata, 'name');
    const description = validateNonEmptyStringIfExists(metadata, 'description');
    const image = validateNonEmptyString(metadata, 'image');
    const attributes = validateNFTTokenUriMetaDataAttributes(metadata['attributes']);
    return {
        name,
        description,
        image,
        attributes
    };
}
exports.validateNFTTokenUriMetaData = validateNFTTokenUriMetaData;
function validateNFTCollectionUriMetaData(metadata) {
    Object.keys(metadata).forEach((key)=>{
        if (!exports.validNFTCollectionUriMetaDataFields.includes(key)) {
            throw new Error(`Invalid field ${key}, only ${exports.validNFTCollectionUriMetaDataFields} are allowed`);
        }
    });
    const name = validateNonEmptyString(metadata, 'name');
    const description = validateNonEmptyString(metadata, 'description');
    const image = validateNonEmptyString(metadata, 'image');
    return {
        name,
        description,
        image
    };
}
exports.validateNFTCollectionUriMetaData = validateNFTCollectionUriMetaData;
async function validateNFTBaseUri(nftBaseUri, maxSupply) {
    if (isInteger(maxSupply) && maxSupply > 0) {
        const nftMetadataz = [];
        for(let i = 0; i < maxSupply; i++){
            const nftMetadata = await fetchNFTMetadata(nftBaseUri, i);
            const validatedNFTMetadata = validateNFTTokenUriMetaData(nftMetadata);
            nftMetadataz.push(validatedNFTMetadata);
        }
        return nftMetadataz;
    } else {
        throw new Error('maxSupply should be a positive integer');
    }
}
exports.validateNFTBaseUri = validateNFTBaseUri;
function validateNFTTokenUriMetaDataAttributes(attributes) {
    if (!!attributes) {
        if (!Array.isArray(attributes)) {
            throw new Error(`Field 'attributes' should be an array`);
        }
        attributes.forEach((item)=>{
            if (typeof item !== 'object') {
                throw new Error(`Field 'attributes' should be an array of objects`);
            }
            Object.keys(item).forEach((key)=>{
                if (!exports.validNFTTokenUriMetaDataAttributesFields.includes(key)) {
                    throw new Error(`Invalid field ${key} for attributes, only ${exports.validNFTTokenUriMetaDataAttributesFields} are allowed`);
                }
            });
            validateNonEmptyString(item, 'trait_type');
            validateNonEmptyAttributeValue(item, 'value');
        });
    }
    return attributes;
}
function validateNonEmptyString(obj, field) {
    const value = obj[`${field}`];
    if (!(typeof value === 'string' && value !== '')) {
        throw new Error(`JSON field '${field}' is not a non empty string`);
    }
    return value;
}
function validateNonEmptyStringIfExists(obj, field) {
    const value = obj[`${field}`];
    if (value !== undefined && !(typeof value === 'string' && value !== '')) {
        throw new Error(`JSON field '${field}' is not a non empty string`);
    }
    return value;
}
function validateNonEmptyAttributeValue(obj, field) {
    const value = obj[`${field}`];
    if (!(typeof value === 'string' && value !== '' || typeof value === 'number' || typeof value === 'boolean')) {
        throw new Error(`Attribute value should be a non empty string, number or boolean`);
    }
    return value;
}
async function fetchNFTMetadata(nftBaseUri, index) {
    try {
        return await (await fetch(`${nftBaseUri}${index}`)).json();
    } catch (e) {
        throw new error_1.TraceableError(`Error fetching NFT metadata from ${nftBaseUri}${index}`, e);
    }
}
function isInteger(num) {
    return num === parseInt(num.toString(), 10);
}
}}),
"[project]/node_modules/@alephium/web3/dist/src/token/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/token/nft.js [app-ssr] (ecmascript)"), exports);
}}),
"[project]/node_modules/@alephium/web3/dist/src/block/block.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BlockSubscription = exports.BlockSubscriptionBase = void 0;
const subscription_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/subscription.js [app-ssr] (ecmascript)");
const web3 = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/global.js [app-ssr] (ecmascript)"));
const constants_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/constants.js [app-ssr] (ecmascript)");
const DEFAULT_INTERVAL = 60 * 1000; // 60 seconds
const EXPIRE_DURATION = 20 * 1000; // 20 seconds
class BlockSubscriptionBase extends subscription_1.Subscription {
    getParentHash(block) {
        const index = Math.floor(block.deps.length / 2) + block.chainTo;
        return block.deps[index];
    }
    async handleReorg(fromGroup, toGroup, orphanBlockHash, newBlockHash) {
        console.info(`reorg occur in chain ${fromGroup} -> ${toGroup}, orphan hash: ${orphanBlockHash}, new hash: ${newBlockHash}`);
        if (this.reorgCallback === undefined) return;
        const orphanBlocks = [];
        let fromHash = orphanBlockHash;
        let canonicalHash = undefined;
        while(true){
            const orphanBlock = await this.getBlockByHash(fromHash);
            orphanBlocks.push(orphanBlock);
            const hashes = await this.getHashesAtHeight(fromGroup, toGroup, orphanBlock.height - 1);
            const parentHash = this.getParentHash(orphanBlock);
            if (hashes[0] === parentHash) {
                canonicalHash = hashes[0];
                break;
            }
            fromHash = parentHash;
        }
        const newBlocks = [];
        fromHash = newBlockHash;
        while(fromHash !== canonicalHash){
            const newBlock = await this.getBlockByHash(fromHash);
            newBlocks.push(newBlock);
            fromHash = this.getParentHash(newBlock);
        }
        const orphans = orphanBlocks.reverse();
        const news = newBlocks.reverse();
        console.info(`orphan hashes: ${orphans.map((b)=>b.hash)}, new hashes: ${news.map((b)=>b.hash)}`);
        await this.reorgCallback(fromGroup, toGroup, orphans, news);
    }
}
exports.BlockSubscriptionBase = BlockSubscriptionBase;
class BlockSubscription extends BlockSubscriptionBase {
    constructor(options, fromTimeStamp, nodeProvider = undefined){
        super(options);
        this.nodeProvider = nodeProvider ?? web3.getCurrentNodeProvider();
        this.reorgCallback = options.reorgCallback;
        this.fromTimeStamp = fromTimeStamp;
        this.parents = new Array(constants_1.TOTAL_NUMBER_OF_CHAINS).fill(undefined);
        this.cache = new Map();
    }
    async getHashesAtHeight(fromGroup, toGroup, height) {
        const result = await this.nodeProvider.blockflow.getBlockflowHashes({
            fromGroup,
            toGroup,
            height
        });
        return result.headers;
    }
    async getBlockByHash(hash) {
        return await this.nodeProvider.blockflow.getBlockflowBlocksBlockHash(hash);
    }
    async getMissingBlocksAndHandleReorg(fromHash, fromHeight, toBlock) {
        const blocks = [];
        let lastBlock = toBlock;
        while(lastBlock.height - 1 > fromHeight){
            const parentHash = this.getParentHash(lastBlock);
            const block = await this.getBlockByHash(parentHash);
            blocks.push(block);
            lastBlock = block;
        }
        const parentHash = this.getParentHash(lastBlock);
        if (parentHash !== fromHash) {
            await this.handleReorg(toBlock.chainFrom, toBlock.chainTo, fromHash, parentHash);
        }
        return blocks.reverse();
    }
    async handleBlocks(blocks, now) {
        const allBlocks = [];
        for(let index = 0; index < blocks.length; index += 1){
            const blocksPerChain = blocks[index].filter((b)=>!this.cache.has(b.hash));
            if (blocksPerChain.length === 0) continue;
            allBlocks.push(...blocksPerChain);
            const parent = this.parents[index];
            if (parent !== undefined) {
                const missingBlocks = await this.getMissingBlocksAndHandleReorg(parent.hash, parent.height, blocksPerChain[0]);
                allBlocks.push(...missingBlocks);
            }
            const latestBlock = blocksPerChain[blocksPerChain.length - 1];
            this.parents[index] = {
                hash: latestBlock.hash,
                height: latestBlock.height
            };
        }
        const sortedBlocks = allBlocks.sort((a, b)=>a.timestamp - b.timestamp);
        try {
            await this.messageCallback(sortedBlocks);
        } finally{
            const threshold = now - EXPIRE_DURATION;
            Array.from(this.cache.entries()).forEach(([hash, ts])=>{
                if (ts < threshold) this.cache.delete(hash);
            });
            const index = sortedBlocks.findIndex((b)=>b.timestamp >= threshold);
            if (index !== -1) {
                sortedBlocks.slice(index).forEach((b)=>this.cache.set(b.hash, b.timestamp));
            }
        }
    }
    async polling() {
        const now = Date.now();
        if (this.fromTimeStamp >= now) return;
        while(this.fromTimeStamp < now){
            if (this.isCancelled()) return;
            const toTs = Math.min(this.fromTimeStamp + DEFAULT_INTERVAL, now);
            try {
                const result = await this.nodeProvider.blockflow.getBlockflowBlocks({
                    fromTs: this.fromTimeStamp,
                    toTs
                });
                await this.handleBlocks(result.blocks, now);
            } catch (err) {
                await this.errorCallback(err, this);
            }
            if (this.fromTimeStamp + EXPIRE_DURATION < now) {
                this.fromTimeStamp = Math.min(toTs + 1, now - EXPIRE_DURATION);
            } else {
                return;
            }
        }
    }
}
exports.BlockSubscription = BlockSubscription;
}}),
"[project]/node_modules/@alephium/web3/dist/src/block/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.BlockSubscription = void 0;
var block_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/block/block.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "BlockSubscription", {
    enumerable: true,
    get: function() {
        return block_1.BlockSubscription;
    }
});
}}),
"[project]/node_modules/@alephium/web3/dist/src/exchange/exchange.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.isTransferTx = exports.getAddressFromUnlockScript = exports.getSenderAddress = exports.getDepositInfo = exports.getALPHDepositInfo = exports.isALPHTransferTx = exports.validateExchangeAddress = void 0;
const address_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/address/index.js [app-ssr] (ecmascript)");
const utils_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)");
const unlock_script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/unlock-script-codec.js [app-ssr] (ecmascript)");
const script_codec_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/script-codec.js [app-ssr] (ecmascript)");
const error_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/error.js [app-ssr] (ecmascript)");
function validateExchangeAddress(address) {
    const decoded = (0, utils_1.base58ToBytes)(address);
    if (decoded.length === 0) throw new Error('Address is empty');
    const addressType = decoded[0];
    if (addressType !== address_1.AddressType.P2PKH && addressType !== address_1.AddressType.P2SH) {
        throw new Error('Invalid address type');
    }
    if (decoded.length !== 33) {
        throw new Error('Invalid address length');
    }
}
exports.validateExchangeAddress = validateExchangeAddress;
function isALPHTransferTx(tx) {
    return isTransferTx(tx) && checkALPHOutput(tx);
}
exports.isALPHTransferTx = isALPHTransferTx;
function getALPHDepositInfo(tx) {
    if (!isALPHTransferTx(tx)) return [];
    const inputAddresses = getInputAddresses(tx);
    const result = new Map();
    tx.unsigned.fixedOutputs.forEach((o)=>{
        if (!inputAddresses.includes(o.address)) {
            const amount = result.get(o.address);
            if (amount === undefined) {
                result.set(o.address, BigInt(o.attoAlphAmount));
            } else {
                result.set(o.address, BigInt(o.attoAlphAmount) + amount);
            }
        }
    });
    return Array.from(result.entries()).map(([key, value])=>({
            targetAddress: key,
            depositAmount: value
        }));
}
exports.getALPHDepositInfo = getALPHDepositInfo;
function getInputAddresses(tx) {
    const inputAddresses = [];
    for (const input of tx.unsigned.inputs){
        try {
            if (input.unlockScript === (0, utils_1.binToHex)(unlock_script_codec_1.encodedSameAsPrevious)) continue;
            const address = getAddressFromUnlockScript(input.unlockScript);
            if (!inputAddresses.includes(address)) {
                inputAddresses.push(address);
            }
        } catch (error) {
            throw new error_1.TraceableError(`Failed to decode address from unlock script`, error);
        }
    }
    return inputAddresses;
}
function getDepositInfo(tx) {
    if (!isTransferTx(tx)) return {
        alph: [],
        tokens: []
    };
    const inputAddresses = getInputAddresses(tx);
    const alphDepositInfos = new Map();
    const tokenDepositInfos = new Map();
    tx.unsigned.fixedOutputs.forEach((o)=>{
        if (!inputAddresses.includes(o.address)) {
            const alphAmount = alphDepositInfos.get(o.address) ?? 0n;
            alphDepositInfos.set(o.address, alphAmount + BigInt(o.attoAlphAmount));
            o.tokens.forEach((token)=>{
                const depositPerToken = tokenDepositInfos.get(token.id) ?? new Map();
                const currentAmount = depositPerToken.get(o.address) ?? 0n;
                depositPerToken.set(o.address, currentAmount + BigInt(token.amount));
                tokenDepositInfos.set(token.id, depositPerToken);
            });
        }
    });
    return {
        alph: Array.from(alphDepositInfos.entries()).map(([key, value])=>({
                targetAddress: key,
                depositAmount: value
            })),
        tokens: Array.from(tokenDepositInfos.entries()).flatMap(([tokenId, depositPerToken])=>{
            return Array.from(depositPerToken.entries()).map(([targetAddress, depositAmount])=>({
                    tokenId,
                    targetAddress,
                    depositAmount
                }));
        })
    };
}
exports.getDepositInfo = getDepositInfo;
// we assume that the tx is a simple transfer tx, i.e. isALPHTransferTx(tx) || isTokenTransferTx(tx)
function getSenderAddress(tx) {
    return getAddressFromUnlockScript(tx.unsigned.inputs[0].unlockScript);
}
exports.getSenderAddress = getSenderAddress;
var UnlockScriptType;
(function(UnlockScriptType) {
    UnlockScriptType[UnlockScriptType["P2PKH"] = 0] = "P2PKH";
    UnlockScriptType[UnlockScriptType["P2MPKH"] = 1] = "P2MPKH";
    UnlockScriptType[UnlockScriptType["P2SH"] = 2] = "P2SH";
})(UnlockScriptType || (UnlockScriptType = {}));
function getAddressFromUnlockScript(unlockScript) {
    if (!(0, utils_1.isHexString)(unlockScript)) {
        throw new Error(`Invalid unlock script ${unlockScript}, expected a hex string`);
    }
    const decoded = (0, utils_1.hexToBinUnsafe)(unlockScript);
    if (decoded.length === 0) throw new Error('UnlockScript is empty');
    const unlockScriptType = decoded[0];
    const unlockScriptBody = decoded.slice(1);
    if (unlockScriptType === UnlockScriptType.P2PKH) {
        if (unlockScriptBody.length !== 33) {
            throw new Error(`Invalid p2pkh unlock script: ${unlockScript}`);
        }
        return (0, address_1.addressFromPublicKey)((0, utils_1.binToHex)(unlockScriptBody));
    }
    if (unlockScriptType === UnlockScriptType.P2MPKH) {
        throw new Error('Naive multi-sig address is not supported for exchanges as it will be replaced by P2SH');
    }
    if (unlockScriptType === UnlockScriptType.P2SH) {
        let p2sh;
        try {
            p2sh = unlock_script_codec_1.unlockScriptCodec.decode(decoded).value;
        } catch (e) {
            throw new error_1.TraceableError(`Invalid p2sh unlock script: ${unlockScript}`, e);
        }
        return (0, address_1.addressFromScript)(script_codec_1.scriptCodec.encode(p2sh.script));
    }
    throw new Error('Invalid unlock script type');
}
exports.getAddressFromUnlockScript = getAddressFromUnlockScript;
function checkALPHOutput(tx) {
    const outputs = tx.unsigned.fixedOutputs;
    return outputs.every((o)=>o.tokens.length === 0);
}
function isTransferTx(tx) {
    if (tx.contractInputs.length !== 0 || tx.generatedOutputs.length !== 0 || tx.unsigned.inputs.length === 0 || tx.unsigned.scriptOpt !== undefined) {
        return false;
    }
    return true;
}
exports.isTransferTx = isTransferTx;
}}),
"[project]/node_modules/@alephium/web3/dist/src/exchange/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.getDepositInfo = exports.getALPHDepositInfo = exports.isALPHTransferTx = exports.getSenderAddress = exports.validateExchangeAddress = void 0;
var exchange_1 = __turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/exchange/exchange.js [app-ssr] (ecmascript)");
Object.defineProperty(exports, "validateExchangeAddress", {
    enumerable: true,
    get: function() {
        return exchange_1.validateExchangeAddress;
    }
});
Object.defineProperty(exports, "getSenderAddress", {
    enumerable: true,
    get: function() {
        return exchange_1.getSenderAddress;
    }
});
Object.defineProperty(exports, "isALPHTransferTx", {
    enumerable: true,
    get: function() {
        return exchange_1.isALPHTransferTx;
    }
});
Object.defineProperty(exports, "getALPHDepositInfo", {
    enumerable: true,
    get: function() {
        return exchange_1.getALPHDepositInfo;
    }
});
Object.defineProperty(exports, "getDepositInfo", {
    enumerable: true,
    get: function() {
        return exchange_1.getDepositInfo;
    }
});
}}),
"[project]/node_modules/@alephium/web3/dist/src/index.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, d: __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*
Copyright 2018 - 2022 The Alephium Authors
This file is part of the alephium project.

The library is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

The library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the library. If not, see <http://www.gnu.org/licenses/>.
*/ var __createBinding = this && this.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = {
            enumerable: true,
            get: function() {
                return m[k];
            }
        };
    }
    Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {
        enumerable: true,
        value: v
    });
} : function(o, v) {
    o["default"] = v;
});
var __exportStar = this && this.__exportStar || function(m, exports1) {
    for(var p in m)if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports1, p)) __createBinding(exports1, m, p);
};
var __importStar = this && this.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
        for(var k in mod)if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.utils = exports.codec = exports.web3 = void 0;
BigInt.prototype['toJSON'] = function() {
    return this.toString();
};
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/api/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/contract/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/signer/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/transaction/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/token/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/constants.js [app-ssr] (ecmascript)"), exports);
exports.web3 = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/global.js [app-ssr] (ecmascript)"));
exports.codec = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/codec/index.js [app-ssr] (ecmascript)"));
exports.utils = __importStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/utils/index.js [app-ssr] (ecmascript)"));
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/debug.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/block/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/address/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/exchange/index.js [app-ssr] (ecmascript)"), exports);
__exportStar(__turbopack_context__.r("[project]/node_modules/@alephium/web3/dist/src/error.js [app-ssr] (ecmascript)"), exports);
}}),

};

//# sourceMappingURL=node_modules_%40alephium_web3_dist_src_ef707184._.js.map